// Autogenerated
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { DataValue } from './DataValue';
import { DiagnosticInfo } from './DiagnosticInfo';
import { ExpandedNodeId } from './ExpandedNodeId';
import { ExtensionObject } from './ExtensionObject';
import { Guid } from './Guid';
import { LocalizedText } from './LocalizedText';
import { NodeId } from './NodeId';
import { NodeIds } from './NodeIds';
import { QualifiedName } from './QualifiedName';
import { Variant } from './Variant';
import { StatusCode } from './StatusCode';
import {
  SByte,
  Byte,
  Int16,
  UInt16,
  Int32,
  UInt32,
  Int64,
  Float,
  Double,
  UaString,
  ByteString
} from './Primitives';
import { BinaryDataEncoder, BinaryDataDecoder } from '../BinaryDataEncoding';
import { decode, encode, typeId } from '../symbols';
export enum NodeIdType {
    TwoByte = 0,
    FourByte = 1,
    Numeric = 2,
    String = 3,
    Guid = 4,
    ByteString = 5
}
export enum NamingRuleType {
    Mandatory = 1,
    Optional = 2,
    Constraint = 3
}
export interface KeyValuePairOptions {
    key?: QualifiedName;
    value?: Variant;
}
export class KeyValuePair implements KeyValuePairOptions {
    key: QualifiedName;
    value: Variant;
    constructor(options?: KeyValuePairOptions) {
        this.key = options?.key ?? new QualifiedName();
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.KeyValuePair_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.key);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): KeyValuePair {
        const key = decoder.readType(QualifiedName);
        const value = decoder.readType(Variant);
        return new KeyValuePair({
            key,
            value
        });
    }
}
export interface AdditionalParametersTypeOptions {
    parameters?: KeyValuePair[];
}
export class AdditionalParametersType implements AdditionalParametersTypeOptions {
    parameters?: KeyValuePair[];
    constructor(options?: AdditionalParametersTypeOptions) {
        this.parameters = options?.parameters;
    }
    static [typeId] = NodeIds.AdditionalParametersType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.parameters);
    }
    static [decode](decoder: BinaryDataDecoder): AdditionalParametersType {
        const parameters = decoder.readTypeArray(KeyValuePair);
        return new AdditionalParametersType({
            parameters
        });
    }
}
export interface EphemeralKeyTypeOptions {
    publicKey?: ByteString;
    signature?: ByteString;
}
export class EphemeralKeyType implements EphemeralKeyTypeOptions {
    publicKey?: ByteString;
    signature?: ByteString;
    constructor(options?: EphemeralKeyTypeOptions) {
        this.publicKey = options?.publicKey;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.EphemeralKeyType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.publicKey);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): EphemeralKeyType {
        const publicKey = decoder.readByteString();
        const signature = decoder.readByteString();
        return new EphemeralKeyType({
            publicKey,
            signature
        });
    }
}
export interface EndpointTypeOptions {
    endpointUrl?: UaString;
    securityMode?: MessageSecurityMode;
    securityPolicyUri?: UaString;
    transportProfileUri?: UaString;
}
export class EndpointType implements EndpointTypeOptions {
    endpointUrl?: UaString;
    securityMode: MessageSecurityMode;
    securityPolicyUri?: UaString;
    transportProfileUri?: UaString;
    constructor(options?: EndpointTypeOptions) {
        this.endpointUrl = options?.endpointUrl;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.transportProfileUri = options?.transportProfileUri;
    }
    static [typeId] = NodeIds.EndpointType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.endpointUrl);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeString(this.transportProfileUri);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointType {
        const endpointUrl = decoder.readString();
        const securityMode = decoder.readUInt32();
        const securityPolicyUri = decoder.readString();
        const transportProfileUri = decoder.readString();
        return new EndpointType({
            endpointUrl,
            securityMode,
            securityPolicyUri,
            transportProfileUri
        });
    }
}
export interface RationalNumberOptions {
    numerator?: Int32;
    denominator?: UInt32;
}
export class RationalNumber implements RationalNumberOptions {
    numerator: Int32;
    denominator: UInt32;
    constructor(options?: RationalNumberOptions) {
        this.numerator = options?.numerator ?? 0;
        this.denominator = options?.denominator ?? 0;
    }
    static [typeId] = NodeIds.RationalNumber_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt32(this.numerator);
        encoder.writeUInt32(this.denominator);
    }
    static [decode](decoder: BinaryDataDecoder): RationalNumber {
        const numerator = decoder.readInt32();
        const denominator = decoder.readUInt32();
        return new RationalNumber({
            numerator,
            denominator
        });
    }
}
export class Vector {
    static [typeId] = NodeIds.Vector_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Vector {
        return new Vector();
    }
}
export interface ThreeDVectorOptions {
    x?: Double;
    y?: Double;
    z?: Double;
}
export class ThreeDVector implements ThreeDVectorOptions {
    x: Double;
    y: Double;
    z: Double;
    constructor(options?: ThreeDVectorOptions) {
        this.x = options?.x ?? 0;
        this.y = options?.y ?? 0;
        this.z = options?.z ?? 0;
    }
    static [typeId] = NodeIds.ThreeDVector_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeDouble(this.y);
        encoder.writeDouble(this.z);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDVector {
        const x = decoder.readDouble();
        const y = decoder.readDouble();
        const z = decoder.readDouble();
        return new ThreeDVector({
            x,
            y,
            z
        });
    }
}
export class CartesianCoordinates {
    static [typeId] = NodeIds.CartesianCoordinates_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): CartesianCoordinates {
        return new CartesianCoordinates();
    }
}
export interface ThreeDCartesianCoordinatesOptions {
    x?: Double;
    y?: Double;
    z?: Double;
}
export class ThreeDCartesianCoordinates implements ThreeDCartesianCoordinatesOptions {
    x: Double;
    y: Double;
    z: Double;
    constructor(options?: ThreeDCartesianCoordinatesOptions) {
        this.x = options?.x ?? 0;
        this.y = options?.y ?? 0;
        this.z = options?.z ?? 0;
    }
    static [typeId] = NodeIds.ThreeDCartesianCoordinates_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeDouble(this.y);
        encoder.writeDouble(this.z);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDCartesianCoordinates {
        const x = decoder.readDouble();
        const y = decoder.readDouble();
        const z = decoder.readDouble();
        return new ThreeDCartesianCoordinates({
            x,
            y,
            z
        });
    }
}
export class Orientation {
    static [typeId] = NodeIds.Orientation_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Orientation {
        return new Orientation();
    }
}
export interface ThreeDOrientationOptions {
    a?: Double;
    b?: Double;
    c?: Double;
}
export class ThreeDOrientation implements ThreeDOrientationOptions {
    a: Double;
    b: Double;
    c: Double;
    constructor(options?: ThreeDOrientationOptions) {
        this.a = options?.a ?? 0;
        this.b = options?.b ?? 0;
        this.c = options?.c ?? 0;
    }
    static [typeId] = NodeIds.ThreeDOrientation_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.a);
        encoder.writeDouble(this.b);
        encoder.writeDouble(this.c);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDOrientation {
        const a = decoder.readDouble();
        const b = decoder.readDouble();
        const c = decoder.readDouble();
        return new ThreeDOrientation({
            a,
            b,
            c
        });
    }
}
export class Frame {
    static [typeId] = NodeIds.Frame_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Frame {
        return new Frame();
    }
}
export interface ThreeDFrameOptions {
    cartesianCoordinates?: ThreeDCartesianCoordinates;
    orientation?: ThreeDOrientation;
}
export class ThreeDFrame implements ThreeDFrameOptions {
    cartesianCoordinates: ThreeDCartesianCoordinates;
    orientation: ThreeDOrientation;
    constructor(options?: ThreeDFrameOptions) {
        this.cartesianCoordinates = options?.cartesianCoordinates ?? new ThreeDCartesianCoordinates();
        this.orientation = options?.orientation ?? new ThreeDOrientation();
    }
    static [typeId] = NodeIds.ThreeDFrame_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.cartesianCoordinates);
        encoder.writeType(this.orientation);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDFrame {
        const cartesianCoordinates = decoder.readType(ThreeDCartesianCoordinates);
        const orientation = decoder.readType(ThreeDOrientation);
        return new ThreeDFrame({
            cartesianCoordinates,
            orientation
        });
    }
}
export enum OpenFileMode {
    Read = 1,
    Write = 2,
    EraseExisting = 4,
    Append = 8
}
export enum IdentityCriteriaType {
    UserName = 1,
    Thumbprint = 2,
    Role = 3,
    GroupId = 4,
    Anonymous = 5,
    AuthenticatedUser = 6
}
export interface IdentityMappingRuleTypeOptions {
    criteriaType?: IdentityCriteriaType;
    criteria?: UaString;
}
export class IdentityMappingRuleType implements IdentityMappingRuleTypeOptions {
    criteriaType: IdentityCriteriaType;
    criteria?: UaString;
    constructor(options?: IdentityMappingRuleTypeOptions) {
        this.criteriaType = options?.criteriaType ?? IdentityCriteriaType.UserName;
        this.criteria = options?.criteria;
    }
    static [typeId] = NodeIds.IdentityMappingRuleType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.criteriaType);
        encoder.writeString(this.criteria);
    }
    static [decode](decoder: BinaryDataDecoder): IdentityMappingRuleType {
        const criteriaType = decoder.readUInt32();
        const criteria = decoder.readString();
        return new IdentityMappingRuleType({
            criteriaType,
            criteria
        });
    }
}
export interface CurrencyUnitTypeOptions {
    numericCode?: Int16;
    exponent?: SByte;
    alphabeticCode?: UaString;
    currency?: LocalizedText;
}
export class CurrencyUnitType implements CurrencyUnitTypeOptions {
    numericCode: Int16;
    exponent: SByte;
    alphabeticCode?: UaString;
    currency: LocalizedText;
    constructor(options?: CurrencyUnitTypeOptions) {
        this.numericCode = options?.numericCode ?? 0;
        this.exponent = options?.exponent ?? 0;
        this.alphabeticCode = options?.alphabeticCode;
        this.currency = options?.currency ?? new LocalizedText();
    }
    static [typeId] = NodeIds.CurrencyUnitType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.numericCode);
        encoder.writeSByte(this.exponent);
        encoder.writeString(this.alphabeticCode);
        encoder.writeType(this.currency);
    }
    static [decode](decoder: BinaryDataDecoder): CurrencyUnitType {
        const numericCode = decoder.readInt16();
        const exponent = decoder.readSByte();
        const alphabeticCode = decoder.readString();
        const currency = decoder.readType(LocalizedText);
        return new CurrencyUnitType({
            numericCode,
            exponent,
            alphabeticCode,
            currency
        });
    }
}
export enum TrustListMasks {
    None = 0,
    TrustedCertificates = 1,
    TrustedCrls = 2,
    IssuerCertificates = 4,
    IssuerCrls = 8,
    All = 15
}
export interface TrustListDataTypeOptions {
    specifiedLists?: UInt32;
    trustedCertificates?: ByteString[];
    trustedCrls?: ByteString[];
    issuerCertificates?: ByteString[];
    issuerCrls?: ByteString[];
}
export class TrustListDataType implements TrustListDataTypeOptions {
    specifiedLists: UInt32;
    trustedCertificates?: ByteString[];
    trustedCrls?: ByteString[];
    issuerCertificates?: ByteString[];
    issuerCrls?: ByteString[];
    constructor(options?: TrustListDataTypeOptions) {
        this.specifiedLists = options?.specifiedLists ?? 0;
        this.trustedCertificates = options?.trustedCertificates;
        this.trustedCrls = options?.trustedCrls;
        this.issuerCertificates = options?.issuerCertificates;
        this.issuerCrls = options?.issuerCrls;
    }
    static [typeId] = NodeIds.TrustListDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedLists);
        encoder.writeByteStringArray(this.trustedCertificates);
        encoder.writeByteStringArray(this.trustedCrls);
        encoder.writeByteStringArray(this.issuerCertificates);
        encoder.writeByteStringArray(this.issuerCrls);
    }
    static [decode](decoder: BinaryDataDecoder): TrustListDataType {
        const specifiedLists = decoder.readUInt32();
        const trustedCertificates = decoder.readByteStringArray();
        const trustedCrls = decoder.readByteStringArray();
        const issuerCertificates = decoder.readByteStringArray();
        const issuerCrls = decoder.readByteStringArray();
        return new TrustListDataType({
            specifiedLists,
            trustedCertificates,
            trustedCrls,
            issuerCertificates,
            issuerCrls
        });
    }
}
export interface DecimalDataTypeOptions {
    scale?: Int16;
    value?: ByteString;
}
export class DecimalDataType implements DecimalDataTypeOptions {
    scale: Int16;
    value?: ByteString;
    constructor(options?: DecimalDataTypeOptions) {
        this.scale = options?.scale ?? 0;
        this.value = options?.value;
    }
    static [typeId] = NodeIds.DecimalDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.scale);
        encoder.writeByteString(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): DecimalDataType {
        const scale = decoder.readInt16();
        const value = decoder.readByteString();
        return new DecimalDataType({
            scale,
            value
        });
    }
}
export interface DataTypeSchemaHeaderOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
}
export class DataTypeSchemaHeader implements DataTypeSchemaHeaderOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
    constructor(options?: DataTypeSchemaHeaderOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
    }
    static [typeId] = NodeIds.DataTypeSchemaHeader_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeSchemaHeader {
        const namespaces = decoder.readStringArray();
        const structureDataTypes = decoder.readTypeArray(StructureDescription);
        const enumDataTypes = decoder.readTypeArray(EnumDescription);
        const simpleDataTypes = decoder.readTypeArray(SimpleTypeDescription);
        return new DataTypeSchemaHeader({
            namespaces,
            structureDataTypes,
            enumDataTypes,
            simpleDataTypes
        });
    }
}
export interface DataTypeDescriptionOptions {
    dataTypeId?: NodeId;
    name?: QualifiedName;
}
export class DataTypeDescription implements DataTypeDescriptionOptions {
    dataTypeId: NodeId;
    name: QualifiedName;
    constructor(options?: DataTypeDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
    }
    static [typeId] = NodeIds.DataTypeDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeDescription {
        const dataTypeId = decoder.readType(NodeId);
        const name = decoder.readType(QualifiedName);
        return new DataTypeDescription({
            dataTypeId,
            name
        });
    }
}
export interface StructureDescriptionOptions {
    dataTypeId?: NodeId;
    name?: QualifiedName;
    structureDefinition?: StructureDefinition;
}
export class StructureDescription implements StructureDescriptionOptions {
    dataTypeId: NodeId;
    name: QualifiedName;
    structureDefinition: StructureDefinition;
    constructor(options?: StructureDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.structureDefinition = options?.structureDefinition ?? new StructureDefinition();
    }
    static [typeId] = NodeIds.StructureDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.structureDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): StructureDescription {
        const dataTypeId = decoder.readType(NodeId);
        const name = decoder.readType(QualifiedName);
        const structureDefinition = decoder.readType(StructureDefinition);
        return new StructureDescription({
            dataTypeId,
            name,
            structureDefinition
        });
    }
}
export interface EnumDescriptionOptions {
    dataTypeId?: NodeId;
    name?: QualifiedName;
    enumDefinition?: EnumDefinition;
    builtInType?: Byte;
}
export class EnumDescription implements EnumDescriptionOptions {
    dataTypeId: NodeId;
    name: QualifiedName;
    enumDefinition: EnumDefinition;
    builtInType: Byte;
    constructor(options?: EnumDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.enumDefinition = options?.enumDefinition ?? new EnumDefinition();
        this.builtInType = options?.builtInType ?? 0;
    }
    static [typeId] = NodeIds.EnumDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.enumDefinition);
        encoder.writeByte(this.builtInType);
    }
    static [decode](decoder: BinaryDataDecoder): EnumDescription {
        const dataTypeId = decoder.readType(NodeId);
        const name = decoder.readType(QualifiedName);
        const enumDefinition = decoder.readType(EnumDefinition);
        const builtInType = decoder.readByte();
        return new EnumDescription({
            dataTypeId,
            name,
            enumDefinition,
            builtInType
        });
    }
}
export interface SimpleTypeDescriptionOptions {
    dataTypeId?: NodeId;
    name?: QualifiedName;
    baseDataType?: NodeId;
    builtInType?: Byte;
}
export class SimpleTypeDescription implements SimpleTypeDescriptionOptions {
    dataTypeId: NodeId;
    name: QualifiedName;
    baseDataType: NodeId;
    builtInType: Byte;
    constructor(options?: SimpleTypeDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.baseDataType = options?.baseDataType ?? NodeId.null();
        this.builtInType = options?.builtInType ?? 0;
    }
    static [typeId] = NodeIds.SimpleTypeDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.baseDataType);
        encoder.writeByte(this.builtInType);
    }
    static [decode](decoder: BinaryDataDecoder): SimpleTypeDescription {
        const dataTypeId = decoder.readType(NodeId);
        const name = decoder.readType(QualifiedName);
        const baseDataType = decoder.readType(NodeId);
        const builtInType = decoder.readByte();
        return new SimpleTypeDescription({
            dataTypeId,
            name,
            baseDataType,
            builtInType
        });
    }
}
export interface UABinaryFileDataTypeOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
    schemaLocation?: UaString;
    fileHeader?: KeyValuePair[];
    body?: Variant;
}
export class UABinaryFileDataType implements UABinaryFileDataTypeOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
    schemaLocation?: UaString;
    fileHeader?: KeyValuePair[];
    body: Variant;
    constructor(options?: UABinaryFileDataTypeOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
        this.schemaLocation = options?.schemaLocation;
        this.fileHeader = options?.fileHeader;
        this.body = options?.body ?? Variant.null();
    }
    static [typeId] = NodeIds.UABinaryFileDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
        encoder.writeString(this.schemaLocation);
        encoder.writeTypeArray(this.fileHeader);
        encoder.writeType(this.body);
    }
    static [decode](decoder: BinaryDataDecoder): UABinaryFileDataType {
        const namespaces = decoder.readStringArray();
        const structureDataTypes = decoder.readTypeArray(StructureDescription);
        const enumDataTypes = decoder.readTypeArray(EnumDescription);
        const simpleDataTypes = decoder.readTypeArray(SimpleTypeDescription);
        const schemaLocation = decoder.readString();
        const fileHeader = decoder.readTypeArray(KeyValuePair);
        const body = decoder.readType(Variant);
        return new UABinaryFileDataType({
            namespaces,
            structureDataTypes,
            enumDataTypes,
            simpleDataTypes,
            schemaLocation,
            fileHeader,
            body
        });
    }
}
export enum PubSubState {
    Disabled = 0,
    Paused = 1,
    Operational = 2,
    Error = 3
}
export interface DataSetMetaDataTypeOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
    name?: UaString;
    description?: LocalizedText;
    fields?: FieldMetaData[];
    dataSetClassId?: Guid;
    configurationVersion?: ConfigurationVersionDataType;
}
export class DataSetMetaDataType implements DataSetMetaDataTypeOptions {
    namespaces?: UaString[];
    structureDataTypes?: StructureDescription[];
    enumDataTypes?: EnumDescription[];
    simpleDataTypes?: SimpleTypeDescription[];
    name?: UaString;
    description: LocalizedText;
    fields?: FieldMetaData[];
    dataSetClassId: Guid;
    configurationVersion: ConfigurationVersionDataType;
    constructor(options?: DataSetMetaDataTypeOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.fields = options?.fields;
        this.dataSetClassId = options?.dataSetClassId ?? new Guid();
        this.configurationVersion = options?.configurationVersion ?? new ConfigurationVersionDataType();
    }
    static [typeId] = NodeIds.DataSetMetaDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeTypeArray(this.fields);
        encoder.writeType(this.dataSetClassId);
        encoder.writeType(this.configurationVersion);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetMetaDataType {
        const namespaces = decoder.readStringArray();
        const structureDataTypes = decoder.readTypeArray(StructureDescription);
        const enumDataTypes = decoder.readTypeArray(EnumDescription);
        const simpleDataTypes = decoder.readTypeArray(SimpleTypeDescription);
        const name = decoder.readString();
        const description = decoder.readType(LocalizedText);
        const fields = decoder.readTypeArray(FieldMetaData);
        const dataSetClassId = decoder.readType(Guid);
        const configurationVersion = decoder.readType(ConfigurationVersionDataType);
        return new DataSetMetaDataType({
            namespaces,
            structureDataTypes,
            enumDataTypes,
            simpleDataTypes,
            name,
            description,
            fields,
            dataSetClassId,
            configurationVersion
        });
    }
}
export interface FieldMetaDataOptions {
    name?: UaString;
    description?: LocalizedText;
    fieldFlags?: DataSetFieldFlags;
    builtInType?: Byte;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    maxStringLength?: UInt32;
    dataSetFieldId?: Guid;
    properties?: KeyValuePair[];
}
export class FieldMetaData implements FieldMetaDataOptions {
    name?: UaString;
    description: LocalizedText;
    fieldFlags: DataSetFieldFlags;
    builtInType: Byte;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    maxStringLength: UInt32;
    dataSetFieldId: Guid;
    properties?: KeyValuePair[];
    constructor(options?: FieldMetaDataOptions) {
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.fieldFlags = options?.fieldFlags ?? DataSetFieldFlags.None;
        this.builtInType = options?.builtInType ?? 0;
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.dataSetFieldId = options?.dataSetFieldId ?? new Guid();
        this.properties = options?.properties;
    }
    static [typeId] = NodeIds.FieldMetaData_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.fieldFlags);
        encoder.writeByte(this.builtInType);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeUInt32(this.maxStringLength);
        encoder.writeType(this.dataSetFieldId);
        encoder.writeTypeArray(this.properties);
    }
    static [decode](decoder: BinaryDataDecoder): FieldMetaData {
        const name = decoder.readString();
        const description = decoder.readType(LocalizedText);
        const fieldFlags = decoder.readUInt32();
        const builtInType = decoder.readByte();
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const maxStringLength = decoder.readUInt32();
        const dataSetFieldId = decoder.readType(Guid);
        const properties = decoder.readTypeArray(KeyValuePair);
        return new FieldMetaData({
            name,
            description,
            fieldFlags,
            builtInType,
            dataType,
            valueRank,
            arrayDimensions,
            maxStringLength,
            dataSetFieldId,
            properties
        });
    }
}
export enum DataSetFieldFlags {
    None = 0,
    PromotedField = 1
}
export interface ConfigurationVersionDataTypeOptions {
    majorVersion?: UInt32;
    minorVersion?: UInt32;
}
export class ConfigurationVersionDataType implements ConfigurationVersionDataTypeOptions {
    majorVersion: UInt32;
    minorVersion: UInt32;
    constructor(options?: ConfigurationVersionDataTypeOptions) {
        this.majorVersion = options?.majorVersion ?? 0;
        this.minorVersion = options?.minorVersion ?? 0;
    }
    static [typeId] = NodeIds.ConfigurationVersionDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.majorVersion);
        encoder.writeUInt32(this.minorVersion);
    }
    static [decode](decoder: BinaryDataDecoder): ConfigurationVersionDataType {
        const majorVersion = decoder.readUInt32();
        const minorVersion = decoder.readUInt32();
        return new ConfigurationVersionDataType({
            majorVersion,
            minorVersion
        });
    }
}
export interface PublishedDataSetDataTypeOptions {
    name?: UaString;
    dataSetFolder?: UaString[];
    dataSetMetaData?: DataSetMetaDataType;
    extensionFields?: KeyValuePair[];
    dataSetSource?: ExtensionObject;
}
export class PublishedDataSetDataType implements PublishedDataSetDataTypeOptions {
    name?: UaString;
    dataSetFolder?: UaString[];
    dataSetMetaData: DataSetMetaDataType;
    extensionFields?: KeyValuePair[];
    dataSetSource: ExtensionObject;
    constructor(options?: PublishedDataSetDataTypeOptions) {
        this.name = options?.name;
        this.dataSetFolder = options?.dataSetFolder;
        this.dataSetMetaData = options?.dataSetMetaData ?? new DataSetMetaDataType();
        this.extensionFields = options?.extensionFields;
        this.dataSetSource = options?.dataSetSource ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.PublishedDataSetDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeStringArray(this.dataSetFolder);
        encoder.writeType(this.dataSetMetaData);
        encoder.writeTypeArray(this.extensionFields);
        encoder.writeType(this.dataSetSource);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataSetDataType {
        const name = decoder.readString();
        const dataSetFolder = decoder.readStringArray();
        const dataSetMetaData = decoder.readType(DataSetMetaDataType);
        const extensionFields = decoder.readTypeArray(KeyValuePair);
        const dataSetSource = decoder.readType(ExtensionObject);
        return new PublishedDataSetDataType({
            name,
            dataSetFolder,
            dataSetMetaData,
            extensionFields,
            dataSetSource
        });
    }
}
export class PublishedDataSetSourceDataType {
    static [typeId] = NodeIds.PublishedDataSetSourceDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataSetSourceDataType {
        return new PublishedDataSetSourceDataType();
    }
}
export interface PublishedVariableDataTypeOptions {
    publishedVariable?: NodeId;
    attributeId?: UInt32;
    samplingIntervalHint?: Double;
    deadbandType?: UInt32;
    deadbandValue?: Double;
    indexRange?: UaString;
    substituteValue?: Variant;
    metaDataProperties?: QualifiedName[];
}
export class PublishedVariableDataType implements PublishedVariableDataTypeOptions {
    publishedVariable: NodeId;
    attributeId: UInt32;
    samplingIntervalHint: Double;
    deadbandType: UInt32;
    deadbandValue: Double;
    indexRange?: UaString;
    substituteValue: Variant;
    metaDataProperties?: QualifiedName[];
    constructor(options?: PublishedVariableDataTypeOptions) {
        this.publishedVariable = options?.publishedVariable ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.samplingIntervalHint = options?.samplingIntervalHint ?? 0;
        this.deadbandType = options?.deadbandType ?? 0;
        this.deadbandValue = options?.deadbandValue ?? 0;
        this.indexRange = options?.indexRange;
        this.substituteValue = options?.substituteValue ?? Variant.null();
        this.metaDataProperties = options?.metaDataProperties;
    }
    static [typeId] = NodeIds.PublishedVariableDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.publishedVariable);
        encoder.writeUInt32(this.attributeId);
        encoder.writeDouble(this.samplingIntervalHint);
        encoder.writeUInt32(this.deadbandType);
        encoder.writeDouble(this.deadbandValue);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.substituteValue);
        encoder.writeTypeArray(this.metaDataProperties);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedVariableDataType {
        const publishedVariable = decoder.readType(NodeId);
        const attributeId = decoder.readUInt32();
        const samplingIntervalHint = decoder.readDouble();
        const deadbandType = decoder.readUInt32();
        const deadbandValue = decoder.readDouble();
        const indexRange = decoder.readString();
        const substituteValue = decoder.readType(Variant);
        const metaDataProperties = decoder.readTypeArray(QualifiedName);
        return new PublishedVariableDataType({
            publishedVariable,
            attributeId,
            samplingIntervalHint,
            deadbandType,
            deadbandValue,
            indexRange,
            substituteValue,
            metaDataProperties
        });
    }
}
export interface PublishedDataItemsDataTypeOptions {
    publishedData?: PublishedVariableDataType[];
}
export class PublishedDataItemsDataType implements PublishedDataItemsDataTypeOptions {
    publishedData?: PublishedVariableDataType[];
    constructor(options?: PublishedDataItemsDataTypeOptions) {
        this.publishedData = options?.publishedData;
    }
    static [typeId] = NodeIds.PublishedDataItemsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.publishedData);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataItemsDataType {
        const publishedData = decoder.readTypeArray(PublishedVariableDataType);
        return new PublishedDataItemsDataType({
            publishedData
        });
    }
}
export interface PublishedEventsDataTypeOptions {
    eventNotifier?: NodeId;
    selectedFields?: SimpleAttributeOperand[];
    filter?: ContentFilter;
}
export class PublishedEventsDataType implements PublishedEventsDataTypeOptions {
    eventNotifier: NodeId;
    selectedFields?: SimpleAttributeOperand[];
    filter: ContentFilter;
    constructor(options?: PublishedEventsDataTypeOptions) {
        this.eventNotifier = options?.eventNotifier ?? NodeId.null();
        this.selectedFields = options?.selectedFields;
        this.filter = options?.filter ?? new ContentFilter();
    }
    static [typeId] = NodeIds.PublishedEventsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.eventNotifier);
        encoder.writeTypeArray(this.selectedFields);
        encoder.writeType(this.filter);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedEventsDataType {
        const eventNotifier = decoder.readType(NodeId);
        const selectedFields = decoder.readTypeArray(SimpleAttributeOperand);
        const filter = decoder.readType(ContentFilter);
        return new PublishedEventsDataType({
            eventNotifier,
            selectedFields,
            filter
        });
    }
}
export enum DataSetFieldContentMask {
    None = 0,
    StatusCode = 1,
    SourceTimestamp = 2,
    ServerTimestamp = 4,
    SourcePicoSeconds = 8,
    ServerPicoSeconds = 16,
    RawData = 32
}
export interface DataSetWriterDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    dataSetWriterId?: UInt16;
    dataSetFieldContentMask?: DataSetFieldContentMask;
    keyFrameCount?: UInt32;
    dataSetName?: UaString;
    dataSetWriterProperties?: KeyValuePair[];
    transportSettings?: ExtensionObject;
    messageSettings?: ExtensionObject;
}
export class DataSetWriterDataType implements DataSetWriterDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    dataSetWriterId: UInt16;
    dataSetFieldContentMask: DataSetFieldContentMask;
    keyFrameCount: UInt32;
    dataSetName?: UaString;
    dataSetWriterProperties?: KeyValuePair[];
    transportSettings: ExtensionObject;
    messageSettings: ExtensionObject;
    constructor(options?: DataSetWriterDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.dataSetWriterId = options?.dataSetWriterId ?? 0;
        this.dataSetFieldContentMask = options?.dataSetFieldContentMask ?? DataSetFieldContentMask.None;
        this.keyFrameCount = options?.keyFrameCount ?? 0;
        this.dataSetName = options?.dataSetName;
        this.dataSetWriterProperties = options?.dataSetWriterProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataSetWriterDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt16(this.dataSetWriterId);
        encoder.writeUInt32(this.dataSetFieldContentMask);
        encoder.writeUInt32(this.keyFrameCount);
        encoder.writeString(this.dataSetName);
        encoder.writeTypeArray(this.dataSetWriterProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const dataSetWriterId = decoder.readUInt16();
        const dataSetFieldContentMask = decoder.readUInt32();
        const keyFrameCount = decoder.readUInt32();
        const dataSetName = decoder.readString();
        const dataSetWriterProperties = decoder.readTypeArray(KeyValuePair);
        const transportSettings = decoder.readType(ExtensionObject);
        const messageSettings = decoder.readType(ExtensionObject);
        return new DataSetWriterDataType({
            name,
            enabled,
            dataSetWriterId,
            dataSetFieldContentMask,
            keyFrameCount,
            dataSetName,
            dataSetWriterProperties,
            transportSettings,
            messageSettings
        });
    }
}
export class DataSetWriterTransportDataType {
    static [typeId] = NodeIds.DataSetWriterTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterTransportDataType {
        return new DataSetWriterTransportDataType();
    }
}
export class DataSetWriterMessageDataType {
    static [typeId] = NodeIds.DataSetWriterMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterMessageDataType {
        return new DataSetWriterMessageDataType();
    }
}
export interface PubSubGroupDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    securityMode?: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize?: UInt32;
    groupProperties?: KeyValuePair[];
}
export class PubSubGroupDataType implements PubSubGroupDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    securityMode: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize: UInt32;
    groupProperties?: KeyValuePair[];
    constructor(options?: PubSubGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
    }
    static [typeId] = NodeIds.PubSubGroupDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubGroupDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const securityMode = decoder.readUInt32();
        const securityGroupId = decoder.readString();
        const securityKeyServices = decoder.readTypeArray(EndpointDescription);
        const maxNetworkMessageSize = decoder.readUInt32();
        const groupProperties = decoder.readTypeArray(KeyValuePair);
        return new PubSubGroupDataType({
            name,
            enabled,
            securityMode,
            securityGroupId,
            securityKeyServices,
            maxNetworkMessageSize,
            groupProperties
        });
    }
}
export interface WriterGroupDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    securityMode?: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize?: UInt32;
    groupProperties?: KeyValuePair[];
    writerGroupId?: UInt16;
    publishingInterval?: Double;
    keepAliveTime?: Double;
    priority?: Byte;
    localeIds?: UaString[];
    headerLayoutUri?: UaString;
    transportSettings?: ExtensionObject;
    messageSettings?: ExtensionObject;
    dataSetWriters?: DataSetWriterDataType[];
}
export class WriterGroupDataType implements WriterGroupDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    securityMode: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize: UInt32;
    groupProperties?: KeyValuePair[];
    writerGroupId: UInt16;
    publishingInterval: Double;
    keepAliveTime: Double;
    priority: Byte;
    localeIds?: UaString[];
    headerLayoutUri?: UaString;
    transportSettings: ExtensionObject;
    messageSettings: ExtensionObject;
    dataSetWriters?: DataSetWriterDataType[];
    constructor(options?: WriterGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
        this.writerGroupId = options?.writerGroupId ?? 0;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.keepAliveTime = options?.keepAliveTime ?? 0;
        this.priority = options?.priority ?? 0;
        this.localeIds = options?.localeIds;
        this.headerLayoutUri = options?.headerLayoutUri;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.dataSetWriters = options?.dataSetWriters;
    }
    static [typeId] = NodeIds.WriterGroupDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
        encoder.writeUInt16(this.writerGroupId);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeDouble(this.keepAliveTime);
        encoder.writeByte(this.priority);
        encoder.writeStringArray(this.localeIds);
        encoder.writeString(this.headerLayoutUri);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeTypeArray(this.dataSetWriters);
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const securityMode = decoder.readUInt32();
        const securityGroupId = decoder.readString();
        const securityKeyServices = decoder.readTypeArray(EndpointDescription);
        const maxNetworkMessageSize = decoder.readUInt32();
        const groupProperties = decoder.readTypeArray(KeyValuePair);
        const writerGroupId = decoder.readUInt16();
        const publishingInterval = decoder.readDouble();
        const keepAliveTime = decoder.readDouble();
        const priority = decoder.readByte();
        const localeIds = decoder.readStringArray();
        const headerLayoutUri = decoder.readString();
        const transportSettings = decoder.readType(ExtensionObject);
        const messageSettings = decoder.readType(ExtensionObject);
        const dataSetWriters = decoder.readTypeArray(DataSetWriterDataType);
        return new WriterGroupDataType({
            name,
            enabled,
            securityMode,
            securityGroupId,
            securityKeyServices,
            maxNetworkMessageSize,
            groupProperties,
            writerGroupId,
            publishingInterval,
            keepAliveTime,
            priority,
            localeIds,
            headerLayoutUri,
            transportSettings,
            messageSettings,
            dataSetWriters
        });
    }
}
export class WriterGroupTransportDataType {
    static [typeId] = NodeIds.WriterGroupTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupTransportDataType {
        return new WriterGroupTransportDataType();
    }
}
export class WriterGroupMessageDataType {
    static [typeId] = NodeIds.WriterGroupMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupMessageDataType {
        return new WriterGroupMessageDataType();
    }
}
export interface PubSubConnectionDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    publisherId?: Variant;
    transportProfileUri?: UaString;
    address?: ExtensionObject;
    connectionProperties?: KeyValuePair[];
    transportSettings?: ExtensionObject;
    writerGroups?: WriterGroupDataType[];
    readerGroups?: ReaderGroupDataType[];
}
export class PubSubConnectionDataType implements PubSubConnectionDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    publisherId: Variant;
    transportProfileUri?: UaString;
    address: ExtensionObject;
    connectionProperties?: KeyValuePair[];
    transportSettings: ExtensionObject;
    writerGroups?: WriterGroupDataType[];
    readerGroups?: ReaderGroupDataType[];
    constructor(options?: PubSubConnectionDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.publisherId = options?.publisherId ?? Variant.null();
        this.transportProfileUri = options?.transportProfileUri;
        this.address = options?.address ?? new ExtensionObject();
        this.connectionProperties = options?.connectionProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.writerGroups = options?.writerGroups;
        this.readerGroups = options?.readerGroups;
    }
    static [typeId] = NodeIds.PubSubConnectionDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeType(this.publisherId);
        encoder.writeString(this.transportProfileUri);
        encoder.writeType(this.address);
        encoder.writeTypeArray(this.connectionProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeTypeArray(this.writerGroups);
        encoder.writeTypeArray(this.readerGroups);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubConnectionDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const publisherId = decoder.readType(Variant);
        const transportProfileUri = decoder.readString();
        const address = decoder.readType(ExtensionObject);
        const connectionProperties = decoder.readTypeArray(KeyValuePair);
        const transportSettings = decoder.readType(ExtensionObject);
        const writerGroups = decoder.readTypeArray(WriterGroupDataType);
        const readerGroups = decoder.readTypeArray(ReaderGroupDataType);
        return new PubSubConnectionDataType({
            name,
            enabled,
            publisherId,
            transportProfileUri,
            address,
            connectionProperties,
            transportSettings,
            writerGroups,
            readerGroups
        });
    }
}
export class ConnectionTransportDataType {
    static [typeId] = NodeIds.ConnectionTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ConnectionTransportDataType {
        return new ConnectionTransportDataType();
    }
}
export interface NetworkAddressDataTypeOptions {
    networkInterface?: UaString;
}
export class NetworkAddressDataType implements NetworkAddressDataTypeOptions {
    networkInterface?: UaString;
    constructor(options?: NetworkAddressDataTypeOptions) {
        this.networkInterface = options?.networkInterface;
    }
    static [typeId] = NodeIds.NetworkAddressDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.networkInterface);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkAddressDataType {
        const networkInterface = decoder.readString();
        return new NetworkAddressDataType({
            networkInterface
        });
    }
}
export interface NetworkAddressUrlDataTypeOptions {
    networkInterface?: UaString;
    url?: UaString;
}
export class NetworkAddressUrlDataType implements NetworkAddressUrlDataTypeOptions {
    networkInterface?: UaString;
    url?: UaString;
    constructor(options?: NetworkAddressUrlDataTypeOptions) {
        this.networkInterface = options?.networkInterface;
        this.url = options?.url;
    }
    static [typeId] = NodeIds.NetworkAddressUrlDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.networkInterface);
        encoder.writeString(this.url);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkAddressUrlDataType {
        const networkInterface = decoder.readString();
        const url = decoder.readString();
        return new NetworkAddressUrlDataType({
            networkInterface,
            url
        });
    }
}
export interface ReaderGroupDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    securityMode?: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize?: UInt32;
    groupProperties?: KeyValuePair[];
    transportSettings?: ExtensionObject;
    messageSettings?: ExtensionObject;
    dataSetReaders?: DataSetReaderDataType[];
}
export class ReaderGroupDataType implements ReaderGroupDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    securityMode: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    maxNetworkMessageSize: UInt32;
    groupProperties?: KeyValuePair[];
    transportSettings: ExtensionObject;
    messageSettings: ExtensionObject;
    dataSetReaders?: DataSetReaderDataType[];
    constructor(options?: ReaderGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.dataSetReaders = options?.dataSetReaders;
    }
    static [typeId] = NodeIds.ReaderGroupDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeTypeArray(this.dataSetReaders);
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const securityMode = decoder.readUInt32();
        const securityGroupId = decoder.readString();
        const securityKeyServices = decoder.readTypeArray(EndpointDescription);
        const maxNetworkMessageSize = decoder.readUInt32();
        const groupProperties = decoder.readTypeArray(KeyValuePair);
        const transportSettings = decoder.readType(ExtensionObject);
        const messageSettings = decoder.readType(ExtensionObject);
        const dataSetReaders = decoder.readTypeArray(DataSetReaderDataType);
        return new ReaderGroupDataType({
            name,
            enabled,
            securityMode,
            securityGroupId,
            securityKeyServices,
            maxNetworkMessageSize,
            groupProperties,
            transportSettings,
            messageSettings,
            dataSetReaders
        });
    }
}
export class ReaderGroupTransportDataType {
    static [typeId] = NodeIds.ReaderGroupTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupTransportDataType {
        return new ReaderGroupTransportDataType();
    }
}
export class ReaderGroupMessageDataType {
    static [typeId] = NodeIds.ReaderGroupMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupMessageDataType {
        return new ReaderGroupMessageDataType();
    }
}
export interface DataSetReaderDataTypeOptions {
    name?: UaString;
    enabled?: boolean;
    publisherId?: Variant;
    writerGroupId?: UInt16;
    dataSetWriterId?: UInt16;
    dataSetMetaData?: DataSetMetaDataType;
    dataSetFieldContentMask?: DataSetFieldContentMask;
    messageReceiveTimeout?: Double;
    keyFrameCount?: UInt32;
    headerLayoutUri?: UaString;
    securityMode?: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    dataSetReaderProperties?: KeyValuePair[];
    transportSettings?: ExtensionObject;
    messageSettings?: ExtensionObject;
    subscribedDataSet?: ExtensionObject;
}
export class DataSetReaderDataType implements DataSetReaderDataTypeOptions {
    name?: UaString;
    enabled: boolean;
    publisherId: Variant;
    writerGroupId: UInt16;
    dataSetWriterId: UInt16;
    dataSetMetaData: DataSetMetaDataType;
    dataSetFieldContentMask: DataSetFieldContentMask;
    messageReceiveTimeout: Double;
    keyFrameCount: UInt32;
    headerLayoutUri?: UaString;
    securityMode: MessageSecurityMode;
    securityGroupId?: UaString;
    securityKeyServices?: EndpointDescription[];
    dataSetReaderProperties?: KeyValuePair[];
    transportSettings: ExtensionObject;
    messageSettings: ExtensionObject;
    subscribedDataSet: ExtensionObject;
    constructor(options?: DataSetReaderDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.publisherId = options?.publisherId ?? Variant.null();
        this.writerGroupId = options?.writerGroupId ?? 0;
        this.dataSetWriterId = options?.dataSetWriterId ?? 0;
        this.dataSetMetaData = options?.dataSetMetaData ?? new DataSetMetaDataType();
        this.dataSetFieldContentMask = options?.dataSetFieldContentMask ?? DataSetFieldContentMask.None;
        this.messageReceiveTimeout = options?.messageReceiveTimeout ?? 0;
        this.keyFrameCount = options?.keyFrameCount ?? 0;
        this.headerLayoutUri = options?.headerLayoutUri;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.dataSetReaderProperties = options?.dataSetReaderProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.subscribedDataSet = options?.subscribedDataSet ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataSetReaderDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeType(this.publisherId);
        encoder.writeUInt16(this.writerGroupId);
        encoder.writeUInt16(this.dataSetWriterId);
        encoder.writeType(this.dataSetMetaData);
        encoder.writeUInt32(this.dataSetFieldContentMask);
        encoder.writeDouble(this.messageReceiveTimeout);
        encoder.writeUInt32(this.keyFrameCount);
        encoder.writeString(this.headerLayoutUri);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeTypeArray(this.dataSetReaderProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeType(this.subscribedDataSet);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderDataType {
        const name = decoder.readString();
        const enabled = decoder.readBoolean();
        const publisherId = decoder.readType(Variant);
        const writerGroupId = decoder.readUInt16();
        const dataSetWriterId = decoder.readUInt16();
        const dataSetMetaData = decoder.readType(DataSetMetaDataType);
        const dataSetFieldContentMask = decoder.readUInt32();
        const messageReceiveTimeout = decoder.readDouble();
        const keyFrameCount = decoder.readUInt32();
        const headerLayoutUri = decoder.readString();
        const securityMode = decoder.readUInt32();
        const securityGroupId = decoder.readString();
        const securityKeyServices = decoder.readTypeArray(EndpointDescription);
        const dataSetReaderProperties = decoder.readTypeArray(KeyValuePair);
        const transportSettings = decoder.readType(ExtensionObject);
        const messageSettings = decoder.readType(ExtensionObject);
        const subscribedDataSet = decoder.readType(ExtensionObject);
        return new DataSetReaderDataType({
            name,
            enabled,
            publisherId,
            writerGroupId,
            dataSetWriterId,
            dataSetMetaData,
            dataSetFieldContentMask,
            messageReceiveTimeout,
            keyFrameCount,
            headerLayoutUri,
            securityMode,
            securityGroupId,
            securityKeyServices,
            dataSetReaderProperties,
            transportSettings,
            messageSettings,
            subscribedDataSet
        });
    }
}
export class DataSetReaderTransportDataType {
    static [typeId] = NodeIds.DataSetReaderTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderTransportDataType {
        return new DataSetReaderTransportDataType();
    }
}
export class DataSetReaderMessageDataType {
    static [typeId] = NodeIds.DataSetReaderMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderMessageDataType {
        return new DataSetReaderMessageDataType();
    }
}
export class SubscribedDataSetDataType {
    static [typeId] = NodeIds.SubscribedDataSetDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): SubscribedDataSetDataType {
        return new SubscribedDataSetDataType();
    }
}
export interface TargetVariablesDataTypeOptions {
    targetVariables?: FieldTargetDataType[];
}
export class TargetVariablesDataType implements TargetVariablesDataTypeOptions {
    targetVariables?: FieldTargetDataType[];
    constructor(options?: TargetVariablesDataTypeOptions) {
        this.targetVariables = options?.targetVariables;
    }
    static [typeId] = NodeIds.TargetVariablesDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.targetVariables);
    }
    static [decode](decoder: BinaryDataDecoder): TargetVariablesDataType {
        const targetVariables = decoder.readTypeArray(FieldTargetDataType);
        return new TargetVariablesDataType({
            targetVariables
        });
    }
}
export interface FieldTargetDataTypeOptions {
    dataSetFieldId?: Guid;
    receiverIndexRange?: UaString;
    targetNodeId?: NodeId;
    attributeId?: UInt32;
    writeIndexRange?: UaString;
    overrideValueHandling?: OverrideValueHandling;
    overrideValue?: Variant;
}
export class FieldTargetDataType implements FieldTargetDataTypeOptions {
    dataSetFieldId: Guid;
    receiverIndexRange?: UaString;
    targetNodeId: NodeId;
    attributeId: UInt32;
    writeIndexRange?: UaString;
    overrideValueHandling: OverrideValueHandling;
    overrideValue: Variant;
    constructor(options?: FieldTargetDataTypeOptions) {
        this.dataSetFieldId = options?.dataSetFieldId ?? new Guid();
        this.receiverIndexRange = options?.receiverIndexRange;
        this.targetNodeId = options?.targetNodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.writeIndexRange = options?.writeIndexRange;
        this.overrideValueHandling = options?.overrideValueHandling ?? OverrideValueHandling.Disabled;
        this.overrideValue = options?.overrideValue ?? Variant.null();
    }
    static [typeId] = NodeIds.FieldTargetDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataSetFieldId);
        encoder.writeString(this.receiverIndexRange);
        encoder.writeType(this.targetNodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.writeIndexRange);
        encoder.writeUInt32(this.overrideValueHandling);
        encoder.writeType(this.overrideValue);
    }
    static [decode](decoder: BinaryDataDecoder): FieldTargetDataType {
        const dataSetFieldId = decoder.readType(Guid);
        const receiverIndexRange = decoder.readString();
        const targetNodeId = decoder.readType(NodeId);
        const attributeId = decoder.readUInt32();
        const writeIndexRange = decoder.readString();
        const overrideValueHandling = decoder.readUInt32();
        const overrideValue = decoder.readType(Variant);
        return new FieldTargetDataType({
            dataSetFieldId,
            receiverIndexRange,
            targetNodeId,
            attributeId,
            writeIndexRange,
            overrideValueHandling,
            overrideValue
        });
    }
}
export enum OverrideValueHandling {
    Disabled = 0,
    LastUsableValue = 1,
    OverrideValue = 2
}
export interface SubscribedDataSetMirrorDataTypeOptions {
    parentNodeName?: UaString;
    rolePermissions?: RolePermissionType[];
}
export class SubscribedDataSetMirrorDataType implements SubscribedDataSetMirrorDataTypeOptions {
    parentNodeName?: UaString;
    rolePermissions?: RolePermissionType[];
    constructor(options?: SubscribedDataSetMirrorDataTypeOptions) {
        this.parentNodeName = options?.parentNodeName;
        this.rolePermissions = options?.rolePermissions;
    }
    static [typeId] = NodeIds.SubscribedDataSetMirrorDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.parentNodeName);
        encoder.writeTypeArray(this.rolePermissions);
    }
    static [decode](decoder: BinaryDataDecoder): SubscribedDataSetMirrorDataType {
        const parentNodeName = decoder.readString();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        return new SubscribedDataSetMirrorDataType({
            parentNodeName,
            rolePermissions
        });
    }
}
export interface PubSubConfigurationDataTypeOptions {
    publishedDataSets?: PublishedDataSetDataType[];
    connections?: PubSubConnectionDataType[];
    enabled?: boolean;
}
export class PubSubConfigurationDataType implements PubSubConfigurationDataTypeOptions {
    publishedDataSets?: PublishedDataSetDataType[];
    connections?: PubSubConnectionDataType[];
    enabled: boolean;
    constructor(options?: PubSubConfigurationDataTypeOptions) {
        this.publishedDataSets = options?.publishedDataSets;
        this.connections = options?.connections;
        this.enabled = options?.enabled ?? false;
    }
    static [typeId] = NodeIds.PubSubConfigurationDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.publishedDataSets);
        encoder.writeTypeArray(this.connections);
        encoder.writeBoolean(this.enabled);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubConfigurationDataType {
        const publishedDataSets = decoder.readTypeArray(PublishedDataSetDataType);
        const connections = decoder.readTypeArray(PubSubConnectionDataType);
        const enabled = decoder.readBoolean();
        return new PubSubConfigurationDataType({
            publishedDataSets,
            connections,
            enabled
        });
    }
}
export enum DataSetOrderingType {
    Undefined = 0,
    AscendingWriterId = 1,
    AscendingWriterIdSingle = 2
}
export enum UadpNetworkMessageContentMask {
    None = 0,
    PublisherId = 1,
    GroupHeader = 2,
    WriterGroupId = 4,
    GroupVersion = 8,
    NetworkMessageNumber = 16,
    SequenceNumber = 32,
    PayloadHeader = 64,
    Timestamp = 128,
    PicoSeconds = 256,
    DataSetClassId = 512,
    PromotedFields = 1024
}
export interface UadpWriterGroupMessageDataTypeOptions {
    groupVersion?: UInt32;
    dataSetOrdering?: DataSetOrderingType;
    networkMessageContentMask?: UadpNetworkMessageContentMask;
    samplingOffset?: Double;
    publishingOffset?: Double[];
}
export class UadpWriterGroupMessageDataType implements UadpWriterGroupMessageDataTypeOptions {
    groupVersion: UInt32;
    dataSetOrdering: DataSetOrderingType;
    networkMessageContentMask: UadpNetworkMessageContentMask;
    samplingOffset: Double;
    publishingOffset?: Double[];
    constructor(options?: UadpWriterGroupMessageDataTypeOptions) {
        this.groupVersion = options?.groupVersion ?? 0;
        this.dataSetOrdering = options?.dataSetOrdering ?? DataSetOrderingType.Undefined;
        this.networkMessageContentMask = options?.networkMessageContentMask ?? UadpNetworkMessageContentMask.None;
        this.samplingOffset = options?.samplingOffset ?? 0;
        this.publishingOffset = options?.publishingOffset;
    }
    static [typeId] = NodeIds.UadpWriterGroupMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.groupVersion);
        encoder.writeUInt32(this.dataSetOrdering);
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeDouble(this.samplingOffset);
        encoder.writeDoubleArray(this.publishingOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpWriterGroupMessageDataType {
        const groupVersion = decoder.readUInt32();
        const dataSetOrdering = decoder.readUInt32();
        const networkMessageContentMask = decoder.readUInt32();
        const samplingOffset = decoder.readDouble();
        const publishingOffset = decoder.readDoubleArray();
        return new UadpWriterGroupMessageDataType({
            groupVersion,
            dataSetOrdering,
            networkMessageContentMask,
            samplingOffset,
            publishingOffset
        });
    }
}
export enum UadpDataSetMessageContentMask {
    None = 0,
    Timestamp = 1,
    PicoSeconds = 2,
    Status = 4,
    MajorVersion = 8,
    MinorVersion = 16,
    SequenceNumber = 32
}
export interface UadpDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask?: UadpDataSetMessageContentMask;
    configuredSize?: UInt16;
    networkMessageNumber?: UInt16;
    dataSetOffset?: UInt16;
}
export class UadpDataSetWriterMessageDataType implements UadpDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask: UadpDataSetMessageContentMask;
    configuredSize: UInt16;
    networkMessageNumber: UInt16;
    dataSetOffset: UInt16;
    constructor(options?: UadpDataSetWriterMessageDataTypeOptions) {
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? UadpDataSetMessageContentMask.None;
        this.configuredSize = options?.configuredSize ?? 0;
        this.networkMessageNumber = options?.networkMessageNumber ?? 0;
        this.dataSetOffset = options?.dataSetOffset ?? 0;
    }
    static [typeId] = NodeIds.UadpDataSetWriterMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.dataSetMessageContentMask);
        encoder.writeUInt16(this.configuredSize);
        encoder.writeUInt16(this.networkMessageNumber);
        encoder.writeUInt16(this.dataSetOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpDataSetWriterMessageDataType {
        const dataSetMessageContentMask = decoder.readUInt32();
        const configuredSize = decoder.readUInt16();
        const networkMessageNumber = decoder.readUInt16();
        const dataSetOffset = decoder.readUInt16();
        return new UadpDataSetWriterMessageDataType({
            dataSetMessageContentMask,
            configuredSize,
            networkMessageNumber,
            dataSetOffset
        });
    }
}
export interface UadpDataSetReaderMessageDataTypeOptions {
    groupVersion?: UInt32;
    networkMessageNumber?: UInt16;
    dataSetOffset?: UInt16;
    dataSetClassId?: Guid;
    networkMessageContentMask?: UadpNetworkMessageContentMask;
    dataSetMessageContentMask?: UadpDataSetMessageContentMask;
    publishingInterval?: Double;
    receiveOffset?: Double;
    processingOffset?: Double;
}
export class UadpDataSetReaderMessageDataType implements UadpDataSetReaderMessageDataTypeOptions {
    groupVersion: UInt32;
    networkMessageNumber: UInt16;
    dataSetOffset: UInt16;
    dataSetClassId: Guid;
    networkMessageContentMask: UadpNetworkMessageContentMask;
    dataSetMessageContentMask: UadpDataSetMessageContentMask;
    publishingInterval: Double;
    receiveOffset: Double;
    processingOffset: Double;
    constructor(options?: UadpDataSetReaderMessageDataTypeOptions) {
        this.groupVersion = options?.groupVersion ?? 0;
        this.networkMessageNumber = options?.networkMessageNumber ?? 0;
        this.dataSetOffset = options?.dataSetOffset ?? 0;
        this.dataSetClassId = options?.dataSetClassId ?? new Guid();
        this.networkMessageContentMask = options?.networkMessageContentMask ?? UadpNetworkMessageContentMask.None;
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? UadpDataSetMessageContentMask.None;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.receiveOffset = options?.receiveOffset ?? 0;
        this.processingOffset = options?.processingOffset ?? 0;
    }
    static [typeId] = NodeIds.UadpDataSetReaderMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.groupVersion);
        encoder.writeUInt16(this.networkMessageNumber);
        encoder.writeUInt16(this.dataSetOffset);
        encoder.writeType(this.dataSetClassId);
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeUInt32(this.dataSetMessageContentMask);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeDouble(this.receiveOffset);
        encoder.writeDouble(this.processingOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpDataSetReaderMessageDataType {
        const groupVersion = decoder.readUInt32();
        const networkMessageNumber = decoder.readUInt16();
        const dataSetOffset = decoder.readUInt16();
        const dataSetClassId = decoder.readType(Guid);
        const networkMessageContentMask = decoder.readUInt32();
        const dataSetMessageContentMask = decoder.readUInt32();
        const publishingInterval = decoder.readDouble();
        const receiveOffset = decoder.readDouble();
        const processingOffset = decoder.readDouble();
        return new UadpDataSetReaderMessageDataType({
            groupVersion,
            networkMessageNumber,
            dataSetOffset,
            dataSetClassId,
            networkMessageContentMask,
            dataSetMessageContentMask,
            publishingInterval,
            receiveOffset,
            processingOffset
        });
    }
}
export enum JsonNetworkMessageContentMask {
    None = 0,
    NetworkMessageHeader = 1,
    DataSetMessageHeader = 2,
    SingleDataSetMessage = 4,
    PublisherId = 8,
    DataSetClassId = 16,
    ReplyTo = 32
}
export interface JsonWriterGroupMessageDataTypeOptions {
    networkMessageContentMask?: JsonNetworkMessageContentMask;
}
export class JsonWriterGroupMessageDataType implements JsonWriterGroupMessageDataTypeOptions {
    networkMessageContentMask: JsonNetworkMessageContentMask;
    constructor(options?: JsonWriterGroupMessageDataTypeOptions) {
        this.networkMessageContentMask = options?.networkMessageContentMask ?? JsonNetworkMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonWriterGroupMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.networkMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonWriterGroupMessageDataType {
        const networkMessageContentMask = decoder.readUInt32();
        return new JsonWriterGroupMessageDataType({
            networkMessageContentMask
        });
    }
}
export enum JsonDataSetMessageContentMask {
    None = 0,
    DataSetWriterId = 1,
    MetaDataVersion = 2,
    SequenceNumber = 4,
    Timestamp = 8,
    Status = 16
}
export interface JsonDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask?: JsonDataSetMessageContentMask;
}
export class JsonDataSetWriterMessageDataType implements JsonDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask: JsonDataSetMessageContentMask;
    constructor(options?: JsonDataSetWriterMessageDataTypeOptions) {
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? JsonDataSetMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonDataSetWriterMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.dataSetMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonDataSetWriterMessageDataType {
        const dataSetMessageContentMask = decoder.readUInt32();
        return new JsonDataSetWriterMessageDataType({
            dataSetMessageContentMask
        });
    }
}
export interface JsonDataSetReaderMessageDataTypeOptions {
    networkMessageContentMask?: JsonNetworkMessageContentMask;
    dataSetMessageContentMask?: JsonDataSetMessageContentMask;
}
export class JsonDataSetReaderMessageDataType implements JsonDataSetReaderMessageDataTypeOptions {
    networkMessageContentMask: JsonNetworkMessageContentMask;
    dataSetMessageContentMask: JsonDataSetMessageContentMask;
    constructor(options?: JsonDataSetReaderMessageDataTypeOptions) {
        this.networkMessageContentMask = options?.networkMessageContentMask ?? JsonNetworkMessageContentMask.None;
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? JsonDataSetMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonDataSetReaderMessageDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeUInt32(this.dataSetMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonDataSetReaderMessageDataType {
        const networkMessageContentMask = decoder.readUInt32();
        const dataSetMessageContentMask = decoder.readUInt32();
        return new JsonDataSetReaderMessageDataType({
            networkMessageContentMask,
            dataSetMessageContentMask
        });
    }
}
export interface DatagramConnectionTransportDataTypeOptions {
    discoveryAddress?: ExtensionObject;
}
export class DatagramConnectionTransportDataType implements DatagramConnectionTransportDataTypeOptions {
    discoveryAddress: ExtensionObject;
    constructor(options?: DatagramConnectionTransportDataTypeOptions) {
        this.discoveryAddress = options?.discoveryAddress ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DatagramConnectionTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.discoveryAddress);
    }
    static [decode](decoder: BinaryDataDecoder): DatagramConnectionTransportDataType {
        const discoveryAddress = decoder.readType(ExtensionObject);
        return new DatagramConnectionTransportDataType({
            discoveryAddress
        });
    }
}
export interface DatagramWriterGroupTransportDataTypeOptions {
    messageRepeatCount?: Byte;
    messageRepeatDelay?: Double;
}
export class DatagramWriterGroupTransportDataType implements DatagramWriterGroupTransportDataTypeOptions {
    messageRepeatCount: Byte;
    messageRepeatDelay: Double;
    constructor(options?: DatagramWriterGroupTransportDataTypeOptions) {
        this.messageRepeatCount = options?.messageRepeatCount ?? 0;
        this.messageRepeatDelay = options?.messageRepeatDelay ?? 0;
    }
    static [typeId] = NodeIds.DatagramWriterGroupTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByte(this.messageRepeatCount);
        encoder.writeDouble(this.messageRepeatDelay);
    }
    static [decode](decoder: BinaryDataDecoder): DatagramWriterGroupTransportDataType {
        const messageRepeatCount = decoder.readByte();
        const messageRepeatDelay = decoder.readDouble();
        return new DatagramWriterGroupTransportDataType({
            messageRepeatCount,
            messageRepeatDelay
        });
    }
}
export interface BrokerConnectionTransportDataTypeOptions {
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
}
export class BrokerConnectionTransportDataType implements BrokerConnectionTransportDataTypeOptions {
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    constructor(options?: BrokerConnectionTransportDataTypeOptions) {
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
    }
    static [typeId] = NodeIds.BrokerConnectionTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerConnectionTransportDataType {
        const resourceUri = decoder.readString();
        const authenticationProfileUri = decoder.readString();
        return new BrokerConnectionTransportDataType({
            resourceUri,
            authenticationProfileUri
        });
    }
}
export enum BrokerTransportQualityOfService {
    NotSpecified = 0,
    BestEffort = 1,
    AtLeastOnce = 2,
    AtMostOnce = 3,
    ExactlyOnce = 4
}
export interface BrokerWriterGroupTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService;
}
export class BrokerWriterGroupTransportDataType implements BrokerWriterGroupTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    constructor(options?: BrokerWriterGroupTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
    }
    static [typeId] = NodeIds.BrokerWriterGroupTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerWriterGroupTransportDataType {
        const queueName = decoder.readString();
        const resourceUri = decoder.readString();
        const authenticationProfileUri = decoder.readString();
        const requestedDeliveryGuarantee = decoder.readUInt32();
        return new BrokerWriterGroupTransportDataType({
            queueName,
            resourceUri,
            authenticationProfileUri,
            requestedDeliveryGuarantee
        });
    }
}
export interface BrokerDataSetWriterTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService;
    metaDataQueueName?: UaString;
    metaDataUpdateTime?: Double;
}
export class BrokerDataSetWriterTransportDataType implements BrokerDataSetWriterTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    metaDataQueueName?: UaString;
    metaDataUpdateTime: Double;
    constructor(options?: BrokerDataSetWriterTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
        this.metaDataQueueName = options?.metaDataQueueName;
        this.metaDataUpdateTime = options?.metaDataUpdateTime ?? 0;
    }
    static [typeId] = NodeIds.BrokerDataSetWriterTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
        encoder.writeString(this.metaDataQueueName);
        encoder.writeDouble(this.metaDataUpdateTime);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerDataSetWriterTransportDataType {
        const queueName = decoder.readString();
        const resourceUri = decoder.readString();
        const authenticationProfileUri = decoder.readString();
        const requestedDeliveryGuarantee = decoder.readUInt32();
        const metaDataQueueName = decoder.readString();
        const metaDataUpdateTime = decoder.readDouble();
        return new BrokerDataSetWriterTransportDataType({
            queueName,
            resourceUri,
            authenticationProfileUri,
            requestedDeliveryGuarantee,
            metaDataQueueName,
            metaDataUpdateTime
        });
    }
}
export interface BrokerDataSetReaderTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService;
    metaDataQueueName?: UaString;
}
export class BrokerDataSetReaderTransportDataType implements BrokerDataSetReaderTransportDataTypeOptions {
    queueName?: UaString;
    resourceUri?: UaString;
    authenticationProfileUri?: UaString;
    requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    metaDataQueueName?: UaString;
    constructor(options?: BrokerDataSetReaderTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
        this.metaDataQueueName = options?.metaDataQueueName;
    }
    static [typeId] = NodeIds.BrokerDataSetReaderTransportDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
        encoder.writeString(this.metaDataQueueName);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerDataSetReaderTransportDataType {
        const queueName = decoder.readString();
        const resourceUri = decoder.readString();
        const authenticationProfileUri = decoder.readString();
        const requestedDeliveryGuarantee = decoder.readUInt32();
        const metaDataQueueName = decoder.readString();
        return new BrokerDataSetReaderTransportDataType({
            queueName,
            resourceUri,
            authenticationProfileUri,
            requestedDeliveryGuarantee,
            metaDataQueueName
        });
    }
}
export enum DiagnosticsLevel {
    Basic = 0,
    Advanced = 1,
    Info = 2,
    Log = 3,
    Debug = 4
}
export enum PubSubDiagnosticsCounterClassification {
    Information = 0,
    Error = 1
}
export interface AliasNameDataTypeOptions {
    aliasName?: QualifiedName;
    referencedNodes?: ExpandedNodeId[];
}
export class AliasNameDataType implements AliasNameDataTypeOptions {
    aliasName: QualifiedName;
    referencedNodes?: ExpandedNodeId[];
    constructor(options?: AliasNameDataTypeOptions) {
        this.aliasName = options?.aliasName ?? new QualifiedName();
        this.referencedNodes = options?.referencedNodes;
    }
    static [typeId] = NodeIds.AliasNameDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.aliasName);
        encoder.writeTypeArray(this.referencedNodes);
    }
    static [decode](decoder: BinaryDataDecoder): AliasNameDataType {
        const aliasName = decoder.readType(QualifiedName);
        const referencedNodes = decoder.readTypeArray(ExpandedNodeId);
        return new AliasNameDataType({
            aliasName,
            referencedNodes
        });
    }
}
export enum IdType {
    Numeric = 0,
    String = 1,
    Guid = 2,
    Opaque = 3
}
export enum NodeClass {
    Unspecified = 0,
    Object = 1,
    Variable = 2,
    Method = 4,
    ObjectType = 8,
    VariableType = 16,
    ReferenceType = 32,
    DataType = 64,
    View = 128
}
export enum PermissionType {
    None = 0,
    Browse = 1,
    ReadRolePermissions = 2,
    WriteAttribute = 4,
    WriteRolePermissions = 8,
    WriteHistorizing = 16,
    Read = 32,
    Write = 64,
    ReadHistory = 128,
    InsertHistory = 256,
    ModifyHistory = 512,
    DeleteHistory = 1024,
    ReceiveEvents = 2048,
    Call = 4096,
    AddReference = 8192,
    RemoveReference = 16384,
    DeleteNode = 32768,
    AddNode = 65536
}
export enum AccessLevelType {
    None = 0,
    CurrentRead = 1,
    CurrentWrite = 2,
    HistoryRead = 4,
    HistoryWrite = 8,
    SemanticChange = 16,
    StatusWrite = 32,
    TimestampWrite = 64
}
export enum AccessLevelExType {
    None = 0,
    CurrentRead = 1,
    CurrentWrite = 2,
    HistoryRead = 4,
    HistoryWrite = 8,
    SemanticChange = 16,
    StatusWrite = 32,
    TimestampWrite = 64,
    NonatomicRead = 256,
    NonatomicWrite = 512,
    WriteFullArrayOnly = 1024,
    NoSubDataTypes = 2048
}
export enum EventNotifierType {
    None = 0,
    SubscribeToEvents = 1,
    HistoryRead = 4,
    HistoryWrite = 8
}
export enum AccessRestrictionType {
    None = 0,
    SigningRequired = 1,
    EncryptionRequired = 2,
    SessionRequired = 4,
    ApplyRestrictionsToBrowse = 8
}
export interface RolePermissionTypeOptions {
    roleId?: NodeId;
    permissions?: PermissionType;
}
export class RolePermissionType implements RolePermissionTypeOptions {
    roleId: NodeId;
    permissions: PermissionType;
    constructor(options?: RolePermissionTypeOptions) {
        this.roleId = options?.roleId ?? NodeId.null();
        this.permissions = options?.permissions ?? PermissionType.None;
    }
    static [typeId] = NodeIds.RolePermissionType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.roleId);
        encoder.writeUInt32(this.permissions);
    }
    static [decode](decoder: BinaryDataDecoder): RolePermissionType {
        const roleId = decoder.readType(NodeId);
        const permissions = decoder.readUInt32();
        return new RolePermissionType({
            roleId,
            permissions
        });
    }
}
export enum StructureType {
    Structure = 0,
    StructureWithOptionalFields = 1,
    Union = 2
}
export interface StructureFieldOptions {
    name?: UaString;
    description?: LocalizedText;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    maxStringLength?: UInt32;
    isOptional?: boolean;
}
export class StructureField implements StructureFieldOptions {
    name?: UaString;
    description: LocalizedText;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    maxStringLength: UInt32;
    isOptional: boolean;
    constructor(options?: StructureFieldOptions) {
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.isOptional = options?.isOptional ?? false;
    }
    static [typeId] = NodeIds.StructureField_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeUInt32(this.maxStringLength);
        encoder.writeBoolean(this.isOptional);
    }
    static [decode](decoder: BinaryDataDecoder): StructureField {
        const name = decoder.readString();
        const description = decoder.readType(LocalizedText);
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const maxStringLength = decoder.readUInt32();
        const isOptional = decoder.readBoolean();
        return new StructureField({
            name,
            description,
            dataType,
            valueRank,
            arrayDimensions,
            maxStringLength,
            isOptional
        });
    }
}
export interface StructureDefinitionOptions {
    defaultEncodingId?: NodeId;
    baseDataType?: NodeId;
    structureType?: StructureType;
    fields?: StructureField[];
}
export class StructureDefinition implements StructureDefinitionOptions {
    defaultEncodingId: NodeId;
    baseDataType: NodeId;
    structureType: StructureType;
    fields?: StructureField[];
    constructor(options?: StructureDefinitionOptions) {
        this.defaultEncodingId = options?.defaultEncodingId ?? NodeId.null();
        this.baseDataType = options?.baseDataType ?? NodeId.null();
        this.structureType = options?.structureType ?? StructureType.Structure;
        this.fields = options?.fields;
    }
    static [typeId] = NodeIds.StructureDefinition_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.defaultEncodingId);
        encoder.writeType(this.baseDataType);
        encoder.writeUInt32(this.structureType);
        encoder.writeTypeArray(this.fields);
    }
    static [decode](decoder: BinaryDataDecoder): StructureDefinition {
        const defaultEncodingId = decoder.readType(NodeId);
        const baseDataType = decoder.readType(NodeId);
        const structureType = decoder.readUInt32();
        const fields = decoder.readTypeArray(StructureField);
        return new StructureDefinition({
            defaultEncodingId,
            baseDataType,
            structureType,
            fields
        });
    }
}
export interface EnumDefinitionOptions {
    fields?: EnumField[];
}
export class EnumDefinition implements EnumDefinitionOptions {
    fields?: EnumField[];
    constructor(options?: EnumDefinitionOptions) {
        this.fields = options?.fields;
    }
    static [typeId] = NodeIds.EnumDefinition_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.fields);
    }
    static [decode](decoder: BinaryDataDecoder): EnumDefinition {
        const fields = decoder.readTypeArray(EnumField);
        return new EnumDefinition({
            fields
        });
    }
}
export interface NodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
}
export class Node implements NodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    constructor(options?: NodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.Node_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): Node {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        return new Node({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references
        });
    }
}
export interface InstanceNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
}
export class InstanceNode implements InstanceNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    constructor(options?: InstanceNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.InstanceNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): InstanceNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        return new InstanceNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references
        });
    }
}
export interface TypeNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
}
export class TypeNode implements TypeNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    constructor(options?: TypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.TypeNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): TypeNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        return new TypeNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references
        });
    }
}
export interface ObjectNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    eventNotifier?: Byte;
}
export class ObjectNode implements ObjectNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    eventNotifier: Byte;
    constructor(options?: ObjectNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ObjectNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const eventNotifier = decoder.readByte();
        return new ObjectNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            eventNotifier
        });
    }
}
export interface ObjectTypeNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    isAbstract?: boolean;
}
export class ObjectTypeNode implements ObjectTypeNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    isAbstract: boolean;
    constructor(options?: ObjectTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.ObjectTypeNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectTypeNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const isAbstract = decoder.readBoolean();
        return new ObjectTypeNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            isAbstract
        });
    }
}
export interface VariableNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    value?: Variant;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    accessLevel?: Byte;
    userAccessLevel?: Byte;
    minimumSamplingInterval?: Double;
    historizing?: boolean;
    accessLevelEx?: UInt32;
}
export class VariableNode implements VariableNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    value: Variant;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    accessLevel: Byte;
    userAccessLevel: Byte;
    minimumSamplingInterval: Double;
    historizing: boolean;
    accessLevelEx: UInt32;
    constructor(options?: VariableNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.accessLevel = options?.accessLevel ?? 0;
        this.userAccessLevel = options?.userAccessLevel ?? 0;
        this.minimumSamplingInterval = options?.minimumSamplingInterval ?? 0;
        this.historizing = options?.historizing ?? false;
        this.accessLevelEx = options?.accessLevelEx ?? 0;
    }
    static [typeId] = NodeIds.VariableNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeByte(this.accessLevel);
        encoder.writeByte(this.userAccessLevel);
        encoder.writeDouble(this.minimumSamplingInterval);
        encoder.writeBoolean(this.historizing);
        encoder.writeUInt32(this.accessLevelEx);
    }
    static [decode](decoder: BinaryDataDecoder): VariableNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const value = decoder.readType(Variant);
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const accessLevel = decoder.readByte();
        const userAccessLevel = decoder.readByte();
        const minimumSamplingInterval = decoder.readDouble();
        const historizing = decoder.readBoolean();
        const accessLevelEx = decoder.readUInt32();
        return new VariableNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            value,
            dataType,
            valueRank,
            arrayDimensions,
            accessLevel,
            userAccessLevel,
            minimumSamplingInterval,
            historizing,
            accessLevelEx
        });
    }
}
export interface VariableTypeNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    value?: Variant;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    isAbstract?: boolean;
}
export class VariableTypeNode implements VariableTypeNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    value: Variant;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    isAbstract: boolean;
    constructor(options?: VariableTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.VariableTypeNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): VariableTypeNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const value = decoder.readType(Variant);
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const isAbstract = decoder.readBoolean();
        return new VariableTypeNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            value,
            dataType,
            valueRank,
            arrayDimensions,
            isAbstract
        });
    }
}
export interface ReferenceTypeNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    isAbstract?: boolean;
    symmetric?: boolean;
    inverseName?: LocalizedText;
}
export class ReferenceTypeNode implements ReferenceTypeNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    isAbstract: boolean;
    symmetric: boolean;
    inverseName: LocalizedText;
    constructor(options?: ReferenceTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
        this.symmetric = options?.symmetric ?? false;
        this.inverseName = options?.inverseName ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ReferenceTypeNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeBoolean(this.symmetric);
        encoder.writeType(this.inverseName);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceTypeNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const isAbstract = decoder.readBoolean();
        const symmetric = decoder.readBoolean();
        const inverseName = decoder.readType(LocalizedText);
        return new ReferenceTypeNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            isAbstract,
            symmetric,
            inverseName
        });
    }
}
export interface MethodNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    executable?: boolean;
    userExecutable?: boolean;
}
export class MethodNode implements MethodNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    executable: boolean;
    userExecutable: boolean;
    constructor(options?: MethodNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.executable = options?.executable ?? false;
        this.userExecutable = options?.userExecutable ?? false;
    }
    static [typeId] = NodeIds.MethodNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.executable);
        encoder.writeBoolean(this.userExecutable);
    }
    static [decode](decoder: BinaryDataDecoder): MethodNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const executable = decoder.readBoolean();
        const userExecutable = decoder.readBoolean();
        return new MethodNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            executable,
            userExecutable
        });
    }
}
export interface ViewNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    containsNoLoops?: boolean;
    eventNotifier?: Byte;
}
export class ViewNode implements ViewNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    containsNoLoops: boolean;
    eventNotifier: Byte;
    constructor(options?: ViewNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.containsNoLoops = options?.containsNoLoops ?? false;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ViewNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.containsNoLoops);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ViewNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const containsNoLoops = decoder.readBoolean();
        const eventNotifier = decoder.readByte();
        return new ViewNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            containsNoLoops,
            eventNotifier
        });
    }
}
export interface DataTypeNodeOptions {
    nodeId?: NodeId;
    nodeClass?: NodeClass;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions?: UInt16;
    references?: ReferenceNode[];
    isAbstract?: boolean;
    dataTypeDefinition?: ExtensionObject;
}
export class DataTypeNode implements DataTypeNodeOptions {
    nodeId: NodeId;
    nodeClass: NodeClass;
    browseName: QualifiedName;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    rolePermissions?: RolePermissionType[];
    userRolePermissions?: RolePermissionType[];
    accessRestrictions: UInt16;
    references?: ReferenceNode[];
    isAbstract: boolean;
    dataTypeDefinition: ExtensionObject;
    constructor(options?: DataTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
        this.dataTypeDefinition = options?.dataTypeDefinition ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataTypeNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeType(this.dataTypeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeNode {
        const nodeId = decoder.readType(NodeId);
        const nodeClass = decoder.readUInt32();
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const rolePermissions = decoder.readTypeArray(RolePermissionType);
        const userRolePermissions = decoder.readTypeArray(RolePermissionType);
        const accessRestrictions = decoder.readUInt16();
        const references = decoder.readTypeArray(ReferenceNode);
        const isAbstract = decoder.readBoolean();
        const dataTypeDefinition = decoder.readType(ExtensionObject);
        return new DataTypeNode({
            nodeId,
            nodeClass,
            browseName,
            displayName,
            description,
            writeMask,
            userWriteMask,
            rolePermissions,
            userRolePermissions,
            accessRestrictions,
            references,
            isAbstract,
            dataTypeDefinition
        });
    }
}
export interface ReferenceNodeOptions {
    referenceTypeId?: NodeId;
    isInverse?: boolean;
    targetId?: ExpandedNodeId;
}
export class ReferenceNode implements ReferenceNodeOptions {
    referenceTypeId: NodeId;
    isInverse: boolean;
    targetId: ExpandedNodeId;
    constructor(options?: ReferenceNodeOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isInverse = options?.isInverse ?? false;
        this.targetId = options?.targetId ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.ReferenceNode_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isInverse);
        encoder.writeType(this.targetId);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceNode {
        const referenceTypeId = decoder.readType(NodeId);
        const isInverse = decoder.readBoolean();
        const targetId = decoder.readType(ExpandedNodeId);
        return new ReferenceNode({
            referenceTypeId,
            isInverse,
            targetId
        });
    }
}
export interface ArgumentOptions {
    name?: UaString;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    description?: LocalizedText;
}
export class Argument implements ArgumentOptions {
    name?: UaString;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    description: LocalizedText;
    constructor(options?: ArgumentOptions) {
        this.name = options?.name;
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.Argument_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): Argument {
        const name = decoder.readString();
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const description = decoder.readType(LocalizedText);
        return new Argument({
            name,
            dataType,
            valueRank,
            arrayDimensions,
            description
        });
    }
}
export interface EnumValueTypeOptions {
    value?: Int64;
    displayName?: LocalizedText;
    description?: LocalizedText;
}
export class EnumValueType implements EnumValueTypeOptions {
    value: Int64;
    displayName: LocalizedText;
    description: LocalizedText;
    constructor(options?: EnumValueTypeOptions) {
        this.value = options?.value ?? BigInt(0);
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.EnumValueType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt64(this.value);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): EnumValueType {
        const value = decoder.readInt64();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        return new EnumValueType({
            value,
            displayName,
            description
        });
    }
}
export interface EnumFieldOptions {
    value?: Int64;
    displayName?: LocalizedText;
    description?: LocalizedText;
    name?: UaString;
}
export class EnumField implements EnumFieldOptions {
    value: Int64;
    displayName: LocalizedText;
    description: LocalizedText;
    name?: UaString;
    constructor(options?: EnumFieldOptions) {
        this.value = options?.value ?? BigInt(0);
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.name = options?.name;
    }
    static [typeId] = NodeIds.EnumField_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt64(this.value);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeString(this.name);
    }
    static [decode](decoder: BinaryDataDecoder): EnumField {
        const value = decoder.readInt64();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const name = decoder.readString();
        return new EnumField({
            value,
            displayName,
            description,
            name
        });
    }
}
export interface OptionSetOptions {
    value?: ByteString;
    validBits?: ByteString;
}
export class OptionSet implements OptionSetOptions {
    value?: ByteString;
    validBits?: ByteString;
    constructor(options?: OptionSetOptions) {
        this.value = options?.value;
        this.validBits = options?.validBits;
    }
    static [typeId] = NodeIds.OptionSet_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.value);
        encoder.writeByteString(this.validBits);
    }
    static [decode](decoder: BinaryDataDecoder): OptionSet {
        const value = decoder.readByteString();
        const validBits = decoder.readByteString();
        return new OptionSet({
            value,
            validBits
        });
    }
}
export class Union {
    static [typeId] = NodeIds.Union_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Union {
        return new Union();
    }
}
export interface TimeZoneDataTypeOptions {
    offset?: Int16;
    daylightSavingInOffset?: boolean;
}
export class TimeZoneDataType implements TimeZoneDataTypeOptions {
    offset: Int16;
    daylightSavingInOffset: boolean;
    constructor(options?: TimeZoneDataTypeOptions) {
        this.offset = options?.offset ?? 0;
        this.daylightSavingInOffset = options?.daylightSavingInOffset ?? false;
    }
    static [typeId] = NodeIds.TimeZoneDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.offset);
        encoder.writeBoolean(this.daylightSavingInOffset);
    }
    static [decode](decoder: BinaryDataDecoder): TimeZoneDataType {
        const offset = decoder.readInt16();
        const daylightSavingInOffset = decoder.readBoolean();
        return new TimeZoneDataType({
            offset,
            daylightSavingInOffset
        });
    }
}
export enum ApplicationType {
    Server = 0,
    Client = 1,
    ClientAndServer = 2,
    DiscoveryServer = 3
}
export interface ApplicationDescriptionOptions {
    applicationUri?: UaString;
    productUri?: UaString;
    applicationName?: LocalizedText;
    applicationType?: ApplicationType;
    gatewayServerUri?: UaString;
    discoveryProfileUri?: UaString;
    discoveryUrls?: UaString[];
}
export class ApplicationDescription implements ApplicationDescriptionOptions {
    applicationUri?: UaString;
    productUri?: UaString;
    applicationName: LocalizedText;
    applicationType: ApplicationType;
    gatewayServerUri?: UaString;
    discoveryProfileUri?: UaString;
    discoveryUrls?: UaString[];
    constructor(options?: ApplicationDescriptionOptions) {
        this.applicationUri = options?.applicationUri;
        this.productUri = options?.productUri;
        this.applicationName = options?.applicationName ?? new LocalizedText();
        this.applicationType = options?.applicationType ?? ApplicationType.Server;
        this.gatewayServerUri = options?.gatewayServerUri;
        this.discoveryProfileUri = options?.discoveryProfileUri;
        this.discoveryUrls = options?.discoveryUrls;
    }
    static [typeId] = NodeIds.ApplicationDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.applicationUri);
        encoder.writeString(this.productUri);
        encoder.writeType(this.applicationName);
        encoder.writeUInt32(this.applicationType);
        encoder.writeString(this.gatewayServerUri);
        encoder.writeString(this.discoveryProfileUri);
        encoder.writeStringArray(this.discoveryUrls);
    }
    static [decode](decoder: BinaryDataDecoder): ApplicationDescription {
        const applicationUri = decoder.readString();
        const productUri = decoder.readString();
        const applicationName = decoder.readType(LocalizedText);
        const applicationType = decoder.readUInt32();
        const gatewayServerUri = decoder.readString();
        const discoveryProfileUri = decoder.readString();
        const discoveryUrls = decoder.readStringArray();
        return new ApplicationDescription({
            applicationUri,
            productUri,
            applicationName,
            applicationType,
            gatewayServerUri,
            discoveryProfileUri,
            discoveryUrls
        });
    }
}
export interface RequestHeaderOptions {
    authenticationToken?: NodeId;
    timestamp?: Date;
    requestHandle?: UInt32;
    returnDiagnostics?: UInt32;
    auditEntryId?: UaString;
    timeoutHint?: UInt32;
    additionalHeader?: ExtensionObject;
}
export class RequestHeader implements RequestHeaderOptions {
    authenticationToken: NodeId;
    timestamp: Date;
    requestHandle: UInt32;
    returnDiagnostics: UInt32;
    auditEntryId?: UaString;
    timeoutHint: UInt32;
    additionalHeader: ExtensionObject;
    constructor(options?: RequestHeaderOptions) {
        this.authenticationToken = options?.authenticationToken ?? NodeId.null();
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.requestHandle = options?.requestHandle ?? 0;
        this.returnDiagnostics = options?.returnDiagnostics ?? 0;
        this.auditEntryId = options?.auditEntryId;
        this.timeoutHint = options?.timeoutHint ?? 0;
        this.additionalHeader = options?.additionalHeader ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.RequestHeader_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.authenticationToken);
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.requestHandle);
        encoder.writeUInt32(this.returnDiagnostics);
        encoder.writeString(this.auditEntryId);
        encoder.writeUInt32(this.timeoutHint);
        encoder.writeType(this.additionalHeader);
    }
    static [decode](decoder: BinaryDataDecoder): RequestHeader {
        const authenticationToken = decoder.readType(NodeId);
        const timestamp = decoder.readDateTime();
        const requestHandle = decoder.readUInt32();
        const returnDiagnostics = decoder.readUInt32();
        const auditEntryId = decoder.readString();
        const timeoutHint = decoder.readUInt32();
        const additionalHeader = decoder.readType(ExtensionObject);
        return new RequestHeader({
            authenticationToken,
            timestamp,
            requestHandle,
            returnDiagnostics,
            auditEntryId,
            timeoutHint,
            additionalHeader
        });
    }
}
export interface ResponseHeaderOptions {
    timestamp?: Date;
    requestHandle?: UInt32;
    serviceResult?: StatusCode;
    serviceDiagnostics?: DiagnosticInfo;
    stringTable?: UaString[];
    additionalHeader?: ExtensionObject;
}
export class ResponseHeader implements ResponseHeaderOptions {
    timestamp: Date;
    requestHandle: UInt32;
    serviceResult: StatusCode;
    serviceDiagnostics: DiagnosticInfo;
    stringTable?: UaString[];
    additionalHeader: ExtensionObject;
    constructor(options?: ResponseHeaderOptions) {
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.requestHandle = options?.requestHandle ?? 0;
        this.serviceResult = options?.serviceResult ?? StatusCode.Good;
        this.serviceDiagnostics = options?.serviceDiagnostics ?? new DiagnosticInfo();
        this.stringTable = options?.stringTable;
        this.additionalHeader = options?.additionalHeader ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.ResponseHeader_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.requestHandle);
        encoder.writeType(this.serviceResult);
        encoder.writeType(this.serviceDiagnostics);
        encoder.writeStringArray(this.stringTable);
        encoder.writeType(this.additionalHeader);
    }
    static [decode](decoder: BinaryDataDecoder): ResponseHeader {
        const timestamp = decoder.readDateTime();
        const requestHandle = decoder.readUInt32();
        const serviceResult = decoder.readType(StatusCode);
        const serviceDiagnostics = decoder.readType(DiagnosticInfo);
        const stringTable = decoder.readStringArray();
        const additionalHeader = decoder.readType(ExtensionObject);
        return new ResponseHeader({
            timestamp,
            requestHandle,
            serviceResult,
            serviceDiagnostics,
            stringTable,
            additionalHeader
        });
    }
}
export interface SessionlessInvokeRequestTypeOptions {
    urisVersion?: UInt32;
    namespaceUris?: UaString[];
    serverUris?: UaString[];
    localeIds?: UaString[];
    serviceId?: UInt32;
}
export class SessionlessInvokeRequestType implements SessionlessInvokeRequestTypeOptions {
    urisVersion: UInt32;
    namespaceUris?: UaString[];
    serverUris?: UaString[];
    localeIds?: UaString[];
    serviceId: UInt32;
    constructor(options?: SessionlessInvokeRequestTypeOptions) {
        this.urisVersion = options?.urisVersion ?? 0;
        this.namespaceUris = options?.namespaceUris;
        this.serverUris = options?.serverUris;
        this.localeIds = options?.localeIds;
        this.serviceId = options?.serviceId ?? 0;
    }
    static [typeId] = NodeIds.SessionlessInvokeRequestType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.urisVersion);
        encoder.writeStringArray(this.namespaceUris);
        encoder.writeStringArray(this.serverUris);
        encoder.writeStringArray(this.localeIds);
        encoder.writeUInt32(this.serviceId);
    }
    static [decode](decoder: BinaryDataDecoder): SessionlessInvokeRequestType {
        const urisVersion = decoder.readUInt32();
        const namespaceUris = decoder.readStringArray();
        const serverUris = decoder.readStringArray();
        const localeIds = decoder.readStringArray();
        const serviceId = decoder.readUInt32();
        return new SessionlessInvokeRequestType({
            urisVersion,
            namespaceUris,
            serverUris,
            localeIds,
            serviceId
        });
    }
}
export interface SessionlessInvokeResponseTypeOptions {
    namespaceUris?: UaString[];
    serverUris?: UaString[];
    serviceId?: UInt32;
}
export class SessionlessInvokeResponseType implements SessionlessInvokeResponseTypeOptions {
    namespaceUris?: UaString[];
    serverUris?: UaString[];
    serviceId: UInt32;
    constructor(options?: SessionlessInvokeResponseTypeOptions) {
        this.namespaceUris = options?.namespaceUris;
        this.serverUris = options?.serverUris;
        this.serviceId = options?.serviceId ?? 0;
    }
    static [typeId] = NodeIds.SessionlessInvokeResponseType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaceUris);
        encoder.writeStringArray(this.serverUris);
        encoder.writeUInt32(this.serviceId);
    }
    static [decode](decoder: BinaryDataDecoder): SessionlessInvokeResponseType {
        const namespaceUris = decoder.readStringArray();
        const serverUris = decoder.readStringArray();
        const serviceId = decoder.readUInt32();
        return new SessionlessInvokeResponseType({
            namespaceUris,
            serverUris,
            serviceId
        });
    }
}
export interface FindServersRequestOptions {
    requestHeader?: RequestHeader;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    serverUris?: UaString[];
}
export class FindServersRequest implements FindServersRequestOptions {
    requestHeader: RequestHeader;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    serverUris?: UaString[];
    constructor(options?: FindServersRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.serverUris = options?.serverUris;
    }
    static [typeId] = NodeIds.FindServersRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeStringArray(this.serverUris);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const endpointUrl = decoder.readString();
        const localeIds = decoder.readStringArray();
        const serverUris = decoder.readStringArray();
        return new FindServersRequest({
            requestHeader,
            endpointUrl,
            localeIds,
            serverUris
        });
    }
}
export interface FindServersResponseOptions {
    responseHeader?: ResponseHeader;
    servers?: ApplicationDescription[];
}
export class FindServersResponse implements FindServersResponseOptions {
    responseHeader: ResponseHeader;
    servers?: ApplicationDescription[];
    constructor(options?: FindServersResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.servers = options?.servers;
    }
    static [typeId] = NodeIds.FindServersResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.servers);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const servers = decoder.readTypeArray(ApplicationDescription);
        return new FindServersResponse({
            responseHeader,
            servers
        });
    }
}
export interface ServerOnNetworkOptions {
    recordId?: UInt32;
    serverName?: UaString;
    discoveryUrl?: UaString;
    serverCapabilities?: UaString[];
}
export class ServerOnNetwork implements ServerOnNetworkOptions {
    recordId: UInt32;
    serverName?: UaString;
    discoveryUrl?: UaString;
    serverCapabilities?: UaString[];
    constructor(options?: ServerOnNetworkOptions) {
        this.recordId = options?.recordId ?? 0;
        this.serverName = options?.serverName;
        this.discoveryUrl = options?.discoveryUrl;
        this.serverCapabilities = options?.serverCapabilities;
    }
    static [typeId] = NodeIds.ServerOnNetwork_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.recordId);
        encoder.writeString(this.serverName);
        encoder.writeString(this.discoveryUrl);
        encoder.writeStringArray(this.serverCapabilities);
    }
    static [decode](decoder: BinaryDataDecoder): ServerOnNetwork {
        const recordId = decoder.readUInt32();
        const serverName = decoder.readString();
        const discoveryUrl = decoder.readString();
        const serverCapabilities = decoder.readStringArray();
        return new ServerOnNetwork({
            recordId,
            serverName,
            discoveryUrl,
            serverCapabilities
        });
    }
}
export interface FindServersOnNetworkRequestOptions {
    requestHeader?: RequestHeader;
    startingRecordId?: UInt32;
    maxRecordsToReturn?: UInt32;
    serverCapabilityFilter?: UaString[];
}
export class FindServersOnNetworkRequest implements FindServersOnNetworkRequestOptions {
    requestHeader: RequestHeader;
    startingRecordId: UInt32;
    maxRecordsToReturn: UInt32;
    serverCapabilityFilter?: UaString[];
    constructor(options?: FindServersOnNetworkRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.startingRecordId = options?.startingRecordId ?? 0;
        this.maxRecordsToReturn = options?.maxRecordsToReturn ?? 0;
        this.serverCapabilityFilter = options?.serverCapabilityFilter;
    }
    static [typeId] = NodeIds.FindServersOnNetworkRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.startingRecordId);
        encoder.writeUInt32(this.maxRecordsToReturn);
        encoder.writeStringArray(this.serverCapabilityFilter);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersOnNetworkRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const startingRecordId = decoder.readUInt32();
        const maxRecordsToReturn = decoder.readUInt32();
        const serverCapabilityFilter = decoder.readStringArray();
        return new FindServersOnNetworkRequest({
            requestHeader,
            startingRecordId,
            maxRecordsToReturn,
            serverCapabilityFilter
        });
    }
}
export interface FindServersOnNetworkResponseOptions {
    responseHeader?: ResponseHeader;
    lastCounterResetTime?: Date;
    servers?: ServerOnNetwork[];
}
export class FindServersOnNetworkResponse implements FindServersOnNetworkResponseOptions {
    responseHeader: ResponseHeader;
    lastCounterResetTime: Date;
    servers?: ServerOnNetwork[];
    constructor(options?: FindServersOnNetworkResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.lastCounterResetTime = options?.lastCounterResetTime ?? new Date(-11644473600000);
        this.servers = options?.servers;
    }
    static [typeId] = NodeIds.FindServersOnNetworkResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeDateTime(this.lastCounterResetTime);
        encoder.writeTypeArray(this.servers);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersOnNetworkResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const lastCounterResetTime = decoder.readDateTime();
        const servers = decoder.readTypeArray(ServerOnNetwork);
        return new FindServersOnNetworkResponse({
            responseHeader,
            lastCounterResetTime,
            servers
        });
    }
}
export enum MessageSecurityMode {
    Invalid = 0,
    None = 1,
    Sign = 2,
    SignAndEncrypt = 3
}
export enum UserTokenType {
    Anonymous = 0,
    UserName = 1,
    Certificate = 2,
    IssuedToken = 3
}
export interface UserTokenPolicyOptions {
    policyId?: UaString;
    tokenType?: UserTokenType;
    issuedTokenType?: UaString;
    issuerEndpointUrl?: UaString;
    securityPolicyUri?: UaString;
}
export class UserTokenPolicy implements UserTokenPolicyOptions {
    policyId?: UaString;
    tokenType: UserTokenType;
    issuedTokenType?: UaString;
    issuerEndpointUrl?: UaString;
    securityPolicyUri?: UaString;
    constructor(options?: UserTokenPolicyOptions) {
        this.policyId = options?.policyId;
        this.tokenType = options?.tokenType ?? UserTokenType.Anonymous;
        this.issuedTokenType = options?.issuedTokenType;
        this.issuerEndpointUrl = options?.issuerEndpointUrl;
        this.securityPolicyUri = options?.securityPolicyUri;
    }
    static [typeId] = NodeIds.UserTokenPolicy_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeUInt32(this.tokenType);
        encoder.writeString(this.issuedTokenType);
        encoder.writeString(this.issuerEndpointUrl);
        encoder.writeString(this.securityPolicyUri);
    }
    static [decode](decoder: BinaryDataDecoder): UserTokenPolicy {
        const policyId = decoder.readString();
        const tokenType = decoder.readUInt32();
        const issuedTokenType = decoder.readString();
        const issuerEndpointUrl = decoder.readString();
        const securityPolicyUri = decoder.readString();
        return new UserTokenPolicy({
            policyId,
            tokenType,
            issuedTokenType,
            issuerEndpointUrl,
            securityPolicyUri
        });
    }
}
export interface EndpointDescriptionOptions {
    endpointUrl?: UaString;
    server?: ApplicationDescription;
    serverCertificate?: ByteString;
    securityMode?: MessageSecurityMode;
    securityPolicyUri?: UaString;
    userIdentityTokens?: UserTokenPolicy[];
    transportProfileUri?: UaString;
    securityLevel?: Byte;
}
export class EndpointDescription implements EndpointDescriptionOptions {
    endpointUrl?: UaString;
    server: ApplicationDescription;
    serverCertificate?: ByteString;
    securityMode: MessageSecurityMode;
    securityPolicyUri?: UaString;
    userIdentityTokens?: UserTokenPolicy[];
    transportProfileUri?: UaString;
    securityLevel: Byte;
    constructor(options?: EndpointDescriptionOptions) {
        this.endpointUrl = options?.endpointUrl;
        this.server = options?.server ?? new ApplicationDescription();
        this.serverCertificate = options?.serverCertificate;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.userIdentityTokens = options?.userIdentityTokens;
        this.transportProfileUri = options?.transportProfileUri;
        this.securityLevel = options?.securityLevel ?? 0;
    }
    static [typeId] = NodeIds.EndpointDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.endpointUrl);
        encoder.writeType(this.server);
        encoder.writeByteString(this.serverCertificate);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeTypeArray(this.userIdentityTokens);
        encoder.writeString(this.transportProfileUri);
        encoder.writeByte(this.securityLevel);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointDescription {
        const endpointUrl = decoder.readString();
        const server = decoder.readType(ApplicationDescription);
        const serverCertificate = decoder.readByteString();
        const securityMode = decoder.readUInt32();
        const securityPolicyUri = decoder.readString();
        const userIdentityTokens = decoder.readTypeArray(UserTokenPolicy);
        const transportProfileUri = decoder.readString();
        const securityLevel = decoder.readByte();
        return new EndpointDescription({
            endpointUrl,
            server,
            serverCertificate,
            securityMode,
            securityPolicyUri,
            userIdentityTokens,
            transportProfileUri,
            securityLevel
        });
    }
}
export interface GetEndpointsRequestOptions {
    requestHeader?: RequestHeader;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    profileUris?: UaString[];
}
export class GetEndpointsRequest implements GetEndpointsRequestOptions {
    requestHeader: RequestHeader;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    profileUris?: UaString[];
    constructor(options?: GetEndpointsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.profileUris = options?.profileUris;
    }
    static [typeId] = NodeIds.GetEndpointsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeStringArray(this.profileUris);
    }
    static [decode](decoder: BinaryDataDecoder): GetEndpointsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const endpointUrl = decoder.readString();
        const localeIds = decoder.readStringArray();
        const profileUris = decoder.readStringArray();
        return new GetEndpointsRequest({
            requestHeader,
            endpointUrl,
            localeIds,
            profileUris
        });
    }
}
export interface GetEndpointsResponseOptions {
    responseHeader?: ResponseHeader;
    endpoints?: EndpointDescription[];
}
export class GetEndpointsResponse implements GetEndpointsResponseOptions {
    responseHeader: ResponseHeader;
    endpoints?: EndpointDescription[];
    constructor(options?: GetEndpointsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.endpoints = options?.endpoints;
    }
    static [typeId] = NodeIds.GetEndpointsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.endpoints);
    }
    static [decode](decoder: BinaryDataDecoder): GetEndpointsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const endpoints = decoder.readTypeArray(EndpointDescription);
        return new GetEndpointsResponse({
            responseHeader,
            endpoints
        });
    }
}
export interface RegisteredServerOptions {
    serverUri?: UaString;
    productUri?: UaString;
    serverNames?: LocalizedText[];
    serverType?: ApplicationType;
    gatewayServerUri?: UaString;
    discoveryUrls?: UaString[];
    semaphoreFilePath?: UaString;
    isOnline?: boolean;
}
export class RegisteredServer implements RegisteredServerOptions {
    serverUri?: UaString;
    productUri?: UaString;
    serverNames?: LocalizedText[];
    serverType: ApplicationType;
    gatewayServerUri?: UaString;
    discoveryUrls?: UaString[];
    semaphoreFilePath?: UaString;
    isOnline: boolean;
    constructor(options?: RegisteredServerOptions) {
        this.serverUri = options?.serverUri;
        this.productUri = options?.productUri;
        this.serverNames = options?.serverNames;
        this.serverType = options?.serverType ?? ApplicationType.Server;
        this.gatewayServerUri = options?.gatewayServerUri;
        this.discoveryUrls = options?.discoveryUrls;
        this.semaphoreFilePath = options?.semaphoreFilePath;
        this.isOnline = options?.isOnline ?? false;
    }
    static [typeId] = NodeIds.RegisteredServer_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverUri);
        encoder.writeString(this.productUri);
        encoder.writeTypeArray(this.serverNames);
        encoder.writeUInt32(this.serverType);
        encoder.writeString(this.gatewayServerUri);
        encoder.writeStringArray(this.discoveryUrls);
        encoder.writeString(this.semaphoreFilePath);
        encoder.writeBoolean(this.isOnline);
    }
    static [decode](decoder: BinaryDataDecoder): RegisteredServer {
        const serverUri = decoder.readString();
        const productUri = decoder.readString();
        const serverNames = decoder.readTypeArray(LocalizedText);
        const serverType = decoder.readUInt32();
        const gatewayServerUri = decoder.readString();
        const discoveryUrls = decoder.readStringArray();
        const semaphoreFilePath = decoder.readString();
        const isOnline = decoder.readBoolean();
        return new RegisteredServer({
            serverUri,
            productUri,
            serverNames,
            serverType,
            gatewayServerUri,
            discoveryUrls,
            semaphoreFilePath,
            isOnline
        });
    }
}
export interface RegisterServerRequestOptions {
    requestHeader?: RequestHeader;
    server?: RegisteredServer;
}
export class RegisterServerRequest implements RegisterServerRequestOptions {
    requestHeader: RequestHeader;
    server: RegisteredServer;
    constructor(options?: RegisterServerRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.server = options?.server ?? new RegisteredServer();
    }
    static [typeId] = NodeIds.RegisterServerRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.server);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServerRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const server = decoder.readType(RegisteredServer);
        return new RegisterServerRequest({
            requestHeader,
            server
        });
    }
}
export interface RegisterServerResponseOptions {
    responseHeader?: ResponseHeader;
}
export class RegisterServerResponse implements RegisterServerResponseOptions {
    responseHeader: ResponseHeader;
    constructor(options?: RegisterServerResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.RegisterServerResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServerResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        return new RegisterServerResponse({
            responseHeader
        });
    }
}
export class DiscoveryConfiguration {
    static [typeId] = NodeIds.DiscoveryConfiguration_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DiscoveryConfiguration {
        return new DiscoveryConfiguration();
    }
}
export interface MdnsDiscoveryConfigurationOptions {
    mdnsServerName?: UaString;
    serverCapabilities?: UaString[];
}
export class MdnsDiscoveryConfiguration implements MdnsDiscoveryConfigurationOptions {
    mdnsServerName?: UaString;
    serverCapabilities?: UaString[];
    constructor(options?: MdnsDiscoveryConfigurationOptions) {
        this.mdnsServerName = options?.mdnsServerName;
        this.serverCapabilities = options?.serverCapabilities;
    }
    static [typeId] = NodeIds.MdnsDiscoveryConfiguration_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.mdnsServerName);
        encoder.writeStringArray(this.serverCapabilities);
    }
    static [decode](decoder: BinaryDataDecoder): MdnsDiscoveryConfiguration {
        const mdnsServerName = decoder.readString();
        const serverCapabilities = decoder.readStringArray();
        return new MdnsDiscoveryConfiguration({
            mdnsServerName,
            serverCapabilities
        });
    }
}
export interface RegisterServer2RequestOptions {
    requestHeader?: RequestHeader;
    server?: RegisteredServer;
    discoveryConfiguration?: ExtensionObject[];
}
export class RegisterServer2Request implements RegisterServer2RequestOptions {
    requestHeader: RequestHeader;
    server: RegisteredServer;
    discoveryConfiguration?: ExtensionObject[];
    constructor(options?: RegisterServer2RequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.server = options?.server ?? new RegisteredServer();
        this.discoveryConfiguration = options?.discoveryConfiguration;
    }
    static [typeId] = NodeIds.RegisterServer2Request_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.server);
        encoder.writeTypeArray(this.discoveryConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServer2Request {
        const requestHeader = decoder.readType(RequestHeader);
        const server = decoder.readType(RegisteredServer);
        const discoveryConfiguration = decoder.readTypeArray(ExtensionObject);
        return new RegisterServer2Request({
            requestHeader,
            server,
            discoveryConfiguration
        });
    }
}
export interface RegisterServer2ResponseOptions {
    responseHeader?: ResponseHeader;
    configurationResults?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class RegisterServer2Response implements RegisterServer2ResponseOptions {
    responseHeader: ResponseHeader;
    configurationResults?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: RegisterServer2ResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.configurationResults = options?.configurationResults;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.RegisterServer2Response_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.configurationResults);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServer2Response {
        const responseHeader = decoder.readType(ResponseHeader);
        const configurationResults = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new RegisterServer2Response({
            responseHeader,
            configurationResults,
            diagnosticInfos
        });
    }
}
export enum SecurityTokenRequestType {
    Issue = 0,
    Renew = 1
}
export interface ChannelSecurityTokenOptions {
    channelId?: UInt32;
    tokenId?: UInt32;
    createdAt?: Date;
    revisedLifetime?: UInt32;
}
export class ChannelSecurityToken implements ChannelSecurityTokenOptions {
    channelId: UInt32;
    tokenId: UInt32;
    createdAt: Date;
    revisedLifetime: UInt32;
    constructor(options?: ChannelSecurityTokenOptions) {
        this.channelId = options?.channelId ?? 0;
        this.tokenId = options?.tokenId ?? 0;
        this.createdAt = options?.createdAt ?? new Date(-11644473600000);
        this.revisedLifetime = options?.revisedLifetime ?? 0;
    }
    static [typeId] = NodeIds.ChannelSecurityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.channelId);
        encoder.writeUInt32(this.tokenId);
        encoder.writeDateTime(this.createdAt);
        encoder.writeUInt32(this.revisedLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): ChannelSecurityToken {
        const channelId = decoder.readUInt32();
        const tokenId = decoder.readUInt32();
        const createdAt = decoder.readDateTime();
        const revisedLifetime = decoder.readUInt32();
        return new ChannelSecurityToken({
            channelId,
            tokenId,
            createdAt,
            revisedLifetime
        });
    }
}
export interface OpenSecureChannelRequestOptions {
    requestHeader?: RequestHeader;
    clientProtocolVersion?: UInt32;
    requestType?: SecurityTokenRequestType;
    securityMode?: MessageSecurityMode;
    clientNonce?: ByteString;
    requestedLifetime?: UInt32;
}
export class OpenSecureChannelRequest implements OpenSecureChannelRequestOptions {
    requestHeader: RequestHeader;
    clientProtocolVersion: UInt32;
    requestType: SecurityTokenRequestType;
    securityMode: MessageSecurityMode;
    clientNonce?: ByteString;
    requestedLifetime: UInt32;
    constructor(options?: OpenSecureChannelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientProtocolVersion = options?.clientProtocolVersion ?? 0;
        this.requestType = options?.requestType ?? SecurityTokenRequestType.Issue;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.clientNonce = options?.clientNonce;
        this.requestedLifetime = options?.requestedLifetime ?? 0;
    }
    static [typeId] = NodeIds.OpenSecureChannelRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.clientProtocolVersion);
        encoder.writeUInt32(this.requestType);
        encoder.writeUInt32(this.securityMode);
        encoder.writeByteString(this.clientNonce);
        encoder.writeUInt32(this.requestedLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): OpenSecureChannelRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const clientProtocolVersion = decoder.readUInt32();
        const requestType = decoder.readUInt32();
        const securityMode = decoder.readUInt32();
        const clientNonce = decoder.readByteString();
        const requestedLifetime = decoder.readUInt32();
        return new OpenSecureChannelRequest({
            requestHeader,
            clientProtocolVersion,
            requestType,
            securityMode,
            clientNonce,
            requestedLifetime
        });
    }
}
export interface OpenSecureChannelResponseOptions {
    responseHeader?: ResponseHeader;
    serverProtocolVersion?: UInt32;
    securityToken?: ChannelSecurityToken;
    serverNonce?: ByteString;
}
export class OpenSecureChannelResponse implements OpenSecureChannelResponseOptions {
    responseHeader: ResponseHeader;
    serverProtocolVersion: UInt32;
    securityToken: ChannelSecurityToken;
    serverNonce?: ByteString;
    constructor(options?: OpenSecureChannelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.serverProtocolVersion = options?.serverProtocolVersion ?? 0;
        this.securityToken = options?.securityToken ?? new ChannelSecurityToken();
        this.serverNonce = options?.serverNonce;
    }
    static [typeId] = NodeIds.OpenSecureChannelResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.serverProtocolVersion);
        encoder.writeType(this.securityToken);
        encoder.writeByteString(this.serverNonce);
    }
    static [decode](decoder: BinaryDataDecoder): OpenSecureChannelResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const serverProtocolVersion = decoder.readUInt32();
        const securityToken = decoder.readType(ChannelSecurityToken);
        const serverNonce = decoder.readByteString();
        return new OpenSecureChannelResponse({
            responseHeader,
            serverProtocolVersion,
            securityToken,
            serverNonce
        });
    }
}
export interface CloseSecureChannelRequestOptions {
    requestHeader?: RequestHeader;
}
export class CloseSecureChannelRequest implements CloseSecureChannelRequestOptions {
    requestHeader: RequestHeader;
    constructor(options?: CloseSecureChannelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
    }
    static [typeId] = NodeIds.CloseSecureChannelRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSecureChannelRequest {
        const requestHeader = decoder.readType(RequestHeader);
        return new CloseSecureChannelRequest({
            requestHeader
        });
    }
}
export interface CloseSecureChannelResponseOptions {
    responseHeader?: ResponseHeader;
}
export class CloseSecureChannelResponse implements CloseSecureChannelResponseOptions {
    responseHeader: ResponseHeader;
    constructor(options?: CloseSecureChannelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.CloseSecureChannelResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSecureChannelResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        return new CloseSecureChannelResponse({
            responseHeader
        });
    }
}
export interface SignedSoftwareCertificateOptions {
    certificateData?: ByteString;
    signature?: ByteString;
}
export class SignedSoftwareCertificate implements SignedSoftwareCertificateOptions {
    certificateData?: ByteString;
    signature?: ByteString;
    constructor(options?: SignedSoftwareCertificateOptions) {
        this.certificateData = options?.certificateData;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.SignedSoftwareCertificate_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.certificateData);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): SignedSoftwareCertificate {
        const certificateData = decoder.readByteString();
        const signature = decoder.readByteString();
        return new SignedSoftwareCertificate({
            certificateData,
            signature
        });
    }
}
export interface SignatureDataOptions {
    algorithm?: UaString;
    signature?: ByteString;
}
export class SignatureData implements SignatureDataOptions {
    algorithm?: UaString;
    signature?: ByteString;
    constructor(options?: SignatureDataOptions) {
        this.algorithm = options?.algorithm;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.SignatureData_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.algorithm);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): SignatureData {
        const algorithm = decoder.readString();
        const signature = decoder.readByteString();
        return new SignatureData({
            algorithm,
            signature
        });
    }
}
export interface CreateSessionRequestOptions {
    requestHeader?: RequestHeader;
    clientDescription?: ApplicationDescription;
    serverUri?: UaString;
    endpointUrl?: UaString;
    sessionName?: UaString;
    clientNonce?: ByteString;
    clientCertificate?: ByteString;
    requestedSessionTimeout?: Double;
    maxResponseMessageSize?: UInt32;
}
export class CreateSessionRequest implements CreateSessionRequestOptions {
    requestHeader: RequestHeader;
    clientDescription: ApplicationDescription;
    serverUri?: UaString;
    endpointUrl?: UaString;
    sessionName?: UaString;
    clientNonce?: ByteString;
    clientCertificate?: ByteString;
    requestedSessionTimeout: Double;
    maxResponseMessageSize: UInt32;
    constructor(options?: CreateSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientDescription = options?.clientDescription ?? new ApplicationDescription();
        this.serverUri = options?.serverUri;
        this.endpointUrl = options?.endpointUrl;
        this.sessionName = options?.sessionName;
        this.clientNonce = options?.clientNonce;
        this.clientCertificate = options?.clientCertificate;
        this.requestedSessionTimeout = options?.requestedSessionTimeout ?? 0;
        this.maxResponseMessageSize = options?.maxResponseMessageSize ?? 0;
    }
    static [typeId] = NodeIds.CreateSessionRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.clientDescription);
        encoder.writeString(this.serverUri);
        encoder.writeString(this.endpointUrl);
        encoder.writeString(this.sessionName);
        encoder.writeByteString(this.clientNonce);
        encoder.writeByteString(this.clientCertificate);
        encoder.writeDouble(this.requestedSessionTimeout);
        encoder.writeUInt32(this.maxResponseMessageSize);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSessionRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const clientDescription = decoder.readType(ApplicationDescription);
        const serverUri = decoder.readString();
        const endpointUrl = decoder.readString();
        const sessionName = decoder.readString();
        const clientNonce = decoder.readByteString();
        const clientCertificate = decoder.readByteString();
        const requestedSessionTimeout = decoder.readDouble();
        const maxResponseMessageSize = decoder.readUInt32();
        return new CreateSessionRequest({
            requestHeader,
            clientDescription,
            serverUri,
            endpointUrl,
            sessionName,
            clientNonce,
            clientCertificate,
            requestedSessionTimeout,
            maxResponseMessageSize
        });
    }
}
export interface CreateSessionResponseOptions {
    responseHeader?: ResponseHeader;
    sessionId?: NodeId;
    authenticationToken?: NodeId;
    revisedSessionTimeout?: Double;
    serverNonce?: ByteString;
    serverCertificate?: ByteString;
    serverEndpoints?: EndpointDescription[];
    serverSoftwareCertificates?: SignedSoftwareCertificate[];
    serverSignature?: SignatureData;
    maxRequestMessageSize?: UInt32;
}
export class CreateSessionResponse implements CreateSessionResponseOptions {
    responseHeader: ResponseHeader;
    sessionId: NodeId;
    authenticationToken: NodeId;
    revisedSessionTimeout: Double;
    serverNonce?: ByteString;
    serverCertificate?: ByteString;
    serverEndpoints?: EndpointDescription[];
    serverSoftwareCertificates?: SignedSoftwareCertificate[];
    serverSignature: SignatureData;
    maxRequestMessageSize: UInt32;
    constructor(options?: CreateSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.authenticationToken = options?.authenticationToken ?? NodeId.null();
        this.revisedSessionTimeout = options?.revisedSessionTimeout ?? 0;
        this.serverNonce = options?.serverNonce;
        this.serverCertificate = options?.serverCertificate;
        this.serverEndpoints = options?.serverEndpoints;
        this.serverSoftwareCertificates = options?.serverSoftwareCertificates;
        this.serverSignature = options?.serverSignature ?? new SignatureData();
        this.maxRequestMessageSize = options?.maxRequestMessageSize ?? 0;
    }
    static [typeId] = NodeIds.CreateSessionResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeType(this.sessionId);
        encoder.writeType(this.authenticationToken);
        encoder.writeDouble(this.revisedSessionTimeout);
        encoder.writeByteString(this.serverNonce);
        encoder.writeByteString(this.serverCertificate);
        encoder.writeTypeArray(this.serverEndpoints);
        encoder.writeTypeArray(this.serverSoftwareCertificates);
        encoder.writeType(this.serverSignature);
        encoder.writeUInt32(this.maxRequestMessageSize);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSessionResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const sessionId = decoder.readType(NodeId);
        const authenticationToken = decoder.readType(NodeId);
        const revisedSessionTimeout = decoder.readDouble();
        const serverNonce = decoder.readByteString();
        const serverCertificate = decoder.readByteString();
        const serverEndpoints = decoder.readTypeArray(EndpointDescription);
        const serverSoftwareCertificates = decoder.readTypeArray(SignedSoftwareCertificate);
        const serverSignature = decoder.readType(SignatureData);
        const maxRequestMessageSize = decoder.readUInt32();
        return new CreateSessionResponse({
            responseHeader,
            sessionId,
            authenticationToken,
            revisedSessionTimeout,
            serverNonce,
            serverCertificate,
            serverEndpoints,
            serverSoftwareCertificates,
            serverSignature,
            maxRequestMessageSize
        });
    }
}
export interface UserIdentityTokenOptions {
    policyId?: UaString;
}
export class UserIdentityToken implements UserIdentityTokenOptions {
    policyId?: UaString;
    constructor(options?: UserIdentityTokenOptions) {
        this.policyId = options?.policyId;
    }
    static [typeId] = NodeIds.UserIdentityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
    }
    static [decode](decoder: BinaryDataDecoder): UserIdentityToken {
        const policyId = decoder.readString();
        return new UserIdentityToken({
            policyId
        });
    }
}
export interface AnonymousIdentityTokenOptions {
    policyId?: UaString;
}
export class AnonymousIdentityToken implements AnonymousIdentityTokenOptions {
    policyId?: UaString;
    constructor(options?: AnonymousIdentityTokenOptions) {
        this.policyId = options?.policyId;
    }
    static [typeId] = NodeIds.AnonymousIdentityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
    }
    static [decode](decoder: BinaryDataDecoder): AnonymousIdentityToken {
        const policyId = decoder.readString();
        return new AnonymousIdentityToken({
            policyId
        });
    }
}
export interface UserNameIdentityTokenOptions {
    policyId?: UaString;
    userName?: UaString;
    password?: ByteString;
    encryptionAlgorithm?: UaString;
}
export class UserNameIdentityToken implements UserNameIdentityTokenOptions {
    policyId?: UaString;
    userName?: UaString;
    password?: ByteString;
    encryptionAlgorithm?: UaString;
    constructor(options?: UserNameIdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.userName = options?.userName;
        this.password = options?.password;
        this.encryptionAlgorithm = options?.encryptionAlgorithm;
    }
    static [typeId] = NodeIds.UserNameIdentityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeString(this.userName);
        encoder.writeByteString(this.password);
        encoder.writeString(this.encryptionAlgorithm);
    }
    static [decode](decoder: BinaryDataDecoder): UserNameIdentityToken {
        const policyId = decoder.readString();
        const userName = decoder.readString();
        const password = decoder.readByteString();
        const encryptionAlgorithm = decoder.readString();
        return new UserNameIdentityToken({
            policyId,
            userName,
            password,
            encryptionAlgorithm
        });
    }
}
export interface X509IdentityTokenOptions {
    policyId?: UaString;
    certificateData?: ByteString;
}
export class X509IdentityToken implements X509IdentityTokenOptions {
    policyId?: UaString;
    certificateData?: ByteString;
    constructor(options?: X509IdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.certificateData = options?.certificateData;
    }
    static [typeId] = NodeIds.X509IdentityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeByteString(this.certificateData);
    }
    static [decode](decoder: BinaryDataDecoder): X509IdentityToken {
        const policyId = decoder.readString();
        const certificateData = decoder.readByteString();
        return new X509IdentityToken({
            policyId,
            certificateData
        });
    }
}
export interface IssuedIdentityTokenOptions {
    policyId?: UaString;
    tokenData?: ByteString;
    encryptionAlgorithm?: UaString;
}
export class IssuedIdentityToken implements IssuedIdentityTokenOptions {
    policyId?: UaString;
    tokenData?: ByteString;
    encryptionAlgorithm?: UaString;
    constructor(options?: IssuedIdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.tokenData = options?.tokenData;
        this.encryptionAlgorithm = options?.encryptionAlgorithm;
    }
    static [typeId] = NodeIds.IssuedIdentityToken_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeByteString(this.tokenData);
        encoder.writeString(this.encryptionAlgorithm);
    }
    static [decode](decoder: BinaryDataDecoder): IssuedIdentityToken {
        const policyId = decoder.readString();
        const tokenData = decoder.readByteString();
        const encryptionAlgorithm = decoder.readString();
        return new IssuedIdentityToken({
            policyId,
            tokenData,
            encryptionAlgorithm
        });
    }
}
export interface ActivateSessionRequestOptions {
    requestHeader?: RequestHeader;
    clientSignature?: SignatureData;
    clientSoftwareCertificates?: SignedSoftwareCertificate[];
    localeIds?: UaString[];
    userIdentityToken?: ExtensionObject;
    userTokenSignature?: SignatureData;
}
export class ActivateSessionRequest implements ActivateSessionRequestOptions {
    requestHeader: RequestHeader;
    clientSignature: SignatureData;
    clientSoftwareCertificates?: SignedSoftwareCertificate[];
    localeIds?: UaString[];
    userIdentityToken: ExtensionObject;
    userTokenSignature: SignatureData;
    constructor(options?: ActivateSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientSignature = options?.clientSignature ?? new SignatureData();
        this.clientSoftwareCertificates = options?.clientSoftwareCertificates;
        this.localeIds = options?.localeIds;
        this.userIdentityToken = options?.userIdentityToken ?? new ExtensionObject();
        this.userTokenSignature = options?.userTokenSignature ?? new SignatureData();
    }
    static [typeId] = NodeIds.ActivateSessionRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.clientSignature);
        encoder.writeTypeArray(this.clientSoftwareCertificates);
        encoder.writeStringArray(this.localeIds);
        encoder.writeType(this.userIdentityToken);
        encoder.writeType(this.userTokenSignature);
    }
    static [decode](decoder: BinaryDataDecoder): ActivateSessionRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const clientSignature = decoder.readType(SignatureData);
        const clientSoftwareCertificates = decoder.readTypeArray(SignedSoftwareCertificate);
        const localeIds = decoder.readStringArray();
        const userIdentityToken = decoder.readType(ExtensionObject);
        const userTokenSignature = decoder.readType(SignatureData);
        return new ActivateSessionRequest({
            requestHeader,
            clientSignature,
            clientSoftwareCertificates,
            localeIds,
            userIdentityToken,
            userTokenSignature
        });
    }
}
export interface ActivateSessionResponseOptions {
    responseHeader?: ResponseHeader;
    serverNonce?: ByteString;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class ActivateSessionResponse implements ActivateSessionResponseOptions {
    responseHeader: ResponseHeader;
    serverNonce?: ByteString;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ActivateSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.serverNonce = options?.serverNonce;
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ActivateSessionResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeByteString(this.serverNonce);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ActivateSessionResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const serverNonce = decoder.readByteString();
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ActivateSessionResponse({
            responseHeader,
            serverNonce,
            results,
            diagnosticInfos
        });
    }
}
export interface CloseSessionRequestOptions {
    requestHeader?: RequestHeader;
    deleteSubscriptions?: boolean;
}
export class CloseSessionRequest implements CloseSessionRequestOptions {
    requestHeader: RequestHeader;
    deleteSubscriptions: boolean;
    constructor(options?: CloseSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.deleteSubscriptions = options?.deleteSubscriptions ?? false;
    }
    static [typeId] = NodeIds.CloseSessionRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.deleteSubscriptions);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSessionRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const deleteSubscriptions = decoder.readBoolean();
        return new CloseSessionRequest({
            requestHeader,
            deleteSubscriptions
        });
    }
}
export interface CloseSessionResponseOptions {
    responseHeader?: ResponseHeader;
}
export class CloseSessionResponse implements CloseSessionResponseOptions {
    responseHeader: ResponseHeader;
    constructor(options?: CloseSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.CloseSessionResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSessionResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        return new CloseSessionResponse({
            responseHeader
        });
    }
}
export interface CancelRequestOptions {
    requestHeader?: RequestHeader;
    requestHandle?: UInt32;
}
export class CancelRequest implements CancelRequestOptions {
    requestHeader: RequestHeader;
    requestHandle: UInt32;
    constructor(options?: CancelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.requestHandle = options?.requestHandle ?? 0;
    }
    static [typeId] = NodeIds.CancelRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.requestHandle);
    }
    static [decode](decoder: BinaryDataDecoder): CancelRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const requestHandle = decoder.readUInt32();
        return new CancelRequest({
            requestHeader,
            requestHandle
        });
    }
}
export interface CancelResponseOptions {
    responseHeader?: ResponseHeader;
    cancelCount?: UInt32;
}
export class CancelResponse implements CancelResponseOptions {
    responseHeader: ResponseHeader;
    cancelCount: UInt32;
    constructor(options?: CancelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.cancelCount = options?.cancelCount ?? 0;
    }
    static [typeId] = NodeIds.CancelResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.cancelCount);
    }
    static [decode](decoder: BinaryDataDecoder): CancelResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const cancelCount = decoder.readUInt32();
        return new CancelResponse({
            responseHeader,
            cancelCount
        });
    }
}
export enum NodeAttributesMask {
    None = 0,
    AccessLevel = 1,
    ArrayDimensions = 2,
    BrowseName = 4,
    ContainsNoLoops = 8,
    DataType = 16,
    Description = 32,
    DisplayName = 64,
    EventNotifier = 128,
    Executable = 256,
    Historizing = 512,
    InverseName = 1024,
    IsAbstract = 2048,
    MinimumSamplingInterval = 4096,
    NodeClass = 8192,
    NodeId = 16384,
    Symmetric = 32768,
    UserAccessLevel = 65536,
    UserExecutable = 131072,
    UserWriteMask = 262144,
    ValueRank = 524288,
    WriteMask = 1048576,
    Value = 2097152,
    DataTypeDefinition = 4194304,
    RolePermissions = 8388608,
    AccessRestrictions = 16777216,
    All = 33554431,
    BaseNode = 26501220,
    Object = 26501348,
    ObjectType = 26503268,
    Variable = 26571383,
    VariableType = 28600438,
    Method = 26632548,
    ReferenceType = 26537060,
    View = 26501356
}
export interface NodeAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
}
export class NodeAttributes implements NodeAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    constructor(options?: NodeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
    }
    static [typeId] = NodeIds.NodeAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
    }
    static [decode](decoder: BinaryDataDecoder): NodeAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        return new NodeAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask
        });
    }
}
export interface ObjectAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    eventNotifier?: Byte;
}
export class ObjectAttributes implements ObjectAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    eventNotifier: Byte;
    constructor(options?: ObjectAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ObjectAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const eventNotifier = decoder.readByte();
        return new ObjectAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            eventNotifier
        });
    }
}
export interface VariableAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    value?: Variant;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    accessLevel?: Byte;
    userAccessLevel?: Byte;
    minimumSamplingInterval?: Double;
    historizing?: boolean;
}
export class VariableAttributes implements VariableAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    value: Variant;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    accessLevel: Byte;
    userAccessLevel: Byte;
    minimumSamplingInterval: Double;
    historizing: boolean;
    constructor(options?: VariableAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.accessLevel = options?.accessLevel ?? 0;
        this.userAccessLevel = options?.userAccessLevel ?? 0;
        this.minimumSamplingInterval = options?.minimumSamplingInterval ?? 0;
        this.historizing = options?.historizing ?? false;
    }
    static [typeId] = NodeIds.VariableAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeByte(this.accessLevel);
        encoder.writeByte(this.userAccessLevel);
        encoder.writeDouble(this.minimumSamplingInterval);
        encoder.writeBoolean(this.historizing);
    }
    static [decode](decoder: BinaryDataDecoder): VariableAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const value = decoder.readType(Variant);
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const accessLevel = decoder.readByte();
        const userAccessLevel = decoder.readByte();
        const minimumSamplingInterval = decoder.readDouble();
        const historizing = decoder.readBoolean();
        return new VariableAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            value,
            dataType,
            valueRank,
            arrayDimensions,
            accessLevel,
            userAccessLevel,
            minimumSamplingInterval,
            historizing
        });
    }
}
export interface MethodAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    executable?: boolean;
    userExecutable?: boolean;
}
export class MethodAttributes implements MethodAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    executable: boolean;
    userExecutable: boolean;
    constructor(options?: MethodAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.executable = options?.executable ?? false;
        this.userExecutable = options?.userExecutable ?? false;
    }
    static [typeId] = NodeIds.MethodAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.executable);
        encoder.writeBoolean(this.userExecutable);
    }
    static [decode](decoder: BinaryDataDecoder): MethodAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const executable = decoder.readBoolean();
        const userExecutable = decoder.readBoolean();
        return new MethodAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            executable,
            userExecutable
        });
    }
}
export interface ObjectTypeAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    isAbstract?: boolean;
}
export class ObjectTypeAttributes implements ObjectTypeAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    isAbstract: boolean;
    constructor(options?: ObjectTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.ObjectTypeAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectTypeAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const isAbstract = decoder.readBoolean();
        return new ObjectTypeAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            isAbstract
        });
    }
}
export interface VariableTypeAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    value?: Variant;
    dataType?: NodeId;
    valueRank?: Int32;
    arrayDimensions?: UInt32[];
    isAbstract?: boolean;
}
export class VariableTypeAttributes implements VariableTypeAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    value: Variant;
    dataType: NodeId;
    valueRank: Int32;
    arrayDimensions?: UInt32[];
    isAbstract: boolean;
    constructor(options?: VariableTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.VariableTypeAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): VariableTypeAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const value = decoder.readType(Variant);
        const dataType = decoder.readType(NodeId);
        const valueRank = decoder.readInt32();
        const arrayDimensions = decoder.readUInt32Array();
        const isAbstract = decoder.readBoolean();
        return new VariableTypeAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            value,
            dataType,
            valueRank,
            arrayDimensions,
            isAbstract
        });
    }
}
export interface ReferenceTypeAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    isAbstract?: boolean;
    symmetric?: boolean;
    inverseName?: LocalizedText;
}
export class ReferenceTypeAttributes implements ReferenceTypeAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    isAbstract: boolean;
    symmetric: boolean;
    inverseName: LocalizedText;
    constructor(options?: ReferenceTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
        this.symmetric = options?.symmetric ?? false;
        this.inverseName = options?.inverseName ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ReferenceTypeAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeBoolean(this.symmetric);
        encoder.writeType(this.inverseName);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceTypeAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const isAbstract = decoder.readBoolean();
        const symmetric = decoder.readBoolean();
        const inverseName = decoder.readType(LocalizedText);
        return new ReferenceTypeAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            isAbstract,
            symmetric,
            inverseName
        });
    }
}
export interface DataTypeAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    isAbstract?: boolean;
}
export class DataTypeAttributes implements DataTypeAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    isAbstract: boolean;
    constructor(options?: DataTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.DataTypeAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const isAbstract = decoder.readBoolean();
        return new DataTypeAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            isAbstract
        });
    }
}
export interface ViewAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    containsNoLoops?: boolean;
    eventNotifier?: Byte;
}
export class ViewAttributes implements ViewAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    containsNoLoops: boolean;
    eventNotifier: Byte;
    constructor(options?: ViewAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.containsNoLoops = options?.containsNoLoops ?? false;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ViewAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.containsNoLoops);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ViewAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const containsNoLoops = decoder.readBoolean();
        const eventNotifier = decoder.readByte();
        return new ViewAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            containsNoLoops,
            eventNotifier
        });
    }
}
export interface GenericAttributeValueOptions {
    attributeId?: UInt32;
    value?: Variant;
}
export class GenericAttributeValue implements GenericAttributeValueOptions {
    attributeId: UInt32;
    value: Variant;
    constructor(options?: GenericAttributeValueOptions) {
        this.attributeId = options?.attributeId ?? 0;
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.GenericAttributeValue_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.attributeId);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): GenericAttributeValue {
        const attributeId = decoder.readUInt32();
        const value = decoder.readType(Variant);
        return new GenericAttributeValue({
            attributeId,
            value
        });
    }
}
export interface GenericAttributesOptions {
    specifiedAttributes?: UInt32;
    displayName?: LocalizedText;
    description?: LocalizedText;
    writeMask?: UInt32;
    userWriteMask?: UInt32;
    attributeValues?: GenericAttributeValue[];
}
export class GenericAttributes implements GenericAttributesOptions {
    specifiedAttributes: UInt32;
    displayName: LocalizedText;
    description: LocalizedText;
    writeMask: UInt32;
    userWriteMask: UInt32;
    attributeValues?: GenericAttributeValue[];
    constructor(options?: GenericAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.attributeValues = options?.attributeValues;
    }
    static [typeId] = NodeIds.GenericAttributes_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.attributeValues);
    }
    static [decode](decoder: BinaryDataDecoder): GenericAttributes {
        const specifiedAttributes = decoder.readUInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        const writeMask = decoder.readUInt32();
        const userWriteMask = decoder.readUInt32();
        const attributeValues = decoder.readTypeArray(GenericAttributeValue);
        return new GenericAttributes({
            specifiedAttributes,
            displayName,
            description,
            writeMask,
            userWriteMask,
            attributeValues
        });
    }
}
export interface AddNodesItemOptions {
    parentNodeId?: ExpandedNodeId;
    referenceTypeId?: NodeId;
    requestedNewNodeId?: ExpandedNodeId;
    browseName?: QualifiedName;
    nodeClass?: NodeClass;
    nodeAttributes?: ExtensionObject;
    typeDefinition?: ExpandedNodeId;
}
export class AddNodesItem implements AddNodesItemOptions {
    parentNodeId: ExpandedNodeId;
    referenceTypeId: NodeId;
    requestedNewNodeId: ExpandedNodeId;
    browseName: QualifiedName;
    nodeClass: NodeClass;
    nodeAttributes: ExtensionObject;
    typeDefinition: ExpandedNodeId;
    constructor(options?: AddNodesItemOptions) {
        this.parentNodeId = options?.parentNodeId ?? new ExpandedNodeId();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.requestedNewNodeId = options?.requestedNewNodeId ?? new ExpandedNodeId();
        this.browseName = options?.browseName ?? new QualifiedName();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.nodeAttributes = options?.nodeAttributes ?? new ExtensionObject();
        this.typeDefinition = options?.typeDefinition ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.AddNodesItem_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.parentNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeType(this.requestedNewNodeId);
        encoder.writeType(this.browseName);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.nodeAttributes);
        encoder.writeType(this.typeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesItem {
        const parentNodeId = decoder.readType(ExpandedNodeId);
        const referenceTypeId = decoder.readType(NodeId);
        const requestedNewNodeId = decoder.readType(ExpandedNodeId);
        const browseName = decoder.readType(QualifiedName);
        const nodeClass = decoder.readUInt32();
        const nodeAttributes = decoder.readType(ExtensionObject);
        const typeDefinition = decoder.readType(ExpandedNodeId);
        return new AddNodesItem({
            parentNodeId,
            referenceTypeId,
            requestedNewNodeId,
            browseName,
            nodeClass,
            nodeAttributes,
            typeDefinition
        });
    }
}
export interface AddNodesResultOptions {
    statusCode?: StatusCode;
    addedNodeId?: NodeId;
}
export class AddNodesResult implements AddNodesResultOptions {
    statusCode: StatusCode;
    addedNodeId: NodeId;
    constructor(options?: AddNodesResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.addedNodeId = options?.addedNodeId ?? NodeId.null();
    }
    static [typeId] = NodeIds.AddNodesResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeType(this.addedNodeId);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesResult {
        const statusCode = decoder.readType(StatusCode);
        const addedNodeId = decoder.readType(NodeId);
        return new AddNodesResult({
            statusCode,
            addedNodeId
        });
    }
}
export interface AddNodesRequestOptions {
    requestHeader?: RequestHeader;
    nodesToAdd?: AddNodesItem[];
}
export class AddNodesRequest implements AddNodesRequestOptions {
    requestHeader: RequestHeader;
    nodesToAdd?: AddNodesItem[];
    constructor(options?: AddNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToAdd = options?.nodesToAdd;
    }
    static [typeId] = NodeIds.AddNodesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToAdd);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const nodesToAdd = decoder.readTypeArray(AddNodesItem);
        return new AddNodesRequest({
            requestHeader,
            nodesToAdd
        });
    }
}
export interface AddNodesResponseOptions {
    responseHeader?: ResponseHeader;
    results?: AddNodesResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class AddNodesResponse implements AddNodesResponseOptions {
    responseHeader: ResponseHeader;
    results?: AddNodesResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: AddNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.AddNodesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(AddNodesResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new AddNodesResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface AddReferencesItemOptions {
    sourceNodeId?: NodeId;
    referenceTypeId?: NodeId;
    isForward?: boolean;
    targetServerUri?: UaString;
    targetNodeId?: ExpandedNodeId;
    targetNodeClass?: NodeClass;
}
export class AddReferencesItem implements AddReferencesItemOptions {
    sourceNodeId: NodeId;
    referenceTypeId: NodeId;
    isForward: boolean;
    targetServerUri?: UaString;
    targetNodeId: ExpandedNodeId;
    targetNodeClass: NodeClass;
    constructor(options?: AddReferencesItemOptions) {
        this.sourceNodeId = options?.sourceNodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.targetServerUri = options?.targetServerUri;
        this.targetNodeId = options?.targetNodeId ?? new ExpandedNodeId();
        this.targetNodeClass = options?.targetNodeClass ?? NodeClass.Unspecified;
    }
    static [typeId] = NodeIds.AddReferencesItem_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sourceNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeString(this.targetServerUri);
        encoder.writeType(this.targetNodeId);
        encoder.writeUInt32(this.targetNodeClass);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesItem {
        const sourceNodeId = decoder.readType(NodeId);
        const referenceTypeId = decoder.readType(NodeId);
        const isForward = decoder.readBoolean();
        const targetServerUri = decoder.readString();
        const targetNodeId = decoder.readType(ExpandedNodeId);
        const targetNodeClass = decoder.readUInt32();
        return new AddReferencesItem({
            sourceNodeId,
            referenceTypeId,
            isForward,
            targetServerUri,
            targetNodeId,
            targetNodeClass
        });
    }
}
export interface AddReferencesRequestOptions {
    requestHeader?: RequestHeader;
    referencesToAdd?: AddReferencesItem[];
}
export class AddReferencesRequest implements AddReferencesRequestOptions {
    requestHeader: RequestHeader;
    referencesToAdd?: AddReferencesItem[];
    constructor(options?: AddReferencesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.referencesToAdd = options?.referencesToAdd;
    }
    static [typeId] = NodeIds.AddReferencesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.referencesToAdd);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const referencesToAdd = decoder.readTypeArray(AddReferencesItem);
        return new AddReferencesRequest({
            requestHeader,
            referencesToAdd
        });
    }
}
export interface AddReferencesResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class AddReferencesResponse implements AddReferencesResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: AddReferencesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.AddReferencesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new AddReferencesResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface DeleteNodesItemOptions {
    nodeId?: NodeId;
    deleteTargetReferences?: boolean;
}
export class DeleteNodesItem implements DeleteNodesItemOptions {
    nodeId: NodeId;
    deleteTargetReferences: boolean;
    constructor(options?: DeleteNodesItemOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.deleteTargetReferences = options?.deleteTargetReferences ?? false;
    }
    static [typeId] = NodeIds.DeleteNodesItem_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeBoolean(this.deleteTargetReferences);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesItem {
        const nodeId = decoder.readType(NodeId);
        const deleteTargetReferences = decoder.readBoolean();
        return new DeleteNodesItem({
            nodeId,
            deleteTargetReferences
        });
    }
}
export interface DeleteNodesRequestOptions {
    requestHeader?: RequestHeader;
    nodesToDelete?: DeleteNodesItem[];
}
export class DeleteNodesRequest implements DeleteNodesRequestOptions {
    requestHeader: RequestHeader;
    nodesToDelete?: DeleteNodesItem[];
    constructor(options?: DeleteNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToDelete = options?.nodesToDelete;
    }
    static [typeId] = NodeIds.DeleteNodesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToDelete);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const nodesToDelete = decoder.readTypeArray(DeleteNodesItem);
        return new DeleteNodesRequest({
            requestHeader,
            nodesToDelete
        });
    }
}
export interface DeleteNodesResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class DeleteNodesResponse implements DeleteNodesResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteNodesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new DeleteNodesResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface DeleteReferencesItemOptions {
    sourceNodeId?: NodeId;
    referenceTypeId?: NodeId;
    isForward?: boolean;
    targetNodeId?: ExpandedNodeId;
    deleteBidirectional?: boolean;
}
export class DeleteReferencesItem implements DeleteReferencesItemOptions {
    sourceNodeId: NodeId;
    referenceTypeId: NodeId;
    isForward: boolean;
    targetNodeId: ExpandedNodeId;
    deleteBidirectional: boolean;
    constructor(options?: DeleteReferencesItemOptions) {
        this.sourceNodeId = options?.sourceNodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.targetNodeId = options?.targetNodeId ?? new ExpandedNodeId();
        this.deleteBidirectional = options?.deleteBidirectional ?? false;
    }
    static [typeId] = NodeIds.DeleteReferencesItem_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sourceNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeType(this.targetNodeId);
        encoder.writeBoolean(this.deleteBidirectional);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesItem {
        const sourceNodeId = decoder.readType(NodeId);
        const referenceTypeId = decoder.readType(NodeId);
        const isForward = decoder.readBoolean();
        const targetNodeId = decoder.readType(ExpandedNodeId);
        const deleteBidirectional = decoder.readBoolean();
        return new DeleteReferencesItem({
            sourceNodeId,
            referenceTypeId,
            isForward,
            targetNodeId,
            deleteBidirectional
        });
    }
}
export interface DeleteReferencesRequestOptions {
    requestHeader?: RequestHeader;
    referencesToDelete?: DeleteReferencesItem[];
}
export class DeleteReferencesRequest implements DeleteReferencesRequestOptions {
    requestHeader: RequestHeader;
    referencesToDelete?: DeleteReferencesItem[];
    constructor(options?: DeleteReferencesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.referencesToDelete = options?.referencesToDelete;
    }
    static [typeId] = NodeIds.DeleteReferencesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.referencesToDelete);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const referencesToDelete = decoder.readTypeArray(DeleteReferencesItem);
        return new DeleteReferencesRequest({
            requestHeader,
            referencesToDelete
        });
    }
}
export interface DeleteReferencesResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class DeleteReferencesResponse implements DeleteReferencesResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteReferencesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteReferencesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new DeleteReferencesResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export enum AttributeWriteMask {
    None = 0,
    AccessLevel = 1,
    ArrayDimensions = 2,
    BrowseName = 4,
    ContainsNoLoops = 8,
    DataType = 16,
    Description = 32,
    DisplayName = 64,
    EventNotifier = 128,
    Executable = 256,
    Historizing = 512,
    InverseName = 1024,
    IsAbstract = 2048,
    MinimumSamplingInterval = 4096,
    NodeClass = 8192,
    NodeId = 16384,
    Symmetric = 32768,
    UserAccessLevel = 65536,
    UserExecutable = 131072,
    UserWriteMask = 262144,
    ValueRank = 524288,
    WriteMask = 1048576,
    ValueForVariableType = 2097152,
    DataTypeDefinition = 4194304,
    RolePermissions = 8388608,
    AccessRestrictions = 16777216,
    AccessLevelEx = 33554432
}
export enum BrowseDirection {
    Forward = 0,
    Inverse = 1,
    Both = 2,
    Invalid = 3
}
export interface ViewDescriptionOptions {
    viewId?: NodeId;
    timestamp?: Date;
    viewVersion?: UInt32;
}
export class ViewDescription implements ViewDescriptionOptions {
    viewId: NodeId;
    timestamp: Date;
    viewVersion: UInt32;
    constructor(options?: ViewDescriptionOptions) {
        this.viewId = options?.viewId ?? NodeId.null();
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.viewVersion = options?.viewVersion ?? 0;
    }
    static [typeId] = NodeIds.ViewDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.viewId);
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.viewVersion);
    }
    static [decode](decoder: BinaryDataDecoder): ViewDescription {
        const viewId = decoder.readType(NodeId);
        const timestamp = decoder.readDateTime();
        const viewVersion = decoder.readUInt32();
        return new ViewDescription({
            viewId,
            timestamp,
            viewVersion
        });
    }
}
export interface BrowseDescriptionOptions {
    nodeId?: NodeId;
    browseDirection?: BrowseDirection;
    referenceTypeId?: NodeId;
    includeSubtypes?: boolean;
    nodeClassMask?: UInt32;
    resultMask?: UInt32;
}
export class BrowseDescription implements BrowseDescriptionOptions {
    nodeId: NodeId;
    browseDirection: BrowseDirection;
    referenceTypeId: NodeId;
    includeSubtypes: boolean;
    nodeClassMask: UInt32;
    resultMask: UInt32;
    constructor(options?: BrowseDescriptionOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.browseDirection = options?.browseDirection ?? BrowseDirection.Forward;
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.includeSubtypes = options?.includeSubtypes ?? false;
        this.nodeClassMask = options?.nodeClassMask ?? 0;
        this.resultMask = options?.resultMask ?? 0;
    }
    static [typeId] = NodeIds.BrowseDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.browseDirection);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.includeSubtypes);
        encoder.writeUInt32(this.nodeClassMask);
        encoder.writeUInt32(this.resultMask);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseDescription {
        const nodeId = decoder.readType(NodeId);
        const browseDirection = decoder.readUInt32();
        const referenceTypeId = decoder.readType(NodeId);
        const includeSubtypes = decoder.readBoolean();
        const nodeClassMask = decoder.readUInt32();
        const resultMask = decoder.readUInt32();
        return new BrowseDescription({
            nodeId,
            browseDirection,
            referenceTypeId,
            includeSubtypes,
            nodeClassMask,
            resultMask
        });
    }
}
export enum BrowseResultMask {
    None = 0,
    ReferenceTypeId = 1,
    IsForward = 2,
    NodeClass = 4,
    BrowseName = 8,
    DisplayName = 16,
    TypeDefinition = 32,
    All = 63,
    ReferenceTypeInfo = 3,
    TargetInfo = 60
}
export interface ReferenceDescriptionOptions {
    referenceTypeId?: NodeId;
    isForward?: boolean;
    nodeId?: ExpandedNodeId;
    browseName?: QualifiedName;
    displayName?: LocalizedText;
    nodeClass?: NodeClass;
    typeDefinition?: ExpandedNodeId;
}
export class ReferenceDescription implements ReferenceDescriptionOptions {
    referenceTypeId: NodeId;
    isForward: boolean;
    nodeId: ExpandedNodeId;
    browseName: QualifiedName;
    displayName: LocalizedText;
    nodeClass: NodeClass;
    typeDefinition: ExpandedNodeId;
    constructor(options?: ReferenceDescriptionOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.nodeId = options?.nodeId ?? new ExpandedNodeId();
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.typeDefinition = options?.typeDefinition ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.ReferenceDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeType(this.nodeId);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.typeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceDescription {
        const referenceTypeId = decoder.readType(NodeId);
        const isForward = decoder.readBoolean();
        const nodeId = decoder.readType(ExpandedNodeId);
        const browseName = decoder.readType(QualifiedName);
        const displayName = decoder.readType(LocalizedText);
        const nodeClass = decoder.readUInt32();
        const typeDefinition = decoder.readType(ExpandedNodeId);
        return new ReferenceDescription({
            referenceTypeId,
            isForward,
            nodeId,
            browseName,
            displayName,
            nodeClass,
            typeDefinition
        });
    }
}
export interface BrowseResultOptions {
    statusCode?: StatusCode;
    continuationPoint?: ByteString;
    references?: ReferenceDescription[];
}
export class BrowseResult implements BrowseResultOptions {
    statusCode: StatusCode;
    continuationPoint?: ByteString;
    references?: ReferenceDescription[];
    constructor(options?: BrowseResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.continuationPoint = options?.continuationPoint;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.BrowseResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseResult {
        const statusCode = decoder.readType(StatusCode);
        const continuationPoint = decoder.readByteString();
        const references = decoder.readTypeArray(ReferenceDescription);
        return new BrowseResult({
            statusCode,
            continuationPoint,
            references
        });
    }
}
export interface BrowseRequestOptions {
    requestHeader?: RequestHeader;
    view?: ViewDescription;
    requestedMaxReferencesPerNode?: UInt32;
    nodesToBrowse?: BrowseDescription[];
}
export class BrowseRequest implements BrowseRequestOptions {
    requestHeader: RequestHeader;
    view: ViewDescription;
    requestedMaxReferencesPerNode: UInt32;
    nodesToBrowse?: BrowseDescription[];
    constructor(options?: BrowseRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.view = options?.view ?? new ViewDescription();
        this.requestedMaxReferencesPerNode = options?.requestedMaxReferencesPerNode ?? 0;
        this.nodesToBrowse = options?.nodesToBrowse;
    }
    static [typeId] = NodeIds.BrowseRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.view);
        encoder.writeUInt32(this.requestedMaxReferencesPerNode);
        encoder.writeTypeArray(this.nodesToBrowse);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const view = decoder.readType(ViewDescription);
        const requestedMaxReferencesPerNode = decoder.readUInt32();
        const nodesToBrowse = decoder.readTypeArray(BrowseDescription);
        return new BrowseRequest({
            requestHeader,
            view,
            requestedMaxReferencesPerNode,
            nodesToBrowse
        });
    }
}
export interface BrowseResponseOptions {
    responseHeader?: ResponseHeader;
    results?: BrowseResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class BrowseResponse implements BrowseResponseOptions {
    responseHeader: ResponseHeader;
    results?: BrowseResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: BrowseResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.BrowseResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(BrowseResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new BrowseResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface BrowseNextRequestOptions {
    requestHeader?: RequestHeader;
    releaseContinuationPoints?: boolean;
    continuationPoints?: ByteString[];
}
export class BrowseNextRequest implements BrowseNextRequestOptions {
    requestHeader: RequestHeader;
    releaseContinuationPoints: boolean;
    continuationPoints?: ByteString[];
    constructor(options?: BrowseNextRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.releaseContinuationPoints = options?.releaseContinuationPoints ?? false;
        this.continuationPoints = options?.continuationPoints;
    }
    static [typeId] = NodeIds.BrowseNextRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.releaseContinuationPoints);
        encoder.writeByteStringArray(this.continuationPoints);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseNextRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const releaseContinuationPoints = decoder.readBoolean();
        const continuationPoints = decoder.readByteStringArray();
        return new BrowseNextRequest({
            requestHeader,
            releaseContinuationPoints,
            continuationPoints
        });
    }
}
export interface BrowseNextResponseOptions {
    responseHeader?: ResponseHeader;
    results?: BrowseResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class BrowseNextResponse implements BrowseNextResponseOptions {
    responseHeader: ResponseHeader;
    results?: BrowseResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: BrowseNextResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.BrowseNextResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseNextResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(BrowseResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new BrowseNextResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface RelativePathElementOptions {
    referenceTypeId?: NodeId;
    isInverse?: boolean;
    includeSubtypes?: boolean;
    targetName?: QualifiedName;
}
export class RelativePathElement implements RelativePathElementOptions {
    referenceTypeId: NodeId;
    isInverse: boolean;
    includeSubtypes: boolean;
    targetName: QualifiedName;
    constructor(options?: RelativePathElementOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isInverse = options?.isInverse ?? false;
        this.includeSubtypes = options?.includeSubtypes ?? false;
        this.targetName = options?.targetName ?? new QualifiedName();
    }
    static [typeId] = NodeIds.RelativePathElement_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isInverse);
        encoder.writeBoolean(this.includeSubtypes);
        encoder.writeType(this.targetName);
    }
    static [decode](decoder: BinaryDataDecoder): RelativePathElement {
        const referenceTypeId = decoder.readType(NodeId);
        const isInverse = decoder.readBoolean();
        const includeSubtypes = decoder.readBoolean();
        const targetName = decoder.readType(QualifiedName);
        return new RelativePathElement({
            referenceTypeId,
            isInverse,
            includeSubtypes,
            targetName
        });
    }
}
export interface RelativePathOptions {
    elements?: RelativePathElement[];
}
export class RelativePath implements RelativePathOptions {
    elements?: RelativePathElement[];
    constructor(options?: RelativePathOptions) {
        this.elements = options?.elements;
    }
    static [typeId] = NodeIds.RelativePath_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elements);
    }
    static [decode](decoder: BinaryDataDecoder): RelativePath {
        const elements = decoder.readTypeArray(RelativePathElement);
        return new RelativePath({
            elements
        });
    }
}
export interface BrowsePathOptions {
    startingNode?: NodeId;
    relativePath?: RelativePath;
}
export class BrowsePath implements BrowsePathOptions {
    startingNode: NodeId;
    relativePath: RelativePath;
    constructor(options?: BrowsePathOptions) {
        this.startingNode = options?.startingNode ?? NodeId.null();
        this.relativePath = options?.relativePath ?? new RelativePath();
    }
    static [typeId] = NodeIds.BrowsePath_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.startingNode);
        encoder.writeType(this.relativePath);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePath {
        const startingNode = decoder.readType(NodeId);
        const relativePath = decoder.readType(RelativePath);
        return new BrowsePath({
            startingNode,
            relativePath
        });
    }
}
export interface BrowsePathTargetOptions {
    targetId?: ExpandedNodeId;
    remainingPathIndex?: UInt32;
}
export class BrowsePathTarget implements BrowsePathTargetOptions {
    targetId: ExpandedNodeId;
    remainingPathIndex: UInt32;
    constructor(options?: BrowsePathTargetOptions) {
        this.targetId = options?.targetId ?? new ExpandedNodeId();
        this.remainingPathIndex = options?.remainingPathIndex ?? 0;
    }
    static [typeId] = NodeIds.BrowsePathTarget_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.targetId);
        encoder.writeUInt32(this.remainingPathIndex);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePathTarget {
        const targetId = decoder.readType(ExpandedNodeId);
        const remainingPathIndex = decoder.readUInt32();
        return new BrowsePathTarget({
            targetId,
            remainingPathIndex
        });
    }
}
export interface BrowsePathResultOptions {
    statusCode?: StatusCode;
    targets?: BrowsePathTarget[];
}
export class BrowsePathResult implements BrowsePathResultOptions {
    statusCode: StatusCode;
    targets?: BrowsePathTarget[];
    constructor(options?: BrowsePathResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.targets = options?.targets;
    }
    static [typeId] = NodeIds.BrowsePathResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.targets);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePathResult {
        const statusCode = decoder.readType(StatusCode);
        const targets = decoder.readTypeArray(BrowsePathTarget);
        return new BrowsePathResult({
            statusCode,
            targets
        });
    }
}
export interface TranslateBrowsePathsToNodeIdsRequestOptions {
    requestHeader?: RequestHeader;
    browsePaths?: BrowsePath[];
}
export class TranslateBrowsePathsToNodeIdsRequest implements TranslateBrowsePathsToNodeIdsRequestOptions {
    requestHeader: RequestHeader;
    browsePaths?: BrowsePath[];
    constructor(options?: TranslateBrowsePathsToNodeIdsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.browsePaths = options?.browsePaths;
    }
    static [typeId] = NodeIds.TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.browsePaths);
    }
    static [decode](decoder: BinaryDataDecoder): TranslateBrowsePathsToNodeIdsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const browsePaths = decoder.readTypeArray(BrowsePath);
        return new TranslateBrowsePathsToNodeIdsRequest({
            requestHeader,
            browsePaths
        });
    }
}
export interface TranslateBrowsePathsToNodeIdsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: BrowsePathResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class TranslateBrowsePathsToNodeIdsResponse implements TranslateBrowsePathsToNodeIdsResponseOptions {
    responseHeader: ResponseHeader;
    results?: BrowsePathResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: TranslateBrowsePathsToNodeIdsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.TranslateBrowsePathsToNodeIdsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): TranslateBrowsePathsToNodeIdsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(BrowsePathResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new TranslateBrowsePathsToNodeIdsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface RegisterNodesRequestOptions {
    requestHeader?: RequestHeader;
    nodesToRegister?: NodeId[];
}
export class RegisterNodesRequest implements RegisterNodesRequestOptions {
    requestHeader: RequestHeader;
    nodesToRegister?: NodeId[];
    constructor(options?: RegisterNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToRegister = options?.nodesToRegister;
    }
    static [typeId] = NodeIds.RegisterNodesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToRegister);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterNodesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const nodesToRegister = decoder.readTypeArray(NodeId);
        return new RegisterNodesRequest({
            requestHeader,
            nodesToRegister
        });
    }
}
export interface RegisterNodesResponseOptions {
    responseHeader?: ResponseHeader;
    registeredNodeIds?: NodeId[];
}
export class RegisterNodesResponse implements RegisterNodesResponseOptions {
    responseHeader: ResponseHeader;
    registeredNodeIds?: NodeId[];
    constructor(options?: RegisterNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.registeredNodeIds = options?.registeredNodeIds;
    }
    static [typeId] = NodeIds.RegisterNodesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.registeredNodeIds);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterNodesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const registeredNodeIds = decoder.readTypeArray(NodeId);
        return new RegisterNodesResponse({
            responseHeader,
            registeredNodeIds
        });
    }
}
export interface UnregisterNodesRequestOptions {
    requestHeader?: RequestHeader;
    nodesToUnregister?: NodeId[];
}
export class UnregisterNodesRequest implements UnregisterNodesRequestOptions {
    requestHeader: RequestHeader;
    nodesToUnregister?: NodeId[];
    constructor(options?: UnregisterNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToUnregister = options?.nodesToUnregister;
    }
    static [typeId] = NodeIds.UnregisterNodesRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToUnregister);
    }
    static [decode](decoder: BinaryDataDecoder): UnregisterNodesRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const nodesToUnregister = decoder.readTypeArray(NodeId);
        return new UnregisterNodesRequest({
            requestHeader,
            nodesToUnregister
        });
    }
}
export interface UnregisterNodesResponseOptions {
    responseHeader?: ResponseHeader;
}
export class UnregisterNodesResponse implements UnregisterNodesResponseOptions {
    responseHeader: ResponseHeader;
    constructor(options?: UnregisterNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.UnregisterNodesResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): UnregisterNodesResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        return new UnregisterNodesResponse({
            responseHeader
        });
    }
}
export interface EndpointConfigurationOptions {
    operationTimeout?: Int32;
    useBinaryEncoding?: boolean;
    maxStringLength?: Int32;
    maxByteStringLength?: Int32;
    maxArrayLength?: Int32;
    maxMessageSize?: Int32;
    maxBufferSize?: Int32;
    channelLifetime?: Int32;
    securityTokenLifetime?: Int32;
}
export class EndpointConfiguration implements EndpointConfigurationOptions {
    operationTimeout: Int32;
    useBinaryEncoding: boolean;
    maxStringLength: Int32;
    maxByteStringLength: Int32;
    maxArrayLength: Int32;
    maxMessageSize: Int32;
    maxBufferSize: Int32;
    channelLifetime: Int32;
    securityTokenLifetime: Int32;
    constructor(options?: EndpointConfigurationOptions) {
        this.operationTimeout = options?.operationTimeout ?? 0;
        this.useBinaryEncoding = options?.useBinaryEncoding ?? false;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.maxByteStringLength = options?.maxByteStringLength ?? 0;
        this.maxArrayLength = options?.maxArrayLength ?? 0;
        this.maxMessageSize = options?.maxMessageSize ?? 0;
        this.maxBufferSize = options?.maxBufferSize ?? 0;
        this.channelLifetime = options?.channelLifetime ?? 0;
        this.securityTokenLifetime = options?.securityTokenLifetime ?? 0;
    }
    static [typeId] = NodeIds.EndpointConfiguration_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt32(this.operationTimeout);
        encoder.writeBoolean(this.useBinaryEncoding);
        encoder.writeInt32(this.maxStringLength);
        encoder.writeInt32(this.maxByteStringLength);
        encoder.writeInt32(this.maxArrayLength);
        encoder.writeInt32(this.maxMessageSize);
        encoder.writeInt32(this.maxBufferSize);
        encoder.writeInt32(this.channelLifetime);
        encoder.writeInt32(this.securityTokenLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointConfiguration {
        const operationTimeout = decoder.readInt32();
        const useBinaryEncoding = decoder.readBoolean();
        const maxStringLength = decoder.readInt32();
        const maxByteStringLength = decoder.readInt32();
        const maxArrayLength = decoder.readInt32();
        const maxMessageSize = decoder.readInt32();
        const maxBufferSize = decoder.readInt32();
        const channelLifetime = decoder.readInt32();
        const securityTokenLifetime = decoder.readInt32();
        return new EndpointConfiguration({
            operationTimeout,
            useBinaryEncoding,
            maxStringLength,
            maxByteStringLength,
            maxArrayLength,
            maxMessageSize,
            maxBufferSize,
            channelLifetime,
            securityTokenLifetime
        });
    }
}
export interface QueryDataDescriptionOptions {
    relativePath?: RelativePath;
    attributeId?: UInt32;
    indexRange?: UaString;
}
export class QueryDataDescription implements QueryDataDescriptionOptions {
    relativePath: RelativePath;
    attributeId: UInt32;
    indexRange?: UaString;
    constructor(options?: QueryDataDescriptionOptions) {
        this.relativePath = options?.relativePath ?? new RelativePath();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.QueryDataDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.relativePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): QueryDataDescription {
        const relativePath = decoder.readType(RelativePath);
        const attributeId = decoder.readUInt32();
        const indexRange = decoder.readString();
        return new QueryDataDescription({
            relativePath,
            attributeId,
            indexRange
        });
    }
}
export interface NodeTypeDescriptionOptions {
    typeDefinitionNode?: ExpandedNodeId;
    includeSubTypes?: boolean;
    dataToReturn?: QueryDataDescription[];
}
export class NodeTypeDescription implements NodeTypeDescriptionOptions {
    typeDefinitionNode: ExpandedNodeId;
    includeSubTypes: boolean;
    dataToReturn?: QueryDataDescription[];
    constructor(options?: NodeTypeDescriptionOptions) {
        this.typeDefinitionNode = options?.typeDefinitionNode ?? new ExpandedNodeId();
        this.includeSubTypes = options?.includeSubTypes ?? false;
        this.dataToReturn = options?.dataToReturn;
    }
    static [typeId] = NodeIds.NodeTypeDescription_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.typeDefinitionNode);
        encoder.writeBoolean(this.includeSubTypes);
        encoder.writeTypeArray(this.dataToReturn);
    }
    static [decode](decoder: BinaryDataDecoder): NodeTypeDescription {
        const typeDefinitionNode = decoder.readType(ExpandedNodeId);
        const includeSubTypes = decoder.readBoolean();
        const dataToReturn = decoder.readTypeArray(QueryDataDescription);
        return new NodeTypeDescription({
            typeDefinitionNode,
            includeSubTypes,
            dataToReturn
        });
    }
}
export enum FilterOperator {
    Equals = 0,
    IsNull = 1,
    GreaterThan = 2,
    LessThan = 3,
    GreaterThanOrEqual = 4,
    LessThanOrEqual = 5,
    Like = 6,
    Not = 7,
    Between = 8,
    InList = 9,
    And = 10,
    Or = 11,
    Cast = 12,
    InView = 13,
    OfType = 14,
    RelatedTo = 15,
    BitwiseAnd = 16,
    BitwiseOr = 17
}
export interface QueryDataSetOptions {
    nodeId?: ExpandedNodeId;
    typeDefinitionNode?: ExpandedNodeId;
    values?: Variant[];
}
export class QueryDataSet implements QueryDataSetOptions {
    nodeId: ExpandedNodeId;
    typeDefinitionNode: ExpandedNodeId;
    values?: Variant[];
    constructor(options?: QueryDataSetOptions) {
        this.nodeId = options?.nodeId ?? new ExpandedNodeId();
        this.typeDefinitionNode = options?.typeDefinitionNode ?? new ExpandedNodeId();
        this.values = options?.values;
    }
    static [typeId] = NodeIds.QueryDataSet_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeType(this.typeDefinitionNode);
        encoder.writeTypeArray(this.values);
    }
    static [decode](decoder: BinaryDataDecoder): QueryDataSet {
        const nodeId = decoder.readType(ExpandedNodeId);
        const typeDefinitionNode = decoder.readType(ExpandedNodeId);
        const values = decoder.readTypeArray(Variant);
        return new QueryDataSet({
            nodeId,
            typeDefinitionNode,
            values
        });
    }
}
export interface NodeReferenceOptions {
    nodeId?: NodeId;
    referenceTypeId?: NodeId;
    isForward?: boolean;
    referencedNodeIds?: NodeId[];
}
export class NodeReference implements NodeReferenceOptions {
    nodeId: NodeId;
    referenceTypeId: NodeId;
    isForward: boolean;
    referencedNodeIds?: NodeId[];
    constructor(options?: NodeReferenceOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.referencedNodeIds = options?.referencedNodeIds;
    }
    static [typeId] = NodeIds.NodeReference_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeTypeArray(this.referencedNodeIds);
    }
    static [decode](decoder: BinaryDataDecoder): NodeReference {
        const nodeId = decoder.readType(NodeId);
        const referenceTypeId = decoder.readType(NodeId);
        const isForward = decoder.readBoolean();
        const referencedNodeIds = decoder.readTypeArray(NodeId);
        return new NodeReference({
            nodeId,
            referenceTypeId,
            isForward,
            referencedNodeIds
        });
    }
}
export interface ContentFilterElementOptions {
    filterOperator?: FilterOperator;
    filterOperands?: ExtensionObject[];
}
export class ContentFilterElement implements ContentFilterElementOptions {
    filterOperator: FilterOperator;
    filterOperands?: ExtensionObject[];
    constructor(options?: ContentFilterElementOptions) {
        this.filterOperator = options?.filterOperator ?? FilterOperator.Equals;
        this.filterOperands = options?.filterOperands;
    }
    static [typeId] = NodeIds.ContentFilterElement_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.filterOperator);
        encoder.writeTypeArray(this.filterOperands);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterElement {
        const filterOperator = decoder.readUInt32();
        const filterOperands = decoder.readTypeArray(ExtensionObject);
        return new ContentFilterElement({
            filterOperator,
            filterOperands
        });
    }
}
export interface ContentFilterOptions {
    elements?: ContentFilterElement[];
}
export class ContentFilter implements ContentFilterOptions {
    elements?: ContentFilterElement[];
    constructor(options?: ContentFilterOptions) {
        this.elements = options?.elements;
    }
    static [typeId] = NodeIds.ContentFilter_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elements);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilter {
        const elements = decoder.readTypeArray(ContentFilterElement);
        return new ContentFilter({
            elements
        });
    }
}
export class FilterOperand {
    static [typeId] = NodeIds.FilterOperand_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): FilterOperand {
        return new FilterOperand();
    }
}
export interface ElementOperandOptions {
    index?: UInt32;
}
export class ElementOperand implements ElementOperandOptions {
    index: UInt32;
    constructor(options?: ElementOperandOptions) {
        this.index = options?.index ?? 0;
    }
    static [typeId] = NodeIds.ElementOperand_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.index);
    }
    static [decode](decoder: BinaryDataDecoder): ElementOperand {
        const index = decoder.readUInt32();
        return new ElementOperand({
            index
        });
    }
}
export interface LiteralOperandOptions {
    value?: Variant;
}
export class LiteralOperand implements LiteralOperandOptions {
    value: Variant;
    constructor(options?: LiteralOperandOptions) {
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.LiteralOperand_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): LiteralOperand {
        const value = decoder.readType(Variant);
        return new LiteralOperand({
            value
        });
    }
}
export interface AttributeOperandOptions {
    nodeId?: NodeId;
    alias?: UaString;
    browsePath?: RelativePath;
    attributeId?: UInt32;
    indexRange?: UaString;
}
export class AttributeOperand implements AttributeOperandOptions {
    nodeId: NodeId;
    alias?: UaString;
    browsePath: RelativePath;
    attributeId: UInt32;
    indexRange?: UaString;
    constructor(options?: AttributeOperandOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.alias = options?.alias;
        this.browsePath = options?.browsePath ?? new RelativePath();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.AttributeOperand_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeString(this.alias);
        encoder.writeType(this.browsePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): AttributeOperand {
        const nodeId = decoder.readType(NodeId);
        const alias = decoder.readString();
        const browsePath = decoder.readType(RelativePath);
        const attributeId = decoder.readUInt32();
        const indexRange = decoder.readString();
        return new AttributeOperand({
            nodeId,
            alias,
            browsePath,
            attributeId,
            indexRange
        });
    }
}
export interface SimpleAttributeOperandOptions {
    typeDefinitionId?: NodeId;
    browsePath?: QualifiedName[];
    attributeId?: UInt32;
    indexRange?: UaString;
}
export class SimpleAttributeOperand implements SimpleAttributeOperandOptions {
    typeDefinitionId: NodeId;
    browsePath?: QualifiedName[];
    attributeId: UInt32;
    indexRange?: UaString;
    constructor(options?: SimpleAttributeOperandOptions) {
        this.typeDefinitionId = options?.typeDefinitionId ?? NodeId.null();
        this.browsePath = options?.browsePath;
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.SimpleAttributeOperand_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.typeDefinitionId);
        encoder.writeTypeArray(this.browsePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): SimpleAttributeOperand {
        const typeDefinitionId = decoder.readType(NodeId);
        const browsePath = decoder.readTypeArray(QualifiedName);
        const attributeId = decoder.readUInt32();
        const indexRange = decoder.readString();
        return new SimpleAttributeOperand({
            typeDefinitionId,
            browsePath,
            attributeId,
            indexRange
        });
    }
}
export interface ContentFilterElementResultOptions {
    statusCode?: StatusCode;
    operandStatusCodes?: StatusCode[];
    operandDiagnosticInfos?: DiagnosticInfo[];
}
export class ContentFilterElementResult implements ContentFilterElementResultOptions {
    statusCode: StatusCode;
    operandStatusCodes?: StatusCode[];
    operandDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ContentFilterElementResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.operandStatusCodes = options?.operandStatusCodes;
        this.operandDiagnosticInfos = options?.operandDiagnosticInfos;
    }
    static [typeId] = NodeIds.ContentFilterElementResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.operandStatusCodes);
        encoder.writeTypeArray(this.operandDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterElementResult {
        const statusCode = decoder.readType(StatusCode);
        const operandStatusCodes = decoder.readTypeArray(StatusCode);
        const operandDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ContentFilterElementResult({
            statusCode,
            operandStatusCodes,
            operandDiagnosticInfos
        });
    }
}
export interface ContentFilterResultOptions {
    elementResults?: ContentFilterElementResult[];
    elementDiagnosticInfos?: DiagnosticInfo[];
}
export class ContentFilterResult implements ContentFilterResultOptions {
    elementResults?: ContentFilterElementResult[];
    elementDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ContentFilterResultOptions) {
        this.elementResults = options?.elementResults;
        this.elementDiagnosticInfos = options?.elementDiagnosticInfos;
    }
    static [typeId] = NodeIds.ContentFilterResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elementResults);
        encoder.writeTypeArray(this.elementDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterResult {
        const elementResults = decoder.readTypeArray(ContentFilterElementResult);
        const elementDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ContentFilterResult({
            elementResults,
            elementDiagnosticInfos
        });
    }
}
export interface ParsingResultOptions {
    statusCode?: StatusCode;
    dataStatusCodes?: StatusCode[];
    dataDiagnosticInfos?: DiagnosticInfo[];
}
export class ParsingResult implements ParsingResultOptions {
    statusCode: StatusCode;
    dataStatusCodes?: StatusCode[];
    dataDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ParsingResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.dataStatusCodes = options?.dataStatusCodes;
        this.dataDiagnosticInfos = options?.dataDiagnosticInfos;
    }
    static [typeId] = NodeIds.ParsingResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.dataStatusCodes);
        encoder.writeTypeArray(this.dataDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ParsingResult {
        const statusCode = decoder.readType(StatusCode);
        const dataStatusCodes = decoder.readTypeArray(StatusCode);
        const dataDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ParsingResult({
            statusCode,
            dataStatusCodes,
            dataDiagnosticInfos
        });
    }
}
export interface QueryFirstRequestOptions {
    requestHeader?: RequestHeader;
    view?: ViewDescription;
    nodeTypes?: NodeTypeDescription[];
    filter?: ContentFilter;
    maxDataSetsToReturn?: UInt32;
    maxReferencesToReturn?: UInt32;
}
export class QueryFirstRequest implements QueryFirstRequestOptions {
    requestHeader: RequestHeader;
    view: ViewDescription;
    nodeTypes?: NodeTypeDescription[];
    filter: ContentFilter;
    maxDataSetsToReturn: UInt32;
    maxReferencesToReturn: UInt32;
    constructor(options?: QueryFirstRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.view = options?.view ?? new ViewDescription();
        this.nodeTypes = options?.nodeTypes;
        this.filter = options?.filter ?? new ContentFilter();
        this.maxDataSetsToReturn = options?.maxDataSetsToReturn ?? 0;
        this.maxReferencesToReturn = options?.maxReferencesToReturn ?? 0;
    }
    static [typeId] = NodeIds.QueryFirstRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.view);
        encoder.writeTypeArray(this.nodeTypes);
        encoder.writeType(this.filter);
        encoder.writeUInt32(this.maxDataSetsToReturn);
        encoder.writeUInt32(this.maxReferencesToReturn);
    }
    static [decode](decoder: BinaryDataDecoder): QueryFirstRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const view = decoder.readType(ViewDescription);
        const nodeTypes = decoder.readTypeArray(NodeTypeDescription);
        const filter = decoder.readType(ContentFilter);
        const maxDataSetsToReturn = decoder.readUInt32();
        const maxReferencesToReturn = decoder.readUInt32();
        return new QueryFirstRequest({
            requestHeader,
            view,
            nodeTypes,
            filter,
            maxDataSetsToReturn,
            maxReferencesToReturn
        });
    }
}
export interface QueryFirstResponseOptions {
    responseHeader?: ResponseHeader;
    queryDataSets?: QueryDataSet[];
    continuationPoint?: ByteString;
    parsingResults?: ParsingResult[];
    diagnosticInfos?: DiagnosticInfo[];
    filterResult?: ContentFilterResult;
}
export class QueryFirstResponse implements QueryFirstResponseOptions {
    responseHeader: ResponseHeader;
    queryDataSets?: QueryDataSet[];
    continuationPoint?: ByteString;
    parsingResults?: ParsingResult[];
    diagnosticInfos?: DiagnosticInfo[];
    filterResult: ContentFilterResult;
    constructor(options?: QueryFirstResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.queryDataSets = options?.queryDataSets;
        this.continuationPoint = options?.continuationPoint;
        this.parsingResults = options?.parsingResults;
        this.diagnosticInfos = options?.diagnosticInfos;
        this.filterResult = options?.filterResult ?? new ContentFilterResult();
    }
    static [typeId] = NodeIds.QueryFirstResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.queryDataSets);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeTypeArray(this.parsingResults);
        encoder.writeTypeArray(this.diagnosticInfos);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): QueryFirstResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const queryDataSets = decoder.readTypeArray(QueryDataSet);
        const continuationPoint = decoder.readByteString();
        const parsingResults = decoder.readTypeArray(ParsingResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        const filterResult = decoder.readType(ContentFilterResult);
        return new QueryFirstResponse({
            responseHeader,
            queryDataSets,
            continuationPoint,
            parsingResults,
            diagnosticInfos,
            filterResult
        });
    }
}
export interface QueryNextRequestOptions {
    requestHeader?: RequestHeader;
    releaseContinuationPoint?: boolean;
    continuationPoint?: ByteString;
}
export class QueryNextRequest implements QueryNextRequestOptions {
    requestHeader: RequestHeader;
    releaseContinuationPoint: boolean;
    continuationPoint?: ByteString;
    constructor(options?: QueryNextRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.releaseContinuationPoint = options?.releaseContinuationPoint ?? false;
        this.continuationPoint = options?.continuationPoint;
    }
    static [typeId] = NodeIds.QueryNextRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.releaseContinuationPoint);
        encoder.writeByteString(this.continuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): QueryNextRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const releaseContinuationPoint = decoder.readBoolean();
        const continuationPoint = decoder.readByteString();
        return new QueryNextRequest({
            requestHeader,
            releaseContinuationPoint,
            continuationPoint
        });
    }
}
export interface QueryNextResponseOptions {
    responseHeader?: ResponseHeader;
    queryDataSets?: QueryDataSet[];
    revisedContinuationPoint?: ByteString;
}
export class QueryNextResponse implements QueryNextResponseOptions {
    responseHeader: ResponseHeader;
    queryDataSets?: QueryDataSet[];
    revisedContinuationPoint?: ByteString;
    constructor(options?: QueryNextResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.queryDataSets = options?.queryDataSets;
        this.revisedContinuationPoint = options?.revisedContinuationPoint;
    }
    static [typeId] = NodeIds.QueryNextResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.queryDataSets);
        encoder.writeByteString(this.revisedContinuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): QueryNextResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const queryDataSets = decoder.readTypeArray(QueryDataSet);
        const revisedContinuationPoint = decoder.readByteString();
        return new QueryNextResponse({
            responseHeader,
            queryDataSets,
            revisedContinuationPoint
        });
    }
}
export enum TimestampsToReturn {
    Source = 0,
    Server = 1,
    Both = 2,
    Neither = 3,
    Invalid = 4
}
export interface ReadValueIdOptions {
    nodeId?: NodeId;
    attributeId?: UInt32;
    indexRange?: UaString;
    dataEncoding?: QualifiedName;
}
export class ReadValueId implements ReadValueIdOptions {
    nodeId: NodeId;
    attributeId: UInt32;
    indexRange?: UaString;
    dataEncoding: QualifiedName;
    constructor(options?: ReadValueIdOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
        this.dataEncoding = options?.dataEncoding ?? new QualifiedName();
    }
    static [typeId] = NodeIds.ReadValueId_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.dataEncoding);
    }
    static [decode](decoder: BinaryDataDecoder): ReadValueId {
        const nodeId = decoder.readType(NodeId);
        const attributeId = decoder.readUInt32();
        const indexRange = decoder.readString();
        const dataEncoding = decoder.readType(QualifiedName);
        return new ReadValueId({
            nodeId,
            attributeId,
            indexRange,
            dataEncoding
        });
    }
}
export interface ReadRequestOptions {
    requestHeader?: RequestHeader;
    maxAge?: Double;
    timestampsToReturn?: TimestampsToReturn;
    nodesToRead?: ReadValueId[];
}
export class ReadRequest implements ReadRequestOptions {
    requestHeader: RequestHeader;
    maxAge: Double;
    timestampsToReturn: TimestampsToReturn;
    nodesToRead?: ReadValueId[];
    constructor(options?: ReadRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.maxAge = options?.maxAge ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.nodesToRead = options?.nodesToRead;
    }
    static [typeId] = NodeIds.ReadRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeDouble(this.maxAge);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.nodesToRead);
    }
    static [decode](decoder: BinaryDataDecoder): ReadRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const maxAge = decoder.readDouble();
        const timestampsToReturn = decoder.readUInt32();
        const nodesToRead = decoder.readTypeArray(ReadValueId);
        return new ReadRequest({
            requestHeader,
            maxAge,
            timestampsToReturn,
            nodesToRead
        });
    }
}
export interface ReadResponseOptions {
    responseHeader?: ResponseHeader;
    results?: DataValue[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class ReadResponse implements ReadResponseOptions {
    responseHeader: ResponseHeader;
    results?: DataValue[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ReadResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ReadResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ReadResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(DataValue);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ReadResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface HistoryReadValueIdOptions {
    nodeId?: NodeId;
    indexRange?: UaString;
    dataEncoding?: QualifiedName;
    continuationPoint?: ByteString;
}
export class HistoryReadValueId implements HistoryReadValueIdOptions {
    nodeId: NodeId;
    indexRange?: UaString;
    dataEncoding: QualifiedName;
    continuationPoint?: ByteString;
    constructor(options?: HistoryReadValueIdOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.indexRange = options?.indexRange;
        this.dataEncoding = options?.dataEncoding ?? new QualifiedName();
        this.continuationPoint = options?.continuationPoint;
    }
    static [typeId] = NodeIds.HistoryReadValueId_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.dataEncoding);
        encoder.writeByteString(this.continuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadValueId {
        const nodeId = decoder.readType(NodeId);
        const indexRange = decoder.readString();
        const dataEncoding = decoder.readType(QualifiedName);
        const continuationPoint = decoder.readByteString();
        return new HistoryReadValueId({
            nodeId,
            indexRange,
            dataEncoding,
            continuationPoint
        });
    }
}
export interface HistoryReadResultOptions {
    statusCode?: StatusCode;
    continuationPoint?: ByteString;
    historyData?: ExtensionObject;
}
export class HistoryReadResult implements HistoryReadResultOptions {
    statusCode: StatusCode;
    continuationPoint?: ByteString;
    historyData: ExtensionObject;
    constructor(options?: HistoryReadResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.continuationPoint = options?.continuationPoint;
        this.historyData = options?.historyData ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.HistoryReadResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeType(this.historyData);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadResult {
        const statusCode = decoder.readType(StatusCode);
        const continuationPoint = decoder.readByteString();
        const historyData = decoder.readType(ExtensionObject);
        return new HistoryReadResult({
            statusCode,
            continuationPoint,
            historyData
        });
    }
}
export class HistoryReadDetails {
    static [typeId] = NodeIds.HistoryReadDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadDetails {
        return new HistoryReadDetails();
    }
}
export interface ReadEventDetailsOptions {
    numValuesPerNode?: UInt32;
    startTime?: Date;
    endTime?: Date;
    filter?: EventFilter;
}
export class ReadEventDetails implements ReadEventDetailsOptions {
    numValuesPerNode: UInt32;
    startTime: Date;
    endTime: Date;
    filter: EventFilter;
    constructor(options?: ReadEventDetailsOptions) {
        this.numValuesPerNode = options?.numValuesPerNode ?? 0;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.filter = options?.filter ?? new EventFilter();
    }
    static [typeId] = NodeIds.ReadEventDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.numValuesPerNode);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeType(this.filter);
    }
    static [decode](decoder: BinaryDataDecoder): ReadEventDetails {
        const numValuesPerNode = decoder.readUInt32();
        const startTime = decoder.readDateTime();
        const endTime = decoder.readDateTime();
        const filter = decoder.readType(EventFilter);
        return new ReadEventDetails({
            numValuesPerNode,
            startTime,
            endTime,
            filter
        });
    }
}
export interface ReadRawModifiedDetailsOptions {
    isReadModified?: boolean;
    startTime?: Date;
    endTime?: Date;
    numValuesPerNode?: UInt32;
    returnBounds?: boolean;
}
export class ReadRawModifiedDetails implements ReadRawModifiedDetailsOptions {
    isReadModified: boolean;
    startTime: Date;
    endTime: Date;
    numValuesPerNode: UInt32;
    returnBounds: boolean;
    constructor(options?: ReadRawModifiedDetailsOptions) {
        this.isReadModified = options?.isReadModified ?? false;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.numValuesPerNode = options?.numValuesPerNode ?? 0;
        this.returnBounds = options?.returnBounds ?? false;
    }
    static [typeId] = NodeIds.ReadRawModifiedDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeBoolean(this.isReadModified);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeUInt32(this.numValuesPerNode);
        encoder.writeBoolean(this.returnBounds);
    }
    static [decode](decoder: BinaryDataDecoder): ReadRawModifiedDetails {
        const isReadModified = decoder.readBoolean();
        const startTime = decoder.readDateTime();
        const endTime = decoder.readDateTime();
        const numValuesPerNode = decoder.readUInt32();
        const returnBounds = decoder.readBoolean();
        return new ReadRawModifiedDetails({
            isReadModified,
            startTime,
            endTime,
            numValuesPerNode,
            returnBounds
        });
    }
}
export interface ReadProcessedDetailsOptions {
    startTime?: Date;
    endTime?: Date;
    processingInterval?: Double;
    aggregateType?: NodeId[];
    aggregateConfiguration?: AggregateConfiguration;
}
export class ReadProcessedDetails implements ReadProcessedDetailsOptions {
    startTime: Date;
    endTime: Date;
    processingInterval: Double;
    aggregateType?: NodeId[];
    aggregateConfiguration: AggregateConfiguration;
    constructor(options?: ReadProcessedDetailsOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.processingInterval = options?.processingInterval ?? 0;
        this.aggregateType = options?.aggregateType;
        this.aggregateConfiguration = options?.aggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.ReadProcessedDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeDouble(this.processingInterval);
        encoder.writeTypeArray(this.aggregateType);
        encoder.writeType(this.aggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): ReadProcessedDetails {
        const startTime = decoder.readDateTime();
        const endTime = decoder.readDateTime();
        const processingInterval = decoder.readDouble();
        const aggregateType = decoder.readTypeArray(NodeId);
        const aggregateConfiguration = decoder.readType(AggregateConfiguration);
        return new ReadProcessedDetails({
            startTime,
            endTime,
            processingInterval,
            aggregateType,
            aggregateConfiguration
        });
    }
}
export interface ReadAtTimeDetailsOptions {
    reqTimes?: Date[];
    useSimpleBounds?: boolean;
}
export class ReadAtTimeDetails implements ReadAtTimeDetailsOptions {
    reqTimes?: Date[];
    useSimpleBounds: boolean;
    constructor(options?: ReadAtTimeDetailsOptions) {
        this.reqTimes = options?.reqTimes;
        this.useSimpleBounds = options?.useSimpleBounds ?? false;
    }
    static [typeId] = NodeIds.ReadAtTimeDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTimeArray(this.reqTimes);
        encoder.writeBoolean(this.useSimpleBounds);
    }
    static [decode](decoder: BinaryDataDecoder): ReadAtTimeDetails {
        const reqTimes = decoder.readDateTimeArray();
        const useSimpleBounds = decoder.readBoolean();
        return new ReadAtTimeDetails({
            reqTimes,
            useSimpleBounds
        });
    }
}
export interface ReadAnnotationDataDetailsOptions {
    reqTimes?: Date[];
}
export class ReadAnnotationDataDetails implements ReadAnnotationDataDetailsOptions {
    reqTimes?: Date[];
    constructor(options?: ReadAnnotationDataDetailsOptions) {
        this.reqTimes = options?.reqTimes;
    }
    static [typeId] = NodeIds.ReadAnnotationDataDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTimeArray(this.reqTimes);
    }
    static [decode](decoder: BinaryDataDecoder): ReadAnnotationDataDetails {
        const reqTimes = decoder.readDateTimeArray();
        return new ReadAnnotationDataDetails({
            reqTimes
        });
    }
}
export interface HistoryDataOptions {
    dataValues?: DataValue[];
}
export class HistoryData implements HistoryDataOptions {
    dataValues?: DataValue[];
    constructor(options?: HistoryDataOptions) {
        this.dataValues = options?.dataValues;
    }
    static [typeId] = NodeIds.HistoryData_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.dataValues);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryData {
        const dataValues = decoder.readTypeArray(DataValue);
        return new HistoryData({
            dataValues
        });
    }
}
export interface ModificationInfoOptions {
    modificationTime?: Date;
    updateType?: HistoryUpdateType;
    userName?: UaString;
}
export class ModificationInfo implements ModificationInfoOptions {
    modificationTime: Date;
    updateType: HistoryUpdateType;
    userName?: UaString;
    constructor(options?: ModificationInfoOptions) {
        this.modificationTime = options?.modificationTime ?? new Date(-11644473600000);
        this.updateType = options?.updateType ?? HistoryUpdateType.Insert;
        this.userName = options?.userName;
    }
    static [typeId] = NodeIds.ModificationInfo_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.modificationTime);
        encoder.writeUInt32(this.updateType);
        encoder.writeString(this.userName);
    }
    static [decode](decoder: BinaryDataDecoder): ModificationInfo {
        const modificationTime = decoder.readDateTime();
        const updateType = decoder.readUInt32();
        const userName = decoder.readString();
        return new ModificationInfo({
            modificationTime,
            updateType,
            userName
        });
    }
}
export interface HistoryModifiedDataOptions {
    dataValues?: DataValue[];
    modificationInfos?: ModificationInfo[];
}
export class HistoryModifiedData implements HistoryModifiedDataOptions {
    dataValues?: DataValue[];
    modificationInfos?: ModificationInfo[];
    constructor(options?: HistoryModifiedDataOptions) {
        this.dataValues = options?.dataValues;
        this.modificationInfos = options?.modificationInfos;
    }
    static [typeId] = NodeIds.HistoryModifiedData_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.dataValues);
        encoder.writeTypeArray(this.modificationInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryModifiedData {
        const dataValues = decoder.readTypeArray(DataValue);
        const modificationInfos = decoder.readTypeArray(ModificationInfo);
        return new HistoryModifiedData({
            dataValues,
            modificationInfos
        });
    }
}
export interface HistoryEventOptions {
    events?: HistoryEventFieldList[];
}
export class HistoryEvent implements HistoryEventOptions {
    events?: HistoryEventFieldList[];
    constructor(options?: HistoryEventOptions) {
        this.events = options?.events;
    }
    static [typeId] = NodeIds.HistoryEvent_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.events);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryEvent {
        const events = decoder.readTypeArray(HistoryEventFieldList);
        return new HistoryEvent({
            events
        });
    }
}
export interface HistoryReadRequestOptions {
    requestHeader?: RequestHeader;
    historyReadDetails?: ExtensionObject;
    timestampsToReturn?: TimestampsToReturn;
    releaseContinuationPoints?: boolean;
    nodesToRead?: HistoryReadValueId[];
}
export class HistoryReadRequest implements HistoryReadRequestOptions {
    requestHeader: RequestHeader;
    historyReadDetails: ExtensionObject;
    timestampsToReturn: TimestampsToReturn;
    releaseContinuationPoints: boolean;
    nodesToRead?: HistoryReadValueId[];
    constructor(options?: HistoryReadRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.historyReadDetails = options?.historyReadDetails ?? new ExtensionObject();
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.releaseContinuationPoints = options?.releaseContinuationPoints ?? false;
        this.nodesToRead = options?.nodesToRead;
    }
    static [typeId] = NodeIds.HistoryReadRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.historyReadDetails);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeBoolean(this.releaseContinuationPoints);
        encoder.writeTypeArray(this.nodesToRead);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const historyReadDetails = decoder.readType(ExtensionObject);
        const timestampsToReturn = decoder.readUInt32();
        const releaseContinuationPoints = decoder.readBoolean();
        const nodesToRead = decoder.readTypeArray(HistoryReadValueId);
        return new HistoryReadRequest({
            requestHeader,
            historyReadDetails,
            timestampsToReturn,
            releaseContinuationPoints,
            nodesToRead
        });
    }
}
export interface HistoryReadResponseOptions {
    responseHeader?: ResponseHeader;
    results?: HistoryReadResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class HistoryReadResponse implements HistoryReadResponseOptions {
    responseHeader: ResponseHeader;
    results?: HistoryReadResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryReadResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryReadResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(HistoryReadResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new HistoryReadResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface WriteValueOptions {
    nodeId?: NodeId;
    attributeId?: UInt32;
    indexRange?: UaString;
    value?: DataValue;
}
export class WriteValue implements WriteValueOptions {
    nodeId: NodeId;
    attributeId: UInt32;
    indexRange?: UaString;
    value: DataValue;
    constructor(options?: WriteValueOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
        this.value = options?.value ?? new DataValue();
    }
    static [typeId] = NodeIds.WriteValue_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): WriteValue {
        const nodeId = decoder.readType(NodeId);
        const attributeId = decoder.readUInt32();
        const indexRange = decoder.readString();
        const value = decoder.readType(DataValue);
        return new WriteValue({
            nodeId,
            attributeId,
            indexRange,
            value
        });
    }
}
export interface WriteRequestOptions {
    requestHeader?: RequestHeader;
    nodesToWrite?: WriteValue[];
}
export class WriteRequest implements WriteRequestOptions {
    requestHeader: RequestHeader;
    nodesToWrite?: WriteValue[];
    constructor(options?: WriteRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToWrite = options?.nodesToWrite;
    }
    static [typeId] = NodeIds.WriteRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToWrite);
    }
    static [decode](decoder: BinaryDataDecoder): WriteRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const nodesToWrite = decoder.readTypeArray(WriteValue);
        return new WriteRequest({
            requestHeader,
            nodesToWrite
        });
    }
}
export interface WriteResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class WriteResponse implements WriteResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: WriteResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.WriteResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): WriteResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new WriteResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface HistoryUpdateDetailsOptions {
    nodeId?: NodeId;
}
export class HistoryUpdateDetails implements HistoryUpdateDetailsOptions {
    nodeId: NodeId;
    constructor(options?: HistoryUpdateDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
    }
    static [typeId] = NodeIds.HistoryUpdateDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateDetails {
        const nodeId = decoder.readType(NodeId);
        return new HistoryUpdateDetails({
            nodeId
        });
    }
}
export enum HistoryUpdateType {
    Insert = 1,
    Replace = 2,
    Update = 3,
    Delete = 4
}
export enum PerformUpdateType {
    Insert = 1,
    Replace = 2,
    Update = 3,
    Remove = 4
}
export interface UpdateDataDetailsOptions {
    nodeId?: NodeId;
    performInsertReplace?: PerformUpdateType;
    updateValues?: DataValue[];
}
export class UpdateDataDetails implements UpdateDataDetailsOptions {
    nodeId: NodeId;
    performInsertReplace: PerformUpdateType;
    updateValues?: DataValue[];
    constructor(options?: UpdateDataDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.updateValues = options?.updateValues;
    }
    static [typeId] = NodeIds.UpdateDataDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeTypeArray(this.updateValues);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateDataDetails {
        const nodeId = decoder.readType(NodeId);
        const performInsertReplace = decoder.readUInt32();
        const updateValues = decoder.readTypeArray(DataValue);
        return new UpdateDataDetails({
            nodeId,
            performInsertReplace,
            updateValues
        });
    }
}
export interface UpdateStructureDataDetailsOptions {
    nodeId?: NodeId;
    performInsertReplace?: PerformUpdateType;
    updateValues?: DataValue[];
}
export class UpdateStructureDataDetails implements UpdateStructureDataDetailsOptions {
    nodeId: NodeId;
    performInsertReplace: PerformUpdateType;
    updateValues?: DataValue[];
    constructor(options?: UpdateStructureDataDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.updateValues = options?.updateValues;
    }
    static [typeId] = NodeIds.UpdateStructureDataDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeTypeArray(this.updateValues);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateStructureDataDetails {
        const nodeId = decoder.readType(NodeId);
        const performInsertReplace = decoder.readUInt32();
        const updateValues = decoder.readTypeArray(DataValue);
        return new UpdateStructureDataDetails({
            nodeId,
            performInsertReplace,
            updateValues
        });
    }
}
export interface UpdateEventDetailsOptions {
    nodeId?: NodeId;
    performInsertReplace?: PerformUpdateType;
    filter?: EventFilter;
    eventData?: HistoryEventFieldList[];
}
export class UpdateEventDetails implements UpdateEventDetailsOptions {
    nodeId: NodeId;
    performInsertReplace: PerformUpdateType;
    filter: EventFilter;
    eventData?: HistoryEventFieldList[];
    constructor(options?: UpdateEventDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.filter = options?.filter ?? new EventFilter();
        this.eventData = options?.eventData;
    }
    static [typeId] = NodeIds.UpdateEventDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeType(this.filter);
        encoder.writeTypeArray(this.eventData);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateEventDetails {
        const nodeId = decoder.readType(NodeId);
        const performInsertReplace = decoder.readUInt32();
        const filter = decoder.readType(EventFilter);
        const eventData = decoder.readTypeArray(HistoryEventFieldList);
        return new UpdateEventDetails({
            nodeId,
            performInsertReplace,
            filter,
            eventData
        });
    }
}
export interface DeleteRawModifiedDetailsOptions {
    nodeId?: NodeId;
    isDeleteModified?: boolean;
    startTime?: Date;
    endTime?: Date;
}
export class DeleteRawModifiedDetails implements DeleteRawModifiedDetailsOptions {
    nodeId: NodeId;
    isDeleteModified: boolean;
    startTime: Date;
    endTime: Date;
    constructor(options?: DeleteRawModifiedDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.isDeleteModified = options?.isDeleteModified ?? false;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.DeleteRawModifiedDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeBoolean(this.isDeleteModified);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteRawModifiedDetails {
        const nodeId = decoder.readType(NodeId);
        const isDeleteModified = decoder.readBoolean();
        const startTime = decoder.readDateTime();
        const endTime = decoder.readDateTime();
        return new DeleteRawModifiedDetails({
            nodeId,
            isDeleteModified,
            startTime,
            endTime
        });
    }
}
export interface DeleteAtTimeDetailsOptions {
    nodeId?: NodeId;
    reqTimes?: Date[];
}
export class DeleteAtTimeDetails implements DeleteAtTimeDetailsOptions {
    nodeId: NodeId;
    reqTimes?: Date[];
    constructor(options?: DeleteAtTimeDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.reqTimes = options?.reqTimes;
    }
    static [typeId] = NodeIds.DeleteAtTimeDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeDateTimeArray(this.reqTimes);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteAtTimeDetails {
        const nodeId = decoder.readType(NodeId);
        const reqTimes = decoder.readDateTimeArray();
        return new DeleteAtTimeDetails({
            nodeId,
            reqTimes
        });
    }
}
export interface DeleteEventDetailsOptions {
    nodeId?: NodeId;
    eventIds?: ByteString[];
}
export class DeleteEventDetails implements DeleteEventDetailsOptions {
    nodeId: NodeId;
    eventIds?: ByteString[];
    constructor(options?: DeleteEventDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.eventIds = options?.eventIds;
    }
    static [typeId] = NodeIds.DeleteEventDetails_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeByteStringArray(this.eventIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteEventDetails {
        const nodeId = decoder.readType(NodeId);
        const eventIds = decoder.readByteStringArray();
        return new DeleteEventDetails({
            nodeId,
            eventIds
        });
    }
}
export interface HistoryUpdateResultOptions {
    statusCode?: StatusCode;
    operationResults?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class HistoryUpdateResult implements HistoryUpdateResultOptions {
    statusCode: StatusCode;
    operationResults?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryUpdateResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.operationResults = options?.operationResults;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryUpdateResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.operationResults);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateResult {
        const statusCode = decoder.readType(StatusCode);
        const operationResults = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new HistoryUpdateResult({
            statusCode,
            operationResults,
            diagnosticInfos
        });
    }
}
export interface HistoryUpdateRequestOptions {
    requestHeader?: RequestHeader;
    historyUpdateDetails?: ExtensionObject[];
}
export class HistoryUpdateRequest implements HistoryUpdateRequestOptions {
    requestHeader: RequestHeader;
    historyUpdateDetails?: ExtensionObject[];
    constructor(options?: HistoryUpdateRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.historyUpdateDetails = options?.historyUpdateDetails;
    }
    static [typeId] = NodeIds.HistoryUpdateRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.historyUpdateDetails);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const historyUpdateDetails = decoder.readTypeArray(ExtensionObject);
        return new HistoryUpdateRequest({
            requestHeader,
            historyUpdateDetails
        });
    }
}
export interface HistoryUpdateResponseOptions {
    responseHeader?: ResponseHeader;
    results?: HistoryUpdateResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class HistoryUpdateResponse implements HistoryUpdateResponseOptions {
    responseHeader: ResponseHeader;
    results?: HistoryUpdateResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryUpdateResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryUpdateResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(HistoryUpdateResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new HistoryUpdateResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface CallMethodRequestOptions {
    objectId?: NodeId;
    methodId?: NodeId;
    inputArguments?: Variant[];
}
export class CallMethodRequest implements CallMethodRequestOptions {
    objectId: NodeId;
    methodId: NodeId;
    inputArguments?: Variant[];
    constructor(options?: CallMethodRequestOptions) {
        this.objectId = options?.objectId ?? NodeId.null();
        this.methodId = options?.methodId ?? NodeId.null();
        this.inputArguments = options?.inputArguments;
    }
    static [typeId] = NodeIds.CallMethodRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.objectId);
        encoder.writeType(this.methodId);
        encoder.writeTypeArray(this.inputArguments);
    }
    static [decode](decoder: BinaryDataDecoder): CallMethodRequest {
        const objectId = decoder.readType(NodeId);
        const methodId = decoder.readType(NodeId);
        const inputArguments = decoder.readTypeArray(Variant);
        return new CallMethodRequest({
            objectId,
            methodId,
            inputArguments
        });
    }
}
export interface CallMethodResultOptions {
    statusCode?: StatusCode;
    inputArgumentResults?: StatusCode[];
    inputArgumentDiagnosticInfos?: DiagnosticInfo[];
    outputArguments?: Variant[];
}
export class CallMethodResult implements CallMethodResultOptions {
    statusCode: StatusCode;
    inputArgumentResults?: StatusCode[];
    inputArgumentDiagnosticInfos?: DiagnosticInfo[];
    outputArguments?: Variant[];
    constructor(options?: CallMethodResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.inputArgumentResults = options?.inputArgumentResults;
        this.inputArgumentDiagnosticInfos = options?.inputArgumentDiagnosticInfos;
        this.outputArguments = options?.outputArguments;
    }
    static [typeId] = NodeIds.CallMethodResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.inputArgumentResults);
        encoder.writeTypeArray(this.inputArgumentDiagnosticInfos);
        encoder.writeTypeArray(this.outputArguments);
    }
    static [decode](decoder: BinaryDataDecoder): CallMethodResult {
        const statusCode = decoder.readType(StatusCode);
        const inputArgumentResults = decoder.readTypeArray(StatusCode);
        const inputArgumentDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        const outputArguments = decoder.readTypeArray(Variant);
        return new CallMethodResult({
            statusCode,
            inputArgumentResults,
            inputArgumentDiagnosticInfos,
            outputArguments
        });
    }
}
export interface CallRequestOptions {
    requestHeader?: RequestHeader;
    methodsToCall?: CallMethodRequest[];
}
export class CallRequest implements CallRequestOptions {
    requestHeader: RequestHeader;
    methodsToCall?: CallMethodRequest[];
    constructor(options?: CallRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.methodsToCall = options?.methodsToCall;
    }
    static [typeId] = NodeIds.CallRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.methodsToCall);
    }
    static [decode](decoder: BinaryDataDecoder): CallRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const methodsToCall = decoder.readTypeArray(CallMethodRequest);
        return new CallRequest({
            requestHeader,
            methodsToCall
        });
    }
}
export interface CallResponseOptions {
    responseHeader?: ResponseHeader;
    results?: CallMethodResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class CallResponse implements CallResponseOptions {
    responseHeader: ResponseHeader;
    results?: CallMethodResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: CallResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.CallResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): CallResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(CallMethodResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new CallResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export enum MonitoringMode {
    Disabled = 0,
    Sampling = 1,
    Reporting = 2
}
export enum DataChangeTrigger {
    Status = 0,
    StatusValue = 1,
    StatusValueTimestamp = 2
}
export enum DeadbandType {
    None = 0,
    Absolute = 1,
    Percent = 2
}
export class MonitoringFilter {
    static [typeId] = NodeIds.MonitoringFilter_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringFilter {
        return new MonitoringFilter();
    }
}
export interface DataChangeFilterOptions {
    trigger?: DataChangeTrigger;
    deadbandType?: UInt32;
    deadbandValue?: Double;
}
export class DataChangeFilter implements DataChangeFilterOptions {
    trigger: DataChangeTrigger;
    deadbandType: UInt32;
    deadbandValue: Double;
    constructor(options?: DataChangeFilterOptions) {
        this.trigger = options?.trigger ?? DataChangeTrigger.Status;
        this.deadbandType = options?.deadbandType ?? 0;
        this.deadbandValue = options?.deadbandValue ?? 0;
    }
    static [typeId] = NodeIds.DataChangeFilter_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.trigger);
        encoder.writeUInt32(this.deadbandType);
        encoder.writeDouble(this.deadbandValue);
    }
    static [decode](decoder: BinaryDataDecoder): DataChangeFilter {
        const trigger = decoder.readUInt32();
        const deadbandType = decoder.readUInt32();
        const deadbandValue = decoder.readDouble();
        return new DataChangeFilter({
            trigger,
            deadbandType,
            deadbandValue
        });
    }
}
export interface EventFilterOptions {
    selectClauses?: SimpleAttributeOperand[];
    whereClause?: ContentFilter;
}
export class EventFilter implements EventFilterOptions {
    selectClauses?: SimpleAttributeOperand[];
    whereClause: ContentFilter;
    constructor(options?: EventFilterOptions) {
        this.selectClauses = options?.selectClauses;
        this.whereClause = options?.whereClause ?? new ContentFilter();
    }
    static [typeId] = NodeIds.EventFilter_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.selectClauses);
        encoder.writeType(this.whereClause);
    }
    static [decode](decoder: BinaryDataDecoder): EventFilter {
        const selectClauses = decoder.readTypeArray(SimpleAttributeOperand);
        const whereClause = decoder.readType(ContentFilter);
        return new EventFilter({
            selectClauses,
            whereClause
        });
    }
}
export interface AggregateConfigurationOptions {
    useServerCapabilitiesDefaults?: boolean;
    treatUncertainAsBad?: boolean;
    percentDataBad?: Byte;
    percentDataGood?: Byte;
    useSlopedExtrapolation?: boolean;
}
export class AggregateConfiguration implements AggregateConfigurationOptions {
    useServerCapabilitiesDefaults: boolean;
    treatUncertainAsBad: boolean;
    percentDataBad: Byte;
    percentDataGood: Byte;
    useSlopedExtrapolation: boolean;
    constructor(options?: AggregateConfigurationOptions) {
        this.useServerCapabilitiesDefaults = options?.useServerCapabilitiesDefaults ?? false;
        this.treatUncertainAsBad = options?.treatUncertainAsBad ?? false;
        this.percentDataBad = options?.percentDataBad ?? 0;
        this.percentDataGood = options?.percentDataGood ?? 0;
        this.useSlopedExtrapolation = options?.useSlopedExtrapolation ?? false;
    }
    static [typeId] = NodeIds.AggregateConfiguration_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeBoolean(this.useServerCapabilitiesDefaults);
        encoder.writeBoolean(this.treatUncertainAsBad);
        encoder.writeByte(this.percentDataBad);
        encoder.writeByte(this.percentDataGood);
        encoder.writeBoolean(this.useSlopedExtrapolation);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateConfiguration {
        const useServerCapabilitiesDefaults = decoder.readBoolean();
        const treatUncertainAsBad = decoder.readBoolean();
        const percentDataBad = decoder.readByte();
        const percentDataGood = decoder.readByte();
        const useSlopedExtrapolation = decoder.readBoolean();
        return new AggregateConfiguration({
            useServerCapabilitiesDefaults,
            treatUncertainAsBad,
            percentDataBad,
            percentDataGood,
            useSlopedExtrapolation
        });
    }
}
export interface AggregateFilterOptions {
    startTime?: Date;
    aggregateType?: NodeId;
    processingInterval?: Double;
    aggregateConfiguration?: AggregateConfiguration;
}
export class AggregateFilter implements AggregateFilterOptions {
    startTime: Date;
    aggregateType: NodeId;
    processingInterval: Double;
    aggregateConfiguration: AggregateConfiguration;
    constructor(options?: AggregateFilterOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.aggregateType = options?.aggregateType ?? NodeId.null();
        this.processingInterval = options?.processingInterval ?? 0;
        this.aggregateConfiguration = options?.aggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.AggregateFilter_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeType(this.aggregateType);
        encoder.writeDouble(this.processingInterval);
        encoder.writeType(this.aggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateFilter {
        const startTime = decoder.readDateTime();
        const aggregateType = decoder.readType(NodeId);
        const processingInterval = decoder.readDouble();
        const aggregateConfiguration = decoder.readType(AggregateConfiguration);
        return new AggregateFilter({
            startTime,
            aggregateType,
            processingInterval,
            aggregateConfiguration
        });
    }
}
export class MonitoringFilterResult {
    static [typeId] = NodeIds.MonitoringFilterResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringFilterResult {
        return new MonitoringFilterResult();
    }
}
export interface EventFilterResultOptions {
    selectClauseResults?: StatusCode[];
    selectClauseDiagnosticInfos?: DiagnosticInfo[];
    whereClauseResult?: ContentFilterResult;
}
export class EventFilterResult implements EventFilterResultOptions {
    selectClauseResults?: StatusCode[];
    selectClauseDiagnosticInfos?: DiagnosticInfo[];
    whereClauseResult: ContentFilterResult;
    constructor(options?: EventFilterResultOptions) {
        this.selectClauseResults = options?.selectClauseResults;
        this.selectClauseDiagnosticInfos = options?.selectClauseDiagnosticInfos;
        this.whereClauseResult = options?.whereClauseResult ?? new ContentFilterResult();
    }
    static [typeId] = NodeIds.EventFilterResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.selectClauseResults);
        encoder.writeTypeArray(this.selectClauseDiagnosticInfos);
        encoder.writeType(this.whereClauseResult);
    }
    static [decode](decoder: BinaryDataDecoder): EventFilterResult {
        const selectClauseResults = decoder.readTypeArray(StatusCode);
        const selectClauseDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        const whereClauseResult = decoder.readType(ContentFilterResult);
        return new EventFilterResult({
            selectClauseResults,
            selectClauseDiagnosticInfos,
            whereClauseResult
        });
    }
}
export interface AggregateFilterResultOptions {
    revisedStartTime?: Date;
    revisedProcessingInterval?: Double;
    revisedAggregateConfiguration?: AggregateConfiguration;
}
export class AggregateFilterResult implements AggregateFilterResultOptions {
    revisedStartTime: Date;
    revisedProcessingInterval: Double;
    revisedAggregateConfiguration: AggregateConfiguration;
    constructor(options?: AggregateFilterResultOptions) {
        this.revisedStartTime = options?.revisedStartTime ?? new Date(-11644473600000);
        this.revisedProcessingInterval = options?.revisedProcessingInterval ?? 0;
        this.revisedAggregateConfiguration = options?.revisedAggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.AggregateFilterResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.revisedStartTime);
        encoder.writeDouble(this.revisedProcessingInterval);
        encoder.writeType(this.revisedAggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateFilterResult {
        const revisedStartTime = decoder.readDateTime();
        const revisedProcessingInterval = decoder.readDouble();
        const revisedAggregateConfiguration = decoder.readType(AggregateConfiguration);
        return new AggregateFilterResult({
            revisedStartTime,
            revisedProcessingInterval,
            revisedAggregateConfiguration
        });
    }
}
export interface MonitoringParametersOptions {
    clientHandle?: UInt32;
    samplingInterval?: Double;
    filter?: ExtensionObject;
    queueSize?: UInt32;
    discardOldest?: boolean;
}
export class MonitoringParameters implements MonitoringParametersOptions {
    clientHandle: UInt32;
    samplingInterval: Double;
    filter: ExtensionObject;
    queueSize: UInt32;
    discardOldest: boolean;
    constructor(options?: MonitoringParametersOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.samplingInterval = options?.samplingInterval ?? 0;
        this.filter = options?.filter ?? new ExtensionObject();
        this.queueSize = options?.queueSize ?? 0;
        this.discardOldest = options?.discardOldest ?? false;
    }
    static [typeId] = NodeIds.MonitoringParameters_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeDouble(this.samplingInterval);
        encoder.writeType(this.filter);
        encoder.writeUInt32(this.queueSize);
        encoder.writeBoolean(this.discardOldest);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringParameters {
        const clientHandle = decoder.readUInt32();
        const samplingInterval = decoder.readDouble();
        const filter = decoder.readType(ExtensionObject);
        const queueSize = decoder.readUInt32();
        const discardOldest = decoder.readBoolean();
        return new MonitoringParameters({
            clientHandle,
            samplingInterval,
            filter,
            queueSize,
            discardOldest
        });
    }
}
export interface MonitoredItemCreateRequestOptions {
    itemToMonitor?: ReadValueId;
    monitoringMode?: MonitoringMode;
    requestedParameters?: MonitoringParameters;
}
export class MonitoredItemCreateRequest implements MonitoredItemCreateRequestOptions {
    itemToMonitor: ReadValueId;
    monitoringMode: MonitoringMode;
    requestedParameters: MonitoringParameters;
    constructor(options?: MonitoredItemCreateRequestOptions) {
        this.itemToMonitor = options?.itemToMonitor ?? new ReadValueId();
        this.monitoringMode = options?.monitoringMode ?? MonitoringMode.Disabled;
        this.requestedParameters = options?.requestedParameters ?? new MonitoringParameters();
    }
    static [typeId] = NodeIds.MonitoredItemCreateRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.itemToMonitor);
        encoder.writeUInt32(this.monitoringMode);
        encoder.writeType(this.requestedParameters);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemCreateRequest {
        const itemToMonitor = decoder.readType(ReadValueId);
        const monitoringMode = decoder.readUInt32();
        const requestedParameters = decoder.readType(MonitoringParameters);
        return new MonitoredItemCreateRequest({
            itemToMonitor,
            monitoringMode,
            requestedParameters
        });
    }
}
export interface MonitoredItemCreateResultOptions {
    statusCode?: StatusCode;
    monitoredItemId?: UInt32;
    revisedSamplingInterval?: Double;
    revisedQueueSize?: UInt32;
    filterResult?: ExtensionObject;
}
export class MonitoredItemCreateResult implements MonitoredItemCreateResultOptions {
    statusCode: StatusCode;
    monitoredItemId: UInt32;
    revisedSamplingInterval: Double;
    revisedQueueSize: UInt32;
    filterResult: ExtensionObject;
    constructor(options?: MonitoredItemCreateResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.monitoredItemId = options?.monitoredItemId ?? 0;
        this.revisedSamplingInterval = options?.revisedSamplingInterval ?? 0;
        this.revisedQueueSize = options?.revisedQueueSize ?? 0;
        this.filterResult = options?.filterResult ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.MonitoredItemCreateResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeUInt32(this.monitoredItemId);
        encoder.writeDouble(this.revisedSamplingInterval);
        encoder.writeUInt32(this.revisedQueueSize);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemCreateResult {
        const statusCode = decoder.readType(StatusCode);
        const monitoredItemId = decoder.readUInt32();
        const revisedSamplingInterval = decoder.readDouble();
        const revisedQueueSize = decoder.readUInt32();
        const filterResult = decoder.readType(ExtensionObject);
        return new MonitoredItemCreateResult({
            statusCode,
            monitoredItemId,
            revisedSamplingInterval,
            revisedQueueSize,
            filterResult
        });
    }
}
export interface CreateMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    timestampsToReturn?: TimestampsToReturn;
    itemsToCreate?: MonitoredItemCreateRequest[];
}
export class CreateMonitoredItemsRequest implements CreateMonitoredItemsRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    timestampsToReturn: TimestampsToReturn;
    itemsToCreate?: MonitoredItemCreateRequest[];
    constructor(options?: CreateMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.itemsToCreate = options?.itemsToCreate;
    }
    static [typeId] = NodeIds.CreateMonitoredItemsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.itemsToCreate);
    }
    static [decode](decoder: BinaryDataDecoder): CreateMonitoredItemsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const timestampsToReturn = decoder.readUInt32();
        const itemsToCreate = decoder.readTypeArray(MonitoredItemCreateRequest);
        return new CreateMonitoredItemsRequest({
            requestHeader,
            subscriptionId,
            timestampsToReturn,
            itemsToCreate
        });
    }
}
export interface CreateMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: MonitoredItemCreateResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class CreateMonitoredItemsResponse implements CreateMonitoredItemsResponseOptions {
    responseHeader: ResponseHeader;
    results?: MonitoredItemCreateResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: CreateMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.CreateMonitoredItemsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): CreateMonitoredItemsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(MonitoredItemCreateResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new CreateMonitoredItemsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface MonitoredItemModifyRequestOptions {
    monitoredItemId?: UInt32;
    requestedParameters?: MonitoringParameters;
}
export class MonitoredItemModifyRequest implements MonitoredItemModifyRequestOptions {
    monitoredItemId: UInt32;
    requestedParameters: MonitoringParameters;
    constructor(options?: MonitoredItemModifyRequestOptions) {
        this.monitoredItemId = options?.monitoredItemId ?? 0;
        this.requestedParameters = options?.requestedParameters ?? new MonitoringParameters();
    }
    static [typeId] = NodeIds.MonitoredItemModifyRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.monitoredItemId);
        encoder.writeType(this.requestedParameters);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemModifyRequest {
        const monitoredItemId = decoder.readUInt32();
        const requestedParameters = decoder.readType(MonitoringParameters);
        return new MonitoredItemModifyRequest({
            monitoredItemId,
            requestedParameters
        });
    }
}
export interface MonitoredItemModifyResultOptions {
    statusCode?: StatusCode;
    revisedSamplingInterval?: Double;
    revisedQueueSize?: UInt32;
    filterResult?: ExtensionObject;
}
export class MonitoredItemModifyResult implements MonitoredItemModifyResultOptions {
    statusCode: StatusCode;
    revisedSamplingInterval: Double;
    revisedQueueSize: UInt32;
    filterResult: ExtensionObject;
    constructor(options?: MonitoredItemModifyResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.revisedSamplingInterval = options?.revisedSamplingInterval ?? 0;
        this.revisedQueueSize = options?.revisedQueueSize ?? 0;
        this.filterResult = options?.filterResult ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.MonitoredItemModifyResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeDouble(this.revisedSamplingInterval);
        encoder.writeUInt32(this.revisedQueueSize);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemModifyResult {
        const statusCode = decoder.readType(StatusCode);
        const revisedSamplingInterval = decoder.readDouble();
        const revisedQueueSize = decoder.readUInt32();
        const filterResult = decoder.readType(ExtensionObject);
        return new MonitoredItemModifyResult({
            statusCode,
            revisedSamplingInterval,
            revisedQueueSize,
            filterResult
        });
    }
}
export interface ModifyMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    timestampsToReturn?: TimestampsToReturn;
    itemsToModify?: MonitoredItemModifyRequest[];
}
export class ModifyMonitoredItemsRequest implements ModifyMonitoredItemsRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    timestampsToReturn: TimestampsToReturn;
    itemsToModify?: MonitoredItemModifyRequest[];
    constructor(options?: ModifyMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.itemsToModify = options?.itemsToModify;
    }
    static [typeId] = NodeIds.ModifyMonitoredItemsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.itemsToModify);
    }
    static [decode](decoder: BinaryDataDecoder): ModifyMonitoredItemsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const timestampsToReturn = decoder.readUInt32();
        const itemsToModify = decoder.readTypeArray(MonitoredItemModifyRequest);
        return new ModifyMonitoredItemsRequest({
            requestHeader,
            subscriptionId,
            timestampsToReturn,
            itemsToModify
        });
    }
}
export interface ModifyMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: MonitoredItemModifyResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class ModifyMonitoredItemsResponse implements ModifyMonitoredItemsResponseOptions {
    responseHeader: ResponseHeader;
    results?: MonitoredItemModifyResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ModifyMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ModifyMonitoredItemsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ModifyMonitoredItemsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(MonitoredItemModifyResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new ModifyMonitoredItemsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface SetMonitoringModeRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    monitoringMode?: MonitoringMode;
    monitoredItemIds?: UInt32[];
}
export class SetMonitoringModeRequest implements SetMonitoringModeRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    monitoringMode: MonitoringMode;
    monitoredItemIds?: UInt32[];
    constructor(options?: SetMonitoringModeRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.monitoringMode = options?.monitoringMode ?? MonitoringMode.Disabled;
        this.monitoredItemIds = options?.monitoredItemIds;
    }
    static [typeId] = NodeIds.SetMonitoringModeRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.monitoringMode);
        encoder.writeUInt32Array(this.monitoredItemIds);
    }
    static [decode](decoder: BinaryDataDecoder): SetMonitoringModeRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const monitoringMode = decoder.readUInt32();
        const monitoredItemIds = decoder.readUInt32Array();
        return new SetMonitoringModeRequest({
            requestHeader,
            subscriptionId,
            monitoringMode,
            monitoredItemIds
        });
    }
}
export interface SetMonitoringModeResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class SetMonitoringModeResponse implements SetMonitoringModeResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetMonitoringModeResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.SetMonitoringModeResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetMonitoringModeResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new SetMonitoringModeResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface SetTriggeringRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    triggeringItemId?: UInt32;
    linksToAdd?: UInt32[];
    linksToRemove?: UInt32[];
}
export class SetTriggeringRequest implements SetTriggeringRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    triggeringItemId: UInt32;
    linksToAdd?: UInt32[];
    linksToRemove?: UInt32[];
    constructor(options?: SetTriggeringRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.triggeringItemId = options?.triggeringItemId ?? 0;
        this.linksToAdd = options?.linksToAdd;
        this.linksToRemove = options?.linksToRemove;
    }
    static [typeId] = NodeIds.SetTriggeringRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.triggeringItemId);
        encoder.writeUInt32Array(this.linksToAdd);
        encoder.writeUInt32Array(this.linksToRemove);
    }
    static [decode](decoder: BinaryDataDecoder): SetTriggeringRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const triggeringItemId = decoder.readUInt32();
        const linksToAdd = decoder.readUInt32Array();
        const linksToRemove = decoder.readUInt32Array();
        return new SetTriggeringRequest({
            requestHeader,
            subscriptionId,
            triggeringItemId,
            linksToAdd,
            linksToRemove
        });
    }
}
export interface SetTriggeringResponseOptions {
    responseHeader?: ResponseHeader;
    addResults?: StatusCode[];
    addDiagnosticInfos?: DiagnosticInfo[];
    removeResults?: StatusCode[];
    removeDiagnosticInfos?: DiagnosticInfo[];
}
export class SetTriggeringResponse implements SetTriggeringResponseOptions {
    responseHeader: ResponseHeader;
    addResults?: StatusCode[];
    addDiagnosticInfos?: DiagnosticInfo[];
    removeResults?: StatusCode[];
    removeDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetTriggeringResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.addResults = options?.addResults;
        this.addDiagnosticInfos = options?.addDiagnosticInfos;
        this.removeResults = options?.removeResults;
        this.removeDiagnosticInfos = options?.removeDiagnosticInfos;
    }
    static [typeId] = NodeIds.SetTriggeringResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.addResults);
        encoder.writeTypeArray(this.addDiagnosticInfos);
        encoder.writeTypeArray(this.removeResults);
        encoder.writeTypeArray(this.removeDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetTriggeringResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const addResults = decoder.readTypeArray(StatusCode);
        const addDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        const removeResults = decoder.readTypeArray(StatusCode);
        const removeDiagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new SetTriggeringResponse({
            responseHeader,
            addResults,
            addDiagnosticInfos,
            removeResults,
            removeDiagnosticInfos
        });
    }
}
export interface DeleteMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    monitoredItemIds?: UInt32[];
}
export class DeleteMonitoredItemsRequest implements DeleteMonitoredItemsRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    monitoredItemIds?: UInt32[];
    constructor(options?: DeleteMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.monitoredItemIds = options?.monitoredItemIds;
    }
    static [typeId] = NodeIds.DeleteMonitoredItemsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32Array(this.monitoredItemIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteMonitoredItemsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const monitoredItemIds = decoder.readUInt32Array();
        return new DeleteMonitoredItemsRequest({
            requestHeader,
            subscriptionId,
            monitoredItemIds
        });
    }
}
export interface DeleteMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class DeleteMonitoredItemsResponse implements DeleteMonitoredItemsResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteMonitoredItemsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteMonitoredItemsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new DeleteMonitoredItemsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface CreateSubscriptionRequestOptions {
    requestHeader?: RequestHeader;
    requestedPublishingInterval?: Double;
    requestedLifetimeCount?: UInt32;
    requestedMaxKeepAliveCount?: UInt32;
    maxNotificationsPerPublish?: UInt32;
    publishingEnabled?: boolean;
    priority?: Byte;
}
export class CreateSubscriptionRequest implements CreateSubscriptionRequestOptions {
    requestHeader: RequestHeader;
    requestedPublishingInterval: Double;
    requestedLifetimeCount: UInt32;
    requestedMaxKeepAliveCount: UInt32;
    maxNotificationsPerPublish: UInt32;
    publishingEnabled: boolean;
    priority: Byte;
    constructor(options?: CreateSubscriptionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.requestedPublishingInterval = options?.requestedPublishingInterval ?? 0;
        this.requestedLifetimeCount = options?.requestedLifetimeCount ?? 0;
        this.requestedMaxKeepAliveCount = options?.requestedMaxKeepAliveCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.priority = options?.priority ?? 0;
    }
    static [typeId] = NodeIds.CreateSubscriptionRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeDouble(this.requestedPublishingInterval);
        encoder.writeUInt32(this.requestedLifetimeCount);
        encoder.writeUInt32(this.requestedMaxKeepAliveCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeByte(this.priority);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSubscriptionRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const requestedPublishingInterval = decoder.readDouble();
        const requestedLifetimeCount = decoder.readUInt32();
        const requestedMaxKeepAliveCount = decoder.readUInt32();
        const maxNotificationsPerPublish = decoder.readUInt32();
        const publishingEnabled = decoder.readBoolean();
        const priority = decoder.readByte();
        return new CreateSubscriptionRequest({
            requestHeader,
            requestedPublishingInterval,
            requestedLifetimeCount,
            requestedMaxKeepAliveCount,
            maxNotificationsPerPublish,
            publishingEnabled,
            priority
        });
    }
}
export interface CreateSubscriptionResponseOptions {
    responseHeader?: ResponseHeader;
    subscriptionId?: UInt32;
    revisedPublishingInterval?: Double;
    revisedLifetimeCount?: UInt32;
    revisedMaxKeepAliveCount?: UInt32;
}
export class CreateSubscriptionResponse implements CreateSubscriptionResponseOptions {
    responseHeader: ResponseHeader;
    subscriptionId: UInt32;
    revisedPublishingInterval: Double;
    revisedLifetimeCount: UInt32;
    revisedMaxKeepAliveCount: UInt32;
    constructor(options?: CreateSubscriptionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.revisedPublishingInterval = options?.revisedPublishingInterval ?? 0;
        this.revisedLifetimeCount = options?.revisedLifetimeCount ?? 0;
        this.revisedMaxKeepAliveCount = options?.revisedMaxKeepAliveCount ?? 0;
    }
    static [typeId] = NodeIds.CreateSubscriptionResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeDouble(this.revisedPublishingInterval);
        encoder.writeUInt32(this.revisedLifetimeCount);
        encoder.writeUInt32(this.revisedMaxKeepAliveCount);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSubscriptionResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const subscriptionId = decoder.readUInt32();
        const revisedPublishingInterval = decoder.readDouble();
        const revisedLifetimeCount = decoder.readUInt32();
        const revisedMaxKeepAliveCount = decoder.readUInt32();
        return new CreateSubscriptionResponse({
            responseHeader,
            subscriptionId,
            revisedPublishingInterval,
            revisedLifetimeCount,
            revisedMaxKeepAliveCount
        });
    }
}
export interface ModifySubscriptionRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    requestedPublishingInterval?: Double;
    requestedLifetimeCount?: UInt32;
    requestedMaxKeepAliveCount?: UInt32;
    maxNotificationsPerPublish?: UInt32;
    priority?: Byte;
}
export class ModifySubscriptionRequest implements ModifySubscriptionRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    requestedPublishingInterval: Double;
    requestedLifetimeCount: UInt32;
    requestedMaxKeepAliveCount: UInt32;
    maxNotificationsPerPublish: UInt32;
    priority: Byte;
    constructor(options?: ModifySubscriptionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.requestedPublishingInterval = options?.requestedPublishingInterval ?? 0;
        this.requestedLifetimeCount = options?.requestedLifetimeCount ?? 0;
        this.requestedMaxKeepAliveCount = options?.requestedMaxKeepAliveCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.priority = options?.priority ?? 0;
    }
    static [typeId] = NodeIds.ModifySubscriptionRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeDouble(this.requestedPublishingInterval);
        encoder.writeUInt32(this.requestedLifetimeCount);
        encoder.writeUInt32(this.requestedMaxKeepAliveCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeByte(this.priority);
    }
    static [decode](decoder: BinaryDataDecoder): ModifySubscriptionRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const requestedPublishingInterval = decoder.readDouble();
        const requestedLifetimeCount = decoder.readUInt32();
        const requestedMaxKeepAliveCount = decoder.readUInt32();
        const maxNotificationsPerPublish = decoder.readUInt32();
        const priority = decoder.readByte();
        return new ModifySubscriptionRequest({
            requestHeader,
            subscriptionId,
            requestedPublishingInterval,
            requestedLifetimeCount,
            requestedMaxKeepAliveCount,
            maxNotificationsPerPublish,
            priority
        });
    }
}
export interface ModifySubscriptionResponseOptions {
    responseHeader?: ResponseHeader;
    revisedPublishingInterval?: Double;
    revisedLifetimeCount?: UInt32;
    revisedMaxKeepAliveCount?: UInt32;
}
export class ModifySubscriptionResponse implements ModifySubscriptionResponseOptions {
    responseHeader: ResponseHeader;
    revisedPublishingInterval: Double;
    revisedLifetimeCount: UInt32;
    revisedMaxKeepAliveCount: UInt32;
    constructor(options?: ModifySubscriptionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.revisedPublishingInterval = options?.revisedPublishingInterval ?? 0;
        this.revisedLifetimeCount = options?.revisedLifetimeCount ?? 0;
        this.revisedMaxKeepAliveCount = options?.revisedMaxKeepAliveCount ?? 0;
    }
    static [typeId] = NodeIds.ModifySubscriptionResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeDouble(this.revisedPublishingInterval);
        encoder.writeUInt32(this.revisedLifetimeCount);
        encoder.writeUInt32(this.revisedMaxKeepAliveCount);
    }
    static [decode](decoder: BinaryDataDecoder): ModifySubscriptionResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const revisedPublishingInterval = decoder.readDouble();
        const revisedLifetimeCount = decoder.readUInt32();
        const revisedMaxKeepAliveCount = decoder.readUInt32();
        return new ModifySubscriptionResponse({
            responseHeader,
            revisedPublishingInterval,
            revisedLifetimeCount,
            revisedMaxKeepAliveCount
        });
    }
}
export interface SetPublishingModeRequestOptions {
    requestHeader?: RequestHeader;
    publishingEnabled?: boolean;
    subscriptionIds?: UInt32[];
}
export class SetPublishingModeRequest implements SetPublishingModeRequestOptions {
    requestHeader: RequestHeader;
    publishingEnabled: boolean;
    subscriptionIds?: UInt32[];
    constructor(options?: SetPublishingModeRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.subscriptionIds = options?.subscriptionIds;
    }
    static [typeId] = NodeIds.SetPublishingModeRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeUInt32Array(this.subscriptionIds);
    }
    static [decode](decoder: BinaryDataDecoder): SetPublishingModeRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const publishingEnabled = decoder.readBoolean();
        const subscriptionIds = decoder.readUInt32Array();
        return new SetPublishingModeRequest({
            requestHeader,
            publishingEnabled,
            subscriptionIds
        });
    }
}
export interface SetPublishingModeResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class SetPublishingModeResponse implements SetPublishingModeResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetPublishingModeResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.SetPublishingModeResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetPublishingModeResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new SetPublishingModeResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface NotificationMessageOptions {
    sequenceNumber?: UInt32;
    publishTime?: Date;
    notificationData?: ExtensionObject[];
}
export class NotificationMessage implements NotificationMessageOptions {
    sequenceNumber: UInt32;
    publishTime: Date;
    notificationData?: ExtensionObject[];
    constructor(options?: NotificationMessageOptions) {
        this.sequenceNumber = options?.sequenceNumber ?? 0;
        this.publishTime = options?.publishTime ?? new Date(-11644473600000);
        this.notificationData = options?.notificationData;
    }
    static [typeId] = NodeIds.NotificationMessage_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.sequenceNumber);
        encoder.writeDateTime(this.publishTime);
        encoder.writeTypeArray(this.notificationData);
    }
    static [decode](decoder: BinaryDataDecoder): NotificationMessage {
        const sequenceNumber = decoder.readUInt32();
        const publishTime = decoder.readDateTime();
        const notificationData = decoder.readTypeArray(ExtensionObject);
        return new NotificationMessage({
            sequenceNumber,
            publishTime,
            notificationData
        });
    }
}
export class NotificationData {
    static [typeId] = NodeIds.NotificationData_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): NotificationData {
        return new NotificationData();
    }
}
export interface DataChangeNotificationOptions {
    monitoredItems?: MonitoredItemNotification[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class DataChangeNotification implements DataChangeNotificationOptions {
    monitoredItems?: MonitoredItemNotification[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DataChangeNotificationOptions) {
        this.monitoredItems = options?.monitoredItems;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DataChangeNotification_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.monitoredItems);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DataChangeNotification {
        const monitoredItems = decoder.readTypeArray(MonitoredItemNotification);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new DataChangeNotification({
            monitoredItems,
            diagnosticInfos
        });
    }
}
export interface MonitoredItemNotificationOptions {
    clientHandle?: UInt32;
    value?: DataValue;
}
export class MonitoredItemNotification implements MonitoredItemNotificationOptions {
    clientHandle: UInt32;
    value: DataValue;
    constructor(options?: MonitoredItemNotificationOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.value = options?.value ?? new DataValue();
    }
    static [typeId] = NodeIds.MonitoredItemNotification_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemNotification {
        const clientHandle = decoder.readUInt32();
        const value = decoder.readType(DataValue);
        return new MonitoredItemNotification({
            clientHandle,
            value
        });
    }
}
export interface EventNotificationListOptions {
    events?: EventFieldList[];
}
export class EventNotificationList implements EventNotificationListOptions {
    events?: EventFieldList[];
    constructor(options?: EventNotificationListOptions) {
        this.events = options?.events;
    }
    static [typeId] = NodeIds.EventNotificationList_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.events);
    }
    static [decode](decoder: BinaryDataDecoder): EventNotificationList {
        const events = decoder.readTypeArray(EventFieldList);
        return new EventNotificationList({
            events
        });
    }
}
export interface EventFieldListOptions {
    clientHandle?: UInt32;
    eventFields?: Variant[];
}
export class EventFieldList implements EventFieldListOptions {
    clientHandle: UInt32;
    eventFields?: Variant[];
    constructor(options?: EventFieldListOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.eventFields = options?.eventFields;
    }
    static [typeId] = NodeIds.EventFieldList_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeTypeArray(this.eventFields);
    }
    static [decode](decoder: BinaryDataDecoder): EventFieldList {
        const clientHandle = decoder.readUInt32();
        const eventFields = decoder.readTypeArray(Variant);
        return new EventFieldList({
            clientHandle,
            eventFields
        });
    }
}
export interface HistoryEventFieldListOptions {
    eventFields?: Variant[];
}
export class HistoryEventFieldList implements HistoryEventFieldListOptions {
    eventFields?: Variant[];
    constructor(options?: HistoryEventFieldListOptions) {
        this.eventFields = options?.eventFields;
    }
    static [typeId] = NodeIds.HistoryEventFieldList_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.eventFields);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryEventFieldList {
        const eventFields = decoder.readTypeArray(Variant);
        return new HistoryEventFieldList({
            eventFields
        });
    }
}
export interface StatusChangeNotificationOptions {
    status?: StatusCode;
    diagnosticInfo?: DiagnosticInfo;
}
export class StatusChangeNotification implements StatusChangeNotificationOptions {
    status: StatusCode;
    diagnosticInfo: DiagnosticInfo;
    constructor(options?: StatusChangeNotificationOptions) {
        this.status = options?.status ?? StatusCode.Good;
        this.diagnosticInfo = options?.diagnosticInfo ?? new DiagnosticInfo();
    }
    static [typeId] = NodeIds.StatusChangeNotification_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.status);
        encoder.writeType(this.diagnosticInfo);
    }
    static [decode](decoder: BinaryDataDecoder): StatusChangeNotification {
        const status = decoder.readType(StatusCode);
        const diagnosticInfo = decoder.readType(DiagnosticInfo);
        return new StatusChangeNotification({
            status,
            diagnosticInfo
        });
    }
}
export interface SubscriptionAcknowledgementOptions {
    subscriptionId?: UInt32;
    sequenceNumber?: UInt32;
}
export class SubscriptionAcknowledgement implements SubscriptionAcknowledgementOptions {
    subscriptionId: UInt32;
    sequenceNumber: UInt32;
    constructor(options?: SubscriptionAcknowledgementOptions) {
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.sequenceNumber = options?.sequenceNumber ?? 0;
    }
    static [typeId] = NodeIds.SubscriptionAcknowledgement_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.sequenceNumber);
    }
    static [decode](decoder: BinaryDataDecoder): SubscriptionAcknowledgement {
        const subscriptionId = decoder.readUInt32();
        const sequenceNumber = decoder.readUInt32();
        return new SubscriptionAcknowledgement({
            subscriptionId,
            sequenceNumber
        });
    }
}
export interface PublishRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionAcknowledgements?: SubscriptionAcknowledgement[];
}
export class PublishRequest implements PublishRequestOptions {
    requestHeader: RequestHeader;
    subscriptionAcknowledgements?: SubscriptionAcknowledgement[];
    constructor(options?: PublishRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionAcknowledgements = options?.subscriptionAcknowledgements;
    }
    static [typeId] = NodeIds.PublishRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.subscriptionAcknowledgements);
    }
    static [decode](decoder: BinaryDataDecoder): PublishRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionAcknowledgements = decoder.readTypeArray(SubscriptionAcknowledgement);
        return new PublishRequest({
            requestHeader,
            subscriptionAcknowledgements
        });
    }
}
export interface PublishResponseOptions {
    responseHeader?: ResponseHeader;
    subscriptionId?: UInt32;
    availableSequenceNumbers?: UInt32[];
    moreNotifications?: boolean;
    notificationMessage?: NotificationMessage;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class PublishResponse implements PublishResponseOptions {
    responseHeader: ResponseHeader;
    subscriptionId: UInt32;
    availableSequenceNumbers?: UInt32[];
    moreNotifications: boolean;
    notificationMessage: NotificationMessage;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: PublishResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.availableSequenceNumbers = options?.availableSequenceNumbers;
        this.moreNotifications = options?.moreNotifications ?? false;
        this.notificationMessage = options?.notificationMessage ?? new NotificationMessage();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.PublishResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32Array(this.availableSequenceNumbers);
        encoder.writeBoolean(this.moreNotifications);
        encoder.writeType(this.notificationMessage);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): PublishResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const subscriptionId = decoder.readUInt32();
        const availableSequenceNumbers = decoder.readUInt32Array();
        const moreNotifications = decoder.readBoolean();
        const notificationMessage = decoder.readType(NotificationMessage);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new PublishResponse({
            responseHeader,
            subscriptionId,
            availableSequenceNumbers,
            moreNotifications,
            notificationMessage,
            results,
            diagnosticInfos
        });
    }
}
export interface RepublishRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionId?: UInt32;
    retransmitSequenceNumber?: UInt32;
}
export class RepublishRequest implements RepublishRequestOptions {
    requestHeader: RequestHeader;
    subscriptionId: UInt32;
    retransmitSequenceNumber: UInt32;
    constructor(options?: RepublishRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.retransmitSequenceNumber = options?.retransmitSequenceNumber ?? 0;
    }
    static [typeId] = NodeIds.RepublishRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.retransmitSequenceNumber);
    }
    static [decode](decoder: BinaryDataDecoder): RepublishRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionId = decoder.readUInt32();
        const retransmitSequenceNumber = decoder.readUInt32();
        return new RepublishRequest({
            requestHeader,
            subscriptionId,
            retransmitSequenceNumber
        });
    }
}
export interface RepublishResponseOptions {
    responseHeader?: ResponseHeader;
    notificationMessage?: NotificationMessage;
}
export class RepublishResponse implements RepublishResponseOptions {
    responseHeader: ResponseHeader;
    notificationMessage: NotificationMessage;
    constructor(options?: RepublishResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.notificationMessage = options?.notificationMessage ?? new NotificationMessage();
    }
    static [typeId] = NodeIds.RepublishResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeType(this.notificationMessage);
    }
    static [decode](decoder: BinaryDataDecoder): RepublishResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const notificationMessage = decoder.readType(NotificationMessage);
        return new RepublishResponse({
            responseHeader,
            notificationMessage
        });
    }
}
export interface TransferResultOptions {
    statusCode?: StatusCode;
    availableSequenceNumbers?: UInt32[];
}
export class TransferResult implements TransferResultOptions {
    statusCode: StatusCode;
    availableSequenceNumbers?: UInt32[];
    constructor(options?: TransferResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.availableSequenceNumbers = options?.availableSequenceNumbers;
    }
    static [typeId] = NodeIds.TransferResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeUInt32Array(this.availableSequenceNumbers);
    }
    static [decode](decoder: BinaryDataDecoder): TransferResult {
        const statusCode = decoder.readType(StatusCode);
        const availableSequenceNumbers = decoder.readUInt32Array();
        return new TransferResult({
            statusCode,
            availableSequenceNumbers
        });
    }
}
export interface TransferSubscriptionsRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionIds?: UInt32[];
    sendInitialValues?: boolean;
}
export class TransferSubscriptionsRequest implements TransferSubscriptionsRequestOptions {
    requestHeader: RequestHeader;
    subscriptionIds?: UInt32[];
    sendInitialValues: boolean;
    constructor(options?: TransferSubscriptionsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionIds = options?.subscriptionIds;
        this.sendInitialValues = options?.sendInitialValues ?? false;
    }
    static [typeId] = NodeIds.TransferSubscriptionsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32Array(this.subscriptionIds);
        encoder.writeBoolean(this.sendInitialValues);
    }
    static [decode](decoder: BinaryDataDecoder): TransferSubscriptionsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionIds = decoder.readUInt32Array();
        const sendInitialValues = decoder.readBoolean();
        return new TransferSubscriptionsRequest({
            requestHeader,
            subscriptionIds,
            sendInitialValues
        });
    }
}
export interface TransferSubscriptionsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: TransferResult[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class TransferSubscriptionsResponse implements TransferSubscriptionsResponseOptions {
    responseHeader: ResponseHeader;
    results?: TransferResult[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: TransferSubscriptionsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.TransferSubscriptionsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): TransferSubscriptionsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(TransferResult);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new TransferSubscriptionsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface DeleteSubscriptionsRequestOptions {
    requestHeader?: RequestHeader;
    subscriptionIds?: UInt32[];
}
export class DeleteSubscriptionsRequest implements DeleteSubscriptionsRequestOptions {
    requestHeader: RequestHeader;
    subscriptionIds?: UInt32[];
    constructor(options?: DeleteSubscriptionsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionIds = options?.subscriptionIds;
    }
    static [typeId] = NodeIds.DeleteSubscriptionsRequest_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32Array(this.subscriptionIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteSubscriptionsRequest {
        const requestHeader = decoder.readType(RequestHeader);
        const subscriptionIds = decoder.readUInt32Array();
        return new DeleteSubscriptionsRequest({
            requestHeader,
            subscriptionIds
        });
    }
}
export interface DeleteSubscriptionsResponseOptions {
    responseHeader?: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
}
export class DeleteSubscriptionsResponse implements DeleteSubscriptionsResponseOptions {
    responseHeader: ResponseHeader;
    results?: StatusCode[];
    diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteSubscriptionsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteSubscriptionsResponse_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteSubscriptionsResponse {
        const responseHeader = decoder.readType(ResponseHeader);
        const results = decoder.readTypeArray(StatusCode);
        const diagnosticInfos = decoder.readTypeArray(DiagnosticInfo);
        return new DeleteSubscriptionsResponse({
            responseHeader,
            results,
            diagnosticInfos
        });
    }
}
export interface BuildInfoOptions {
    productUri?: UaString;
    manufacturerName?: UaString;
    productName?: UaString;
    softwareVersion?: UaString;
    buildNumber?: UaString;
    buildDate?: Date;
}
export class BuildInfo implements BuildInfoOptions {
    productUri?: UaString;
    manufacturerName?: UaString;
    productName?: UaString;
    softwareVersion?: UaString;
    buildNumber?: UaString;
    buildDate: Date;
    constructor(options?: BuildInfoOptions) {
        this.productUri = options?.productUri;
        this.manufacturerName = options?.manufacturerName;
        this.productName = options?.productName;
        this.softwareVersion = options?.softwareVersion;
        this.buildNumber = options?.buildNumber;
        this.buildDate = options?.buildDate ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.BuildInfo_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.productUri);
        encoder.writeString(this.manufacturerName);
        encoder.writeString(this.productName);
        encoder.writeString(this.softwareVersion);
        encoder.writeString(this.buildNumber);
        encoder.writeDateTime(this.buildDate);
    }
    static [decode](decoder: BinaryDataDecoder): BuildInfo {
        const productUri = decoder.readString();
        const manufacturerName = decoder.readString();
        const productName = decoder.readString();
        const softwareVersion = decoder.readString();
        const buildNumber = decoder.readString();
        const buildDate = decoder.readDateTime();
        return new BuildInfo({
            productUri,
            manufacturerName,
            productName,
            softwareVersion,
            buildNumber,
            buildDate
        });
    }
}
export enum RedundancySupport {
    None = 0,
    Cold = 1,
    Warm = 2,
    Hot = 3,
    Transparent = 4,
    HotAndMirrored = 5
}
export enum ServerState {
    Running = 0,
    Failed = 1,
    NoConfiguration = 2,
    Suspended = 3,
    Shutdown = 4,
    Test = 5,
    CommunicationFault = 6,
    Unknown = 7
}
export interface RedundantServerDataTypeOptions {
    serverId?: UaString;
    serviceLevel?: Byte;
    serverState?: ServerState;
}
export class RedundantServerDataType implements RedundantServerDataTypeOptions {
    serverId?: UaString;
    serviceLevel: Byte;
    serverState: ServerState;
    constructor(options?: RedundantServerDataTypeOptions) {
        this.serverId = options?.serverId;
        this.serviceLevel = options?.serviceLevel ?? 0;
        this.serverState = options?.serverState ?? ServerState.Running;
    }
    static [typeId] = NodeIds.RedundantServerDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverId);
        encoder.writeByte(this.serviceLevel);
        encoder.writeUInt32(this.serverState);
    }
    static [decode](decoder: BinaryDataDecoder): RedundantServerDataType {
        const serverId = decoder.readString();
        const serviceLevel = decoder.readByte();
        const serverState = decoder.readUInt32();
        return new RedundantServerDataType({
            serverId,
            serviceLevel,
            serverState
        });
    }
}
export interface EndpointUrlListDataTypeOptions {
    endpointUrlList?: UaString[];
}
export class EndpointUrlListDataType implements EndpointUrlListDataTypeOptions {
    endpointUrlList?: UaString[];
    constructor(options?: EndpointUrlListDataTypeOptions) {
        this.endpointUrlList = options?.endpointUrlList;
    }
    static [typeId] = NodeIds.EndpointUrlListDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.endpointUrlList);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointUrlListDataType {
        const endpointUrlList = decoder.readStringArray();
        return new EndpointUrlListDataType({
            endpointUrlList
        });
    }
}
export interface NetworkGroupDataTypeOptions {
    serverUri?: UaString;
    networkPaths?: EndpointUrlListDataType[];
}
export class NetworkGroupDataType implements NetworkGroupDataTypeOptions {
    serverUri?: UaString;
    networkPaths?: EndpointUrlListDataType[];
    constructor(options?: NetworkGroupDataTypeOptions) {
        this.serverUri = options?.serverUri;
        this.networkPaths = options?.networkPaths;
    }
    static [typeId] = NodeIds.NetworkGroupDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverUri);
        encoder.writeTypeArray(this.networkPaths);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkGroupDataType {
        const serverUri = decoder.readString();
        const networkPaths = decoder.readTypeArray(EndpointUrlListDataType);
        return new NetworkGroupDataType({
            serverUri,
            networkPaths
        });
    }
}
export interface SamplingIntervalDiagnosticsDataTypeOptions {
    samplingInterval?: Double;
    monitoredItemCount?: UInt32;
    maxMonitoredItemCount?: UInt32;
    disabledMonitoredItemCount?: UInt32;
}
export class SamplingIntervalDiagnosticsDataType implements SamplingIntervalDiagnosticsDataTypeOptions {
    samplingInterval: Double;
    monitoredItemCount: UInt32;
    maxMonitoredItemCount: UInt32;
    disabledMonitoredItemCount: UInt32;
    constructor(options?: SamplingIntervalDiagnosticsDataTypeOptions) {
        this.samplingInterval = options?.samplingInterval ?? 0;
        this.monitoredItemCount = options?.monitoredItemCount ?? 0;
        this.maxMonitoredItemCount = options?.maxMonitoredItemCount ?? 0;
        this.disabledMonitoredItemCount = options?.disabledMonitoredItemCount ?? 0;
    }
    static [typeId] = NodeIds.SamplingIntervalDiagnosticsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.samplingInterval);
        encoder.writeUInt32(this.monitoredItemCount);
        encoder.writeUInt32(this.maxMonitoredItemCount);
        encoder.writeUInt32(this.disabledMonitoredItemCount);
    }
    static [decode](decoder: BinaryDataDecoder): SamplingIntervalDiagnosticsDataType {
        const samplingInterval = decoder.readDouble();
        const monitoredItemCount = decoder.readUInt32();
        const maxMonitoredItemCount = decoder.readUInt32();
        const disabledMonitoredItemCount = decoder.readUInt32();
        return new SamplingIntervalDiagnosticsDataType({
            samplingInterval,
            monitoredItemCount,
            maxMonitoredItemCount,
            disabledMonitoredItemCount
        });
    }
}
export interface ServerDiagnosticsSummaryDataTypeOptions {
    serverViewCount?: UInt32;
    currentSessionCount?: UInt32;
    cumulatedSessionCount?: UInt32;
    securityRejectedSessionCount?: UInt32;
    rejectedSessionCount?: UInt32;
    sessionTimeoutCount?: UInt32;
    sessionAbortCount?: UInt32;
    currentSubscriptionCount?: UInt32;
    cumulatedSubscriptionCount?: UInt32;
    publishingIntervalCount?: UInt32;
    securityRejectedRequestsCount?: UInt32;
    rejectedRequestsCount?: UInt32;
}
export class ServerDiagnosticsSummaryDataType implements ServerDiagnosticsSummaryDataTypeOptions {
    serverViewCount: UInt32;
    currentSessionCount: UInt32;
    cumulatedSessionCount: UInt32;
    securityRejectedSessionCount: UInt32;
    rejectedSessionCount: UInt32;
    sessionTimeoutCount: UInt32;
    sessionAbortCount: UInt32;
    currentSubscriptionCount: UInt32;
    cumulatedSubscriptionCount: UInt32;
    publishingIntervalCount: UInt32;
    securityRejectedRequestsCount: UInt32;
    rejectedRequestsCount: UInt32;
    constructor(options?: ServerDiagnosticsSummaryDataTypeOptions) {
        this.serverViewCount = options?.serverViewCount ?? 0;
        this.currentSessionCount = options?.currentSessionCount ?? 0;
        this.cumulatedSessionCount = options?.cumulatedSessionCount ?? 0;
        this.securityRejectedSessionCount = options?.securityRejectedSessionCount ?? 0;
        this.rejectedSessionCount = options?.rejectedSessionCount ?? 0;
        this.sessionTimeoutCount = options?.sessionTimeoutCount ?? 0;
        this.sessionAbortCount = options?.sessionAbortCount ?? 0;
        this.currentSubscriptionCount = options?.currentSubscriptionCount ?? 0;
        this.cumulatedSubscriptionCount = options?.cumulatedSubscriptionCount ?? 0;
        this.publishingIntervalCount = options?.publishingIntervalCount ?? 0;
        this.securityRejectedRequestsCount = options?.securityRejectedRequestsCount ?? 0;
        this.rejectedRequestsCount = options?.rejectedRequestsCount ?? 0;
    }
    static [typeId] = NodeIds.ServerDiagnosticsSummaryDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.serverViewCount);
        encoder.writeUInt32(this.currentSessionCount);
        encoder.writeUInt32(this.cumulatedSessionCount);
        encoder.writeUInt32(this.securityRejectedSessionCount);
        encoder.writeUInt32(this.rejectedSessionCount);
        encoder.writeUInt32(this.sessionTimeoutCount);
        encoder.writeUInt32(this.sessionAbortCount);
        encoder.writeUInt32(this.currentSubscriptionCount);
        encoder.writeUInt32(this.cumulatedSubscriptionCount);
        encoder.writeUInt32(this.publishingIntervalCount);
        encoder.writeUInt32(this.securityRejectedRequestsCount);
        encoder.writeUInt32(this.rejectedRequestsCount);
    }
    static [decode](decoder: BinaryDataDecoder): ServerDiagnosticsSummaryDataType {
        const serverViewCount = decoder.readUInt32();
        const currentSessionCount = decoder.readUInt32();
        const cumulatedSessionCount = decoder.readUInt32();
        const securityRejectedSessionCount = decoder.readUInt32();
        const rejectedSessionCount = decoder.readUInt32();
        const sessionTimeoutCount = decoder.readUInt32();
        const sessionAbortCount = decoder.readUInt32();
        const currentSubscriptionCount = decoder.readUInt32();
        const cumulatedSubscriptionCount = decoder.readUInt32();
        const publishingIntervalCount = decoder.readUInt32();
        const securityRejectedRequestsCount = decoder.readUInt32();
        const rejectedRequestsCount = decoder.readUInt32();
        return new ServerDiagnosticsSummaryDataType({
            serverViewCount,
            currentSessionCount,
            cumulatedSessionCount,
            securityRejectedSessionCount,
            rejectedSessionCount,
            sessionTimeoutCount,
            sessionAbortCount,
            currentSubscriptionCount,
            cumulatedSubscriptionCount,
            publishingIntervalCount,
            securityRejectedRequestsCount,
            rejectedRequestsCount
        });
    }
}
export interface ServerStatusDataTypeOptions {
    startTime?: Date;
    currentTime?: Date;
    state?: ServerState;
    buildInfo?: BuildInfo;
    secondsTillShutdown?: UInt32;
    shutdownReason?: LocalizedText;
}
export class ServerStatusDataType implements ServerStatusDataTypeOptions {
    startTime: Date;
    currentTime: Date;
    state: ServerState;
    buildInfo: BuildInfo;
    secondsTillShutdown: UInt32;
    shutdownReason: LocalizedText;
    constructor(options?: ServerStatusDataTypeOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.currentTime = options?.currentTime ?? new Date(-11644473600000);
        this.state = options?.state ?? ServerState.Running;
        this.buildInfo = options?.buildInfo ?? new BuildInfo();
        this.secondsTillShutdown = options?.secondsTillShutdown ?? 0;
        this.shutdownReason = options?.shutdownReason ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ServerStatusDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.currentTime);
        encoder.writeUInt32(this.state);
        encoder.writeType(this.buildInfo);
        encoder.writeUInt32(this.secondsTillShutdown);
        encoder.writeType(this.shutdownReason);
    }
    static [decode](decoder: BinaryDataDecoder): ServerStatusDataType {
        const startTime = decoder.readDateTime();
        const currentTime = decoder.readDateTime();
        const state = decoder.readUInt32();
        const buildInfo = decoder.readType(BuildInfo);
        const secondsTillShutdown = decoder.readUInt32();
        const shutdownReason = decoder.readType(LocalizedText);
        return new ServerStatusDataType({
            startTime,
            currentTime,
            state,
            buildInfo,
            secondsTillShutdown,
            shutdownReason
        });
    }
}
export interface SessionDiagnosticsDataTypeOptions {
    sessionId?: NodeId;
    sessionName?: UaString;
    clientDescription?: ApplicationDescription;
    serverUri?: UaString;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    actualSessionTimeout?: Double;
    maxResponseMessageSize?: UInt32;
    clientConnectionTime?: Date;
    clientLastContactTime?: Date;
    currentSubscriptionsCount?: UInt32;
    currentMonitoredItemsCount?: UInt32;
    currentPublishRequestsInQueue?: UInt32;
    totalRequestCount?: ServiceCounterDataType;
    unauthorizedRequestCount?: UInt32;
    readCount?: ServiceCounterDataType;
    historyReadCount?: ServiceCounterDataType;
    writeCount?: ServiceCounterDataType;
    historyUpdateCount?: ServiceCounterDataType;
    callCount?: ServiceCounterDataType;
    createMonitoredItemsCount?: ServiceCounterDataType;
    modifyMonitoredItemsCount?: ServiceCounterDataType;
    setMonitoringModeCount?: ServiceCounterDataType;
    setTriggeringCount?: ServiceCounterDataType;
    deleteMonitoredItemsCount?: ServiceCounterDataType;
    createSubscriptionCount?: ServiceCounterDataType;
    modifySubscriptionCount?: ServiceCounterDataType;
    setPublishingModeCount?: ServiceCounterDataType;
    publishCount?: ServiceCounterDataType;
    republishCount?: ServiceCounterDataType;
    transferSubscriptionsCount?: ServiceCounterDataType;
    deleteSubscriptionsCount?: ServiceCounterDataType;
    addNodesCount?: ServiceCounterDataType;
    addReferencesCount?: ServiceCounterDataType;
    deleteNodesCount?: ServiceCounterDataType;
    deleteReferencesCount?: ServiceCounterDataType;
    browseCount?: ServiceCounterDataType;
    browseNextCount?: ServiceCounterDataType;
    translateBrowsePathsToNodeIdsCount?: ServiceCounterDataType;
    queryFirstCount?: ServiceCounterDataType;
    queryNextCount?: ServiceCounterDataType;
    registerNodesCount?: ServiceCounterDataType;
    unregisterNodesCount?: ServiceCounterDataType;
}
export class SessionDiagnosticsDataType implements SessionDiagnosticsDataTypeOptions {
    sessionId: NodeId;
    sessionName?: UaString;
    clientDescription: ApplicationDescription;
    serverUri?: UaString;
    endpointUrl?: UaString;
    localeIds?: UaString[];
    actualSessionTimeout: Double;
    maxResponseMessageSize: UInt32;
    clientConnectionTime: Date;
    clientLastContactTime: Date;
    currentSubscriptionsCount: UInt32;
    currentMonitoredItemsCount: UInt32;
    currentPublishRequestsInQueue: UInt32;
    totalRequestCount: ServiceCounterDataType;
    unauthorizedRequestCount: UInt32;
    readCount: ServiceCounterDataType;
    historyReadCount: ServiceCounterDataType;
    writeCount: ServiceCounterDataType;
    historyUpdateCount: ServiceCounterDataType;
    callCount: ServiceCounterDataType;
    createMonitoredItemsCount: ServiceCounterDataType;
    modifyMonitoredItemsCount: ServiceCounterDataType;
    setMonitoringModeCount: ServiceCounterDataType;
    setTriggeringCount: ServiceCounterDataType;
    deleteMonitoredItemsCount: ServiceCounterDataType;
    createSubscriptionCount: ServiceCounterDataType;
    modifySubscriptionCount: ServiceCounterDataType;
    setPublishingModeCount: ServiceCounterDataType;
    publishCount: ServiceCounterDataType;
    republishCount: ServiceCounterDataType;
    transferSubscriptionsCount: ServiceCounterDataType;
    deleteSubscriptionsCount: ServiceCounterDataType;
    addNodesCount: ServiceCounterDataType;
    addReferencesCount: ServiceCounterDataType;
    deleteNodesCount: ServiceCounterDataType;
    deleteReferencesCount: ServiceCounterDataType;
    browseCount: ServiceCounterDataType;
    browseNextCount: ServiceCounterDataType;
    translateBrowsePathsToNodeIdsCount: ServiceCounterDataType;
    queryFirstCount: ServiceCounterDataType;
    queryNextCount: ServiceCounterDataType;
    registerNodesCount: ServiceCounterDataType;
    unregisterNodesCount: ServiceCounterDataType;
    constructor(options?: SessionDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.sessionName = options?.sessionName;
        this.clientDescription = options?.clientDescription ?? new ApplicationDescription();
        this.serverUri = options?.serverUri;
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.actualSessionTimeout = options?.actualSessionTimeout ?? 0;
        this.maxResponseMessageSize = options?.maxResponseMessageSize ?? 0;
        this.clientConnectionTime = options?.clientConnectionTime ?? new Date(-11644473600000);
        this.clientLastContactTime = options?.clientLastContactTime ?? new Date(-11644473600000);
        this.currentSubscriptionsCount = options?.currentSubscriptionsCount ?? 0;
        this.currentMonitoredItemsCount = options?.currentMonitoredItemsCount ?? 0;
        this.currentPublishRequestsInQueue = options?.currentPublishRequestsInQueue ?? 0;
        this.totalRequestCount = options?.totalRequestCount ?? new ServiceCounterDataType();
        this.unauthorizedRequestCount = options?.unauthorizedRequestCount ?? 0;
        this.readCount = options?.readCount ?? new ServiceCounterDataType();
        this.historyReadCount = options?.historyReadCount ?? new ServiceCounterDataType();
        this.writeCount = options?.writeCount ?? new ServiceCounterDataType();
        this.historyUpdateCount = options?.historyUpdateCount ?? new ServiceCounterDataType();
        this.callCount = options?.callCount ?? new ServiceCounterDataType();
        this.createMonitoredItemsCount = options?.createMonitoredItemsCount ?? new ServiceCounterDataType();
        this.modifyMonitoredItemsCount = options?.modifyMonitoredItemsCount ?? new ServiceCounterDataType();
        this.setMonitoringModeCount = options?.setMonitoringModeCount ?? new ServiceCounterDataType();
        this.setTriggeringCount = options?.setTriggeringCount ?? new ServiceCounterDataType();
        this.deleteMonitoredItemsCount = options?.deleteMonitoredItemsCount ?? new ServiceCounterDataType();
        this.createSubscriptionCount = options?.createSubscriptionCount ?? new ServiceCounterDataType();
        this.modifySubscriptionCount = options?.modifySubscriptionCount ?? new ServiceCounterDataType();
        this.setPublishingModeCount = options?.setPublishingModeCount ?? new ServiceCounterDataType();
        this.publishCount = options?.publishCount ?? new ServiceCounterDataType();
        this.republishCount = options?.republishCount ?? new ServiceCounterDataType();
        this.transferSubscriptionsCount = options?.transferSubscriptionsCount ?? new ServiceCounterDataType();
        this.deleteSubscriptionsCount = options?.deleteSubscriptionsCount ?? new ServiceCounterDataType();
        this.addNodesCount = options?.addNodesCount ?? new ServiceCounterDataType();
        this.addReferencesCount = options?.addReferencesCount ?? new ServiceCounterDataType();
        this.deleteNodesCount = options?.deleteNodesCount ?? new ServiceCounterDataType();
        this.deleteReferencesCount = options?.deleteReferencesCount ?? new ServiceCounterDataType();
        this.browseCount = options?.browseCount ?? new ServiceCounterDataType();
        this.browseNextCount = options?.browseNextCount ?? new ServiceCounterDataType();
        this.translateBrowsePathsToNodeIdsCount = options?.translateBrowsePathsToNodeIdsCount ?? new ServiceCounterDataType();
        this.queryFirstCount = options?.queryFirstCount ?? new ServiceCounterDataType();
        this.queryNextCount = options?.queryNextCount ?? new ServiceCounterDataType();
        this.registerNodesCount = options?.registerNodesCount ?? new ServiceCounterDataType();
        this.unregisterNodesCount = options?.unregisterNodesCount ?? new ServiceCounterDataType();
    }
    static [typeId] = NodeIds.SessionDiagnosticsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeString(this.sessionName);
        encoder.writeType(this.clientDescription);
        encoder.writeString(this.serverUri);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeDouble(this.actualSessionTimeout);
        encoder.writeUInt32(this.maxResponseMessageSize);
        encoder.writeDateTime(this.clientConnectionTime);
        encoder.writeDateTime(this.clientLastContactTime);
        encoder.writeUInt32(this.currentSubscriptionsCount);
        encoder.writeUInt32(this.currentMonitoredItemsCount);
        encoder.writeUInt32(this.currentPublishRequestsInQueue);
        encoder.writeType(this.totalRequestCount);
        encoder.writeUInt32(this.unauthorizedRequestCount);
        encoder.writeType(this.readCount);
        encoder.writeType(this.historyReadCount);
        encoder.writeType(this.writeCount);
        encoder.writeType(this.historyUpdateCount);
        encoder.writeType(this.callCount);
        encoder.writeType(this.createMonitoredItemsCount);
        encoder.writeType(this.modifyMonitoredItemsCount);
        encoder.writeType(this.setMonitoringModeCount);
        encoder.writeType(this.setTriggeringCount);
        encoder.writeType(this.deleteMonitoredItemsCount);
        encoder.writeType(this.createSubscriptionCount);
        encoder.writeType(this.modifySubscriptionCount);
        encoder.writeType(this.setPublishingModeCount);
        encoder.writeType(this.publishCount);
        encoder.writeType(this.republishCount);
        encoder.writeType(this.transferSubscriptionsCount);
        encoder.writeType(this.deleteSubscriptionsCount);
        encoder.writeType(this.addNodesCount);
        encoder.writeType(this.addReferencesCount);
        encoder.writeType(this.deleteNodesCount);
        encoder.writeType(this.deleteReferencesCount);
        encoder.writeType(this.browseCount);
        encoder.writeType(this.browseNextCount);
        encoder.writeType(this.translateBrowsePathsToNodeIdsCount);
        encoder.writeType(this.queryFirstCount);
        encoder.writeType(this.queryNextCount);
        encoder.writeType(this.registerNodesCount);
        encoder.writeType(this.unregisterNodesCount);
    }
    static [decode](decoder: BinaryDataDecoder): SessionDiagnosticsDataType {
        const sessionId = decoder.readType(NodeId);
        const sessionName = decoder.readString();
        const clientDescription = decoder.readType(ApplicationDescription);
        const serverUri = decoder.readString();
        const endpointUrl = decoder.readString();
        const localeIds = decoder.readStringArray();
        const actualSessionTimeout = decoder.readDouble();
        const maxResponseMessageSize = decoder.readUInt32();
        const clientConnectionTime = decoder.readDateTime();
        const clientLastContactTime = decoder.readDateTime();
        const currentSubscriptionsCount = decoder.readUInt32();
        const currentMonitoredItemsCount = decoder.readUInt32();
        const currentPublishRequestsInQueue = decoder.readUInt32();
        const totalRequestCount = decoder.readType(ServiceCounterDataType);
        const unauthorizedRequestCount = decoder.readUInt32();
        const readCount = decoder.readType(ServiceCounterDataType);
        const historyReadCount = decoder.readType(ServiceCounterDataType);
        const writeCount = decoder.readType(ServiceCounterDataType);
        const historyUpdateCount = decoder.readType(ServiceCounterDataType);
        const callCount = decoder.readType(ServiceCounterDataType);
        const createMonitoredItemsCount = decoder.readType(ServiceCounterDataType);
        const modifyMonitoredItemsCount = decoder.readType(ServiceCounterDataType);
        const setMonitoringModeCount = decoder.readType(ServiceCounterDataType);
        const setTriggeringCount = decoder.readType(ServiceCounterDataType);
        const deleteMonitoredItemsCount = decoder.readType(ServiceCounterDataType);
        const createSubscriptionCount = decoder.readType(ServiceCounterDataType);
        const modifySubscriptionCount = decoder.readType(ServiceCounterDataType);
        const setPublishingModeCount = decoder.readType(ServiceCounterDataType);
        const publishCount = decoder.readType(ServiceCounterDataType);
        const republishCount = decoder.readType(ServiceCounterDataType);
        const transferSubscriptionsCount = decoder.readType(ServiceCounterDataType);
        const deleteSubscriptionsCount = decoder.readType(ServiceCounterDataType);
        const addNodesCount = decoder.readType(ServiceCounterDataType);
        const addReferencesCount = decoder.readType(ServiceCounterDataType);
        const deleteNodesCount = decoder.readType(ServiceCounterDataType);
        const deleteReferencesCount = decoder.readType(ServiceCounterDataType);
        const browseCount = decoder.readType(ServiceCounterDataType);
        const browseNextCount = decoder.readType(ServiceCounterDataType);
        const translateBrowsePathsToNodeIdsCount = decoder.readType(ServiceCounterDataType);
        const queryFirstCount = decoder.readType(ServiceCounterDataType);
        const queryNextCount = decoder.readType(ServiceCounterDataType);
        const registerNodesCount = decoder.readType(ServiceCounterDataType);
        const unregisterNodesCount = decoder.readType(ServiceCounterDataType);
        return new SessionDiagnosticsDataType({
            sessionId,
            sessionName,
            clientDescription,
            serverUri,
            endpointUrl,
            localeIds,
            actualSessionTimeout,
            maxResponseMessageSize,
            clientConnectionTime,
            clientLastContactTime,
            currentSubscriptionsCount,
            currentMonitoredItemsCount,
            currentPublishRequestsInQueue,
            totalRequestCount,
            unauthorizedRequestCount,
            readCount,
            historyReadCount,
            writeCount,
            historyUpdateCount,
            callCount,
            createMonitoredItemsCount,
            modifyMonitoredItemsCount,
            setMonitoringModeCount,
            setTriggeringCount,
            deleteMonitoredItemsCount,
            createSubscriptionCount,
            modifySubscriptionCount,
            setPublishingModeCount,
            publishCount,
            republishCount,
            transferSubscriptionsCount,
            deleteSubscriptionsCount,
            addNodesCount,
            addReferencesCount,
            deleteNodesCount,
            deleteReferencesCount,
            browseCount,
            browseNextCount,
            translateBrowsePathsToNodeIdsCount,
            queryFirstCount,
            queryNextCount,
            registerNodesCount,
            unregisterNodesCount
        });
    }
}
export interface SessionSecurityDiagnosticsDataTypeOptions {
    sessionId?: NodeId;
    clientUserIdOfSession?: UaString;
    clientUserIdHistory?: UaString[];
    authenticationMechanism?: UaString;
    encoding?: UaString;
    transportProtocol?: UaString;
    securityMode?: MessageSecurityMode;
    securityPolicyUri?: UaString;
    clientCertificate?: ByteString;
}
export class SessionSecurityDiagnosticsDataType implements SessionSecurityDiagnosticsDataTypeOptions {
    sessionId: NodeId;
    clientUserIdOfSession?: UaString;
    clientUserIdHistory?: UaString[];
    authenticationMechanism?: UaString;
    encoding?: UaString;
    transportProtocol?: UaString;
    securityMode: MessageSecurityMode;
    securityPolicyUri?: UaString;
    clientCertificate?: ByteString;
    constructor(options?: SessionSecurityDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.clientUserIdOfSession = options?.clientUserIdOfSession;
        this.clientUserIdHistory = options?.clientUserIdHistory;
        this.authenticationMechanism = options?.authenticationMechanism;
        this.encoding = options?.encoding;
        this.transportProtocol = options?.transportProtocol;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.clientCertificate = options?.clientCertificate;
    }
    static [typeId] = NodeIds.SessionSecurityDiagnosticsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeString(this.clientUserIdOfSession);
        encoder.writeStringArray(this.clientUserIdHistory);
        encoder.writeString(this.authenticationMechanism);
        encoder.writeString(this.encoding);
        encoder.writeString(this.transportProtocol);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeByteString(this.clientCertificate);
    }
    static [decode](decoder: BinaryDataDecoder): SessionSecurityDiagnosticsDataType {
        const sessionId = decoder.readType(NodeId);
        const clientUserIdOfSession = decoder.readString();
        const clientUserIdHistory = decoder.readStringArray();
        const authenticationMechanism = decoder.readString();
        const encoding = decoder.readString();
        const transportProtocol = decoder.readString();
        const securityMode = decoder.readUInt32();
        const securityPolicyUri = decoder.readString();
        const clientCertificate = decoder.readByteString();
        return new SessionSecurityDiagnosticsDataType({
            sessionId,
            clientUserIdOfSession,
            clientUserIdHistory,
            authenticationMechanism,
            encoding,
            transportProtocol,
            securityMode,
            securityPolicyUri,
            clientCertificate
        });
    }
}
export interface ServiceCounterDataTypeOptions {
    totalCount?: UInt32;
    errorCount?: UInt32;
}
export class ServiceCounterDataType implements ServiceCounterDataTypeOptions {
    totalCount: UInt32;
    errorCount: UInt32;
    constructor(options?: ServiceCounterDataTypeOptions) {
        this.totalCount = options?.totalCount ?? 0;
        this.errorCount = options?.errorCount ?? 0;
    }
    static [typeId] = NodeIds.ServiceCounterDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.totalCount);
        encoder.writeUInt32(this.errorCount);
    }
    static [decode](decoder: BinaryDataDecoder): ServiceCounterDataType {
        const totalCount = decoder.readUInt32();
        const errorCount = decoder.readUInt32();
        return new ServiceCounterDataType({
            totalCount,
            errorCount
        });
    }
}
export interface StatusResultOptions {
    statusCode?: StatusCode;
    diagnosticInfo?: DiagnosticInfo;
}
export class StatusResult implements StatusResultOptions {
    statusCode: StatusCode;
    diagnosticInfo: DiagnosticInfo;
    constructor(options?: StatusResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.diagnosticInfo = options?.diagnosticInfo ?? new DiagnosticInfo();
    }
    static [typeId] = NodeIds.StatusResult_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeType(this.diagnosticInfo);
    }
    static [decode](decoder: BinaryDataDecoder): StatusResult {
        const statusCode = decoder.readType(StatusCode);
        const diagnosticInfo = decoder.readType(DiagnosticInfo);
        return new StatusResult({
            statusCode,
            diagnosticInfo
        });
    }
}
export interface SubscriptionDiagnosticsDataTypeOptions {
    sessionId?: NodeId;
    subscriptionId?: UInt32;
    priority?: Byte;
    publishingInterval?: Double;
    maxKeepAliveCount?: UInt32;
    maxLifetimeCount?: UInt32;
    maxNotificationsPerPublish?: UInt32;
    publishingEnabled?: boolean;
    modifyCount?: UInt32;
    enableCount?: UInt32;
    disableCount?: UInt32;
    republishRequestCount?: UInt32;
    republishMessageRequestCount?: UInt32;
    republishMessageCount?: UInt32;
    transferRequestCount?: UInt32;
    transferredToAltClientCount?: UInt32;
    transferredToSameClientCount?: UInt32;
    publishRequestCount?: UInt32;
    dataChangeNotificationsCount?: UInt32;
    eventNotificationsCount?: UInt32;
    notificationsCount?: UInt32;
    latePublishRequestCount?: UInt32;
    currentKeepAliveCount?: UInt32;
    currentLifetimeCount?: UInt32;
    unacknowledgedMessageCount?: UInt32;
    discardedMessageCount?: UInt32;
    monitoredItemCount?: UInt32;
    disabledMonitoredItemCount?: UInt32;
    monitoringQueueOverflowCount?: UInt32;
    nextSequenceNumber?: UInt32;
    eventQueueOverFlowCount?: UInt32;
}
export class SubscriptionDiagnosticsDataType implements SubscriptionDiagnosticsDataTypeOptions {
    sessionId: NodeId;
    subscriptionId: UInt32;
    priority: Byte;
    publishingInterval: Double;
    maxKeepAliveCount: UInt32;
    maxLifetimeCount: UInt32;
    maxNotificationsPerPublish: UInt32;
    publishingEnabled: boolean;
    modifyCount: UInt32;
    enableCount: UInt32;
    disableCount: UInt32;
    republishRequestCount: UInt32;
    republishMessageRequestCount: UInt32;
    republishMessageCount: UInt32;
    transferRequestCount: UInt32;
    transferredToAltClientCount: UInt32;
    transferredToSameClientCount: UInt32;
    publishRequestCount: UInt32;
    dataChangeNotificationsCount: UInt32;
    eventNotificationsCount: UInt32;
    notificationsCount: UInt32;
    latePublishRequestCount: UInt32;
    currentKeepAliveCount: UInt32;
    currentLifetimeCount: UInt32;
    unacknowledgedMessageCount: UInt32;
    discardedMessageCount: UInt32;
    monitoredItemCount: UInt32;
    disabledMonitoredItemCount: UInt32;
    monitoringQueueOverflowCount: UInt32;
    nextSequenceNumber: UInt32;
    eventQueueOverFlowCount: UInt32;
    constructor(options?: SubscriptionDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.priority = options?.priority ?? 0;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.maxKeepAliveCount = options?.maxKeepAliveCount ?? 0;
        this.maxLifetimeCount = options?.maxLifetimeCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.modifyCount = options?.modifyCount ?? 0;
        this.enableCount = options?.enableCount ?? 0;
        this.disableCount = options?.disableCount ?? 0;
        this.republishRequestCount = options?.republishRequestCount ?? 0;
        this.republishMessageRequestCount = options?.republishMessageRequestCount ?? 0;
        this.republishMessageCount = options?.republishMessageCount ?? 0;
        this.transferRequestCount = options?.transferRequestCount ?? 0;
        this.transferredToAltClientCount = options?.transferredToAltClientCount ?? 0;
        this.transferredToSameClientCount = options?.transferredToSameClientCount ?? 0;
        this.publishRequestCount = options?.publishRequestCount ?? 0;
        this.dataChangeNotificationsCount = options?.dataChangeNotificationsCount ?? 0;
        this.eventNotificationsCount = options?.eventNotificationsCount ?? 0;
        this.notificationsCount = options?.notificationsCount ?? 0;
        this.latePublishRequestCount = options?.latePublishRequestCount ?? 0;
        this.currentKeepAliveCount = options?.currentKeepAliveCount ?? 0;
        this.currentLifetimeCount = options?.currentLifetimeCount ?? 0;
        this.unacknowledgedMessageCount = options?.unacknowledgedMessageCount ?? 0;
        this.discardedMessageCount = options?.discardedMessageCount ?? 0;
        this.monitoredItemCount = options?.monitoredItemCount ?? 0;
        this.disabledMonitoredItemCount = options?.disabledMonitoredItemCount ?? 0;
        this.monitoringQueueOverflowCount = options?.monitoringQueueOverflowCount ?? 0;
        this.nextSequenceNumber = options?.nextSequenceNumber ?? 0;
        this.eventQueueOverFlowCount = options?.eventQueueOverFlowCount ?? 0;
    }
    static [typeId] = NodeIds.SubscriptionDiagnosticsDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeByte(this.priority);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeUInt32(this.maxKeepAliveCount);
        encoder.writeUInt32(this.maxLifetimeCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeUInt32(this.modifyCount);
        encoder.writeUInt32(this.enableCount);
        encoder.writeUInt32(this.disableCount);
        encoder.writeUInt32(this.republishRequestCount);
        encoder.writeUInt32(this.republishMessageRequestCount);
        encoder.writeUInt32(this.republishMessageCount);
        encoder.writeUInt32(this.transferRequestCount);
        encoder.writeUInt32(this.transferredToAltClientCount);
        encoder.writeUInt32(this.transferredToSameClientCount);
        encoder.writeUInt32(this.publishRequestCount);
        encoder.writeUInt32(this.dataChangeNotificationsCount);
        encoder.writeUInt32(this.eventNotificationsCount);
        encoder.writeUInt32(this.notificationsCount);
        encoder.writeUInt32(this.latePublishRequestCount);
        encoder.writeUInt32(this.currentKeepAliveCount);
        encoder.writeUInt32(this.currentLifetimeCount);
        encoder.writeUInt32(this.unacknowledgedMessageCount);
        encoder.writeUInt32(this.discardedMessageCount);
        encoder.writeUInt32(this.monitoredItemCount);
        encoder.writeUInt32(this.disabledMonitoredItemCount);
        encoder.writeUInt32(this.monitoringQueueOverflowCount);
        encoder.writeUInt32(this.nextSequenceNumber);
        encoder.writeUInt32(this.eventQueueOverFlowCount);
    }
    static [decode](decoder: BinaryDataDecoder): SubscriptionDiagnosticsDataType {
        const sessionId = decoder.readType(NodeId);
        const subscriptionId = decoder.readUInt32();
        const priority = decoder.readByte();
        const publishingInterval = decoder.readDouble();
        const maxKeepAliveCount = decoder.readUInt32();
        const maxLifetimeCount = decoder.readUInt32();
        const maxNotificationsPerPublish = decoder.readUInt32();
        const publishingEnabled = decoder.readBoolean();
        const modifyCount = decoder.readUInt32();
        const enableCount = decoder.readUInt32();
        const disableCount = decoder.readUInt32();
        const republishRequestCount = decoder.readUInt32();
        const republishMessageRequestCount = decoder.readUInt32();
        const republishMessageCount = decoder.readUInt32();
        const transferRequestCount = decoder.readUInt32();
        const transferredToAltClientCount = decoder.readUInt32();
        const transferredToSameClientCount = decoder.readUInt32();
        const publishRequestCount = decoder.readUInt32();
        const dataChangeNotificationsCount = decoder.readUInt32();
        const eventNotificationsCount = decoder.readUInt32();
        const notificationsCount = decoder.readUInt32();
        const latePublishRequestCount = decoder.readUInt32();
        const currentKeepAliveCount = decoder.readUInt32();
        const currentLifetimeCount = decoder.readUInt32();
        const unacknowledgedMessageCount = decoder.readUInt32();
        const discardedMessageCount = decoder.readUInt32();
        const monitoredItemCount = decoder.readUInt32();
        const disabledMonitoredItemCount = decoder.readUInt32();
        const monitoringQueueOverflowCount = decoder.readUInt32();
        const nextSequenceNumber = decoder.readUInt32();
        const eventQueueOverFlowCount = decoder.readUInt32();
        return new SubscriptionDiagnosticsDataType({
            sessionId,
            subscriptionId,
            priority,
            publishingInterval,
            maxKeepAliveCount,
            maxLifetimeCount,
            maxNotificationsPerPublish,
            publishingEnabled,
            modifyCount,
            enableCount,
            disableCount,
            republishRequestCount,
            republishMessageRequestCount,
            republishMessageCount,
            transferRequestCount,
            transferredToAltClientCount,
            transferredToSameClientCount,
            publishRequestCount,
            dataChangeNotificationsCount,
            eventNotificationsCount,
            notificationsCount,
            latePublishRequestCount,
            currentKeepAliveCount,
            currentLifetimeCount,
            unacknowledgedMessageCount,
            discardedMessageCount,
            monitoredItemCount,
            disabledMonitoredItemCount,
            monitoringQueueOverflowCount,
            nextSequenceNumber,
            eventQueueOverFlowCount
        });
    }
}
export enum ModelChangeStructureVerbMask {
    NodeAdded = 1,
    NodeDeleted = 2,
    ReferenceAdded = 4,
    ReferenceDeleted = 8,
    DataTypeChanged = 16
}
export interface ModelChangeStructureDataTypeOptions {
    affected?: NodeId;
    affectedType?: NodeId;
    verb?: Byte;
}
export class ModelChangeStructureDataType implements ModelChangeStructureDataTypeOptions {
    affected: NodeId;
    affectedType: NodeId;
    verb: Byte;
    constructor(options?: ModelChangeStructureDataTypeOptions) {
        this.affected = options?.affected ?? NodeId.null();
        this.affectedType = options?.affectedType ?? NodeId.null();
        this.verb = options?.verb ?? 0;
    }
    static [typeId] = NodeIds.ModelChangeStructureDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.affected);
        encoder.writeType(this.affectedType);
        encoder.writeByte(this.verb);
    }
    static [decode](decoder: BinaryDataDecoder): ModelChangeStructureDataType {
        const affected = decoder.readType(NodeId);
        const affectedType = decoder.readType(NodeId);
        const verb = decoder.readByte();
        return new ModelChangeStructureDataType({
            affected,
            affectedType,
            verb
        });
    }
}
export interface SemanticChangeStructureDataTypeOptions {
    affected?: NodeId;
    affectedType?: NodeId;
}
export class SemanticChangeStructureDataType implements SemanticChangeStructureDataTypeOptions {
    affected: NodeId;
    affectedType: NodeId;
    constructor(options?: SemanticChangeStructureDataTypeOptions) {
        this.affected = options?.affected ?? NodeId.null();
        this.affectedType = options?.affectedType ?? NodeId.null();
    }
    static [typeId] = NodeIds.SemanticChangeStructureDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.affected);
        encoder.writeType(this.affectedType);
    }
    static [decode](decoder: BinaryDataDecoder): SemanticChangeStructureDataType {
        const affected = decoder.readType(NodeId);
        const affectedType = decoder.readType(NodeId);
        return new SemanticChangeStructureDataType({
            affected,
            affectedType
        });
    }
}
export interface RangeOptions {
    low?: Double;
    high?: Double;
}
export class Range implements RangeOptions {
    low: Double;
    high: Double;
    constructor(options?: RangeOptions) {
        this.low = options?.low ?? 0;
        this.high = options?.high ?? 0;
    }
    static [typeId] = NodeIds.Range_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.low);
        encoder.writeDouble(this.high);
    }
    static [decode](decoder: BinaryDataDecoder): Range {
        const low = decoder.readDouble();
        const high = decoder.readDouble();
        return new Range({
            low,
            high
        });
    }
}
export interface EUInformationOptions {
    namespaceUri?: UaString;
    unitId?: Int32;
    displayName?: LocalizedText;
    description?: LocalizedText;
}
export class EUInformation implements EUInformationOptions {
    namespaceUri?: UaString;
    unitId: Int32;
    displayName: LocalizedText;
    description: LocalizedText;
    constructor(options?: EUInformationOptions) {
        this.namespaceUri = options?.namespaceUri;
        this.unitId = options?.unitId ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.EUInformation_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.namespaceUri);
        encoder.writeInt32(this.unitId);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): EUInformation {
        const namespaceUri = decoder.readString();
        const unitId = decoder.readInt32();
        const displayName = decoder.readType(LocalizedText);
        const description = decoder.readType(LocalizedText);
        return new EUInformation({
            namespaceUri,
            unitId,
            displayName,
            description
        });
    }
}
export enum AxisScaleEnumeration {
    Linear = 0,
    Log = 1,
    Ln = 2
}
export interface ComplexNumberTypeOptions {
    real?: Float;
    imaginary?: Float;
}
export class ComplexNumberType implements ComplexNumberTypeOptions {
    real: Float;
    imaginary: Float;
    constructor(options?: ComplexNumberTypeOptions) {
        this.real = options?.real ?? 0;
        this.imaginary = options?.imaginary ?? 0;
    }
    static [typeId] = NodeIds.ComplexNumberType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeFloat(this.real);
        encoder.writeFloat(this.imaginary);
    }
    static [decode](decoder: BinaryDataDecoder): ComplexNumberType {
        const real = decoder.readFloat();
        const imaginary = decoder.readFloat();
        return new ComplexNumberType({
            real,
            imaginary
        });
    }
}
export interface DoubleComplexNumberTypeOptions {
    real?: Double;
    imaginary?: Double;
}
export class DoubleComplexNumberType implements DoubleComplexNumberTypeOptions {
    real: Double;
    imaginary: Double;
    constructor(options?: DoubleComplexNumberTypeOptions) {
        this.real = options?.real ?? 0;
        this.imaginary = options?.imaginary ?? 0;
    }
    static [typeId] = NodeIds.DoubleComplexNumberType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.real);
        encoder.writeDouble(this.imaginary);
    }
    static [decode](decoder: BinaryDataDecoder): DoubleComplexNumberType {
        const real = decoder.readDouble();
        const imaginary = decoder.readDouble();
        return new DoubleComplexNumberType({
            real,
            imaginary
        });
    }
}
export interface AxisInformationOptions {
    engineeringUnits?: EUInformation;
    euRange?: Range;
    title?: LocalizedText;
    axisScaleType?: AxisScaleEnumeration;
    axisSteps?: Double[];
}
export class AxisInformation implements AxisInformationOptions {
    engineeringUnits: EUInformation;
    euRange: Range;
    title: LocalizedText;
    axisScaleType: AxisScaleEnumeration;
    axisSteps?: Double[];
    constructor(options?: AxisInformationOptions) {
        this.engineeringUnits = options?.engineeringUnits ?? new EUInformation();
        this.euRange = options?.euRange ?? new Range();
        this.title = options?.title ?? new LocalizedText();
        this.axisScaleType = options?.axisScaleType ?? AxisScaleEnumeration.Linear;
        this.axisSteps = options?.axisSteps;
    }
    static [typeId] = NodeIds.AxisInformation_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.engineeringUnits);
        encoder.writeType(this.euRange);
        encoder.writeType(this.title);
        encoder.writeUInt32(this.axisScaleType);
        encoder.writeDoubleArray(this.axisSteps);
    }
    static [decode](decoder: BinaryDataDecoder): AxisInformation {
        const engineeringUnits = decoder.readType(EUInformation);
        const euRange = decoder.readType(Range);
        const title = decoder.readType(LocalizedText);
        const axisScaleType = decoder.readUInt32();
        const axisSteps = decoder.readDoubleArray();
        return new AxisInformation({
            engineeringUnits,
            euRange,
            title,
            axisScaleType,
            axisSteps
        });
    }
}
export interface XVTypeOptions {
    x?: Double;
    value?: Float;
}
export class XVType implements XVTypeOptions {
    x: Double;
    value: Float;
    constructor(options?: XVTypeOptions) {
        this.x = options?.x ?? 0;
        this.value = options?.value ?? 0;
    }
    static [typeId] = NodeIds.XVType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeFloat(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): XVType {
        const x = decoder.readDouble();
        const value = decoder.readFloat();
        return new XVType({
            x,
            value
        });
    }
}
export interface ProgramDiagnosticDataTypeOptions {
    createSessionId?: NodeId;
    createClientName?: UaString;
    invocationCreationTime?: Date;
    lastTransitionTime?: Date;
    lastMethodCall?: UaString;
    lastMethodSessionId?: NodeId;
    lastMethodInputArguments?: Argument[];
    lastMethodOutputArguments?: Argument[];
    lastMethodCallTime?: Date;
    lastMethodReturnStatus?: StatusResult;
}
export class ProgramDiagnosticDataType implements ProgramDiagnosticDataTypeOptions {
    createSessionId: NodeId;
    createClientName?: UaString;
    invocationCreationTime: Date;
    lastTransitionTime: Date;
    lastMethodCall?: UaString;
    lastMethodSessionId: NodeId;
    lastMethodInputArguments?: Argument[];
    lastMethodOutputArguments?: Argument[];
    lastMethodCallTime: Date;
    lastMethodReturnStatus: StatusResult;
    constructor(options?: ProgramDiagnosticDataTypeOptions) {
        this.createSessionId = options?.createSessionId ?? NodeId.null();
        this.createClientName = options?.createClientName;
        this.invocationCreationTime = options?.invocationCreationTime ?? new Date(-11644473600000);
        this.lastTransitionTime = options?.lastTransitionTime ?? new Date(-11644473600000);
        this.lastMethodCall = options?.lastMethodCall;
        this.lastMethodSessionId = options?.lastMethodSessionId ?? NodeId.null();
        this.lastMethodInputArguments = options?.lastMethodInputArguments;
        this.lastMethodOutputArguments = options?.lastMethodOutputArguments;
        this.lastMethodCallTime = options?.lastMethodCallTime ?? new Date(-11644473600000);
        this.lastMethodReturnStatus = options?.lastMethodReturnStatus ?? new StatusResult();
    }
    static [typeId] = NodeIds.ProgramDiagnosticDataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.createSessionId);
        encoder.writeString(this.createClientName);
        encoder.writeDateTime(this.invocationCreationTime);
        encoder.writeDateTime(this.lastTransitionTime);
        encoder.writeString(this.lastMethodCall);
        encoder.writeType(this.lastMethodSessionId);
        encoder.writeTypeArray(this.lastMethodInputArguments);
        encoder.writeTypeArray(this.lastMethodOutputArguments);
        encoder.writeDateTime(this.lastMethodCallTime);
        encoder.writeType(this.lastMethodReturnStatus);
    }
    static [decode](decoder: BinaryDataDecoder): ProgramDiagnosticDataType {
        const createSessionId = decoder.readType(NodeId);
        const createClientName = decoder.readString();
        const invocationCreationTime = decoder.readDateTime();
        const lastTransitionTime = decoder.readDateTime();
        const lastMethodCall = decoder.readString();
        const lastMethodSessionId = decoder.readType(NodeId);
        const lastMethodInputArguments = decoder.readTypeArray(Argument);
        const lastMethodOutputArguments = decoder.readTypeArray(Argument);
        const lastMethodCallTime = decoder.readDateTime();
        const lastMethodReturnStatus = decoder.readType(StatusResult);
        return new ProgramDiagnosticDataType({
            createSessionId,
            createClientName,
            invocationCreationTime,
            lastTransitionTime,
            lastMethodCall,
            lastMethodSessionId,
            lastMethodInputArguments,
            lastMethodOutputArguments,
            lastMethodCallTime,
            lastMethodReturnStatus
        });
    }
}
export interface ProgramDiagnostic2DataTypeOptions {
    createSessionId?: NodeId;
    createClientName?: UaString;
    invocationCreationTime?: Date;
    lastTransitionTime?: Date;
    lastMethodCall?: UaString;
    lastMethodSessionId?: NodeId;
    lastMethodInputArguments?: Argument[];
    lastMethodOutputArguments?: Argument[];
    lastMethodInputValues?: Variant[];
    lastMethodOutputValues?: Variant[];
    lastMethodCallTime?: Date;
    lastMethodReturnStatus?: StatusResult;
}
export class ProgramDiagnostic2DataType implements ProgramDiagnostic2DataTypeOptions {
    createSessionId: NodeId;
    createClientName?: UaString;
    invocationCreationTime: Date;
    lastTransitionTime: Date;
    lastMethodCall?: UaString;
    lastMethodSessionId: NodeId;
    lastMethodInputArguments?: Argument[];
    lastMethodOutputArguments?: Argument[];
    lastMethodInputValues?: Variant[];
    lastMethodOutputValues?: Variant[];
    lastMethodCallTime: Date;
    lastMethodReturnStatus: StatusResult;
    constructor(options?: ProgramDiagnostic2DataTypeOptions) {
        this.createSessionId = options?.createSessionId ?? NodeId.null();
        this.createClientName = options?.createClientName;
        this.invocationCreationTime = options?.invocationCreationTime ?? new Date(-11644473600000);
        this.lastTransitionTime = options?.lastTransitionTime ?? new Date(-11644473600000);
        this.lastMethodCall = options?.lastMethodCall;
        this.lastMethodSessionId = options?.lastMethodSessionId ?? NodeId.null();
        this.lastMethodInputArguments = options?.lastMethodInputArguments;
        this.lastMethodOutputArguments = options?.lastMethodOutputArguments;
        this.lastMethodInputValues = options?.lastMethodInputValues;
        this.lastMethodOutputValues = options?.lastMethodOutputValues;
        this.lastMethodCallTime = options?.lastMethodCallTime ?? new Date(-11644473600000);
        this.lastMethodReturnStatus = options?.lastMethodReturnStatus ?? new StatusResult();
    }
    static [typeId] = NodeIds.ProgramDiagnostic2DataType_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.createSessionId);
        encoder.writeString(this.createClientName);
        encoder.writeDateTime(this.invocationCreationTime);
        encoder.writeDateTime(this.lastTransitionTime);
        encoder.writeString(this.lastMethodCall);
        encoder.writeType(this.lastMethodSessionId);
        encoder.writeTypeArray(this.lastMethodInputArguments);
        encoder.writeTypeArray(this.lastMethodOutputArguments);
        encoder.writeTypeArray(this.lastMethodInputValues);
        encoder.writeTypeArray(this.lastMethodOutputValues);
        encoder.writeDateTime(this.lastMethodCallTime);
        encoder.writeType(this.lastMethodReturnStatus);
    }
    static [decode](decoder: BinaryDataDecoder): ProgramDiagnostic2DataType {
        const createSessionId = decoder.readType(NodeId);
        const createClientName = decoder.readString();
        const invocationCreationTime = decoder.readDateTime();
        const lastTransitionTime = decoder.readDateTime();
        const lastMethodCall = decoder.readString();
        const lastMethodSessionId = decoder.readType(NodeId);
        const lastMethodInputArguments = decoder.readTypeArray(Argument);
        const lastMethodOutputArguments = decoder.readTypeArray(Argument);
        const lastMethodInputValues = decoder.readTypeArray(Variant);
        const lastMethodOutputValues = decoder.readTypeArray(Variant);
        const lastMethodCallTime = decoder.readDateTime();
        const lastMethodReturnStatus = decoder.readType(StatusResult);
        return new ProgramDiagnostic2DataType({
            createSessionId,
            createClientName,
            invocationCreationTime,
            lastTransitionTime,
            lastMethodCall,
            lastMethodSessionId,
            lastMethodInputArguments,
            lastMethodOutputArguments,
            lastMethodInputValues,
            lastMethodOutputValues,
            lastMethodCallTime,
            lastMethodReturnStatus
        });
    }
}
export interface AnnotationOptions {
    message?: UaString;
    userName?: UaString;
    annotationTime?: Date;
}
export class Annotation implements AnnotationOptions {
    message?: UaString;
    userName?: UaString;
    annotationTime: Date;
    constructor(options?: AnnotationOptions) {
        this.message = options?.message;
        this.userName = options?.userName;
        this.annotationTime = options?.annotationTime ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.Annotation_Encoding_DefaultBinary;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.message);
        encoder.writeString(this.userName);
        encoder.writeDateTime(this.annotationTime);
    }
    static [decode](decoder: BinaryDataDecoder): Annotation {
        const message = decoder.readString();
        const userName = decoder.readString();
        const annotationTime = decoder.readDateTime();
        return new Annotation({
            message,
            userName,
            annotationTime
        });
    }
}
export enum ExceptionDeviationFormat {
    AbsoluteValue = 0,
    PercentOfValue = 1,
    PercentOfRange = 2,
    PercentOfEURange = 3,
    Unknown = 4
}
