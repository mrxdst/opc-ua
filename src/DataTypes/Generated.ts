// Autogenerated
/* eslint-disable @typescript-eslint/no-empty-function */
/* eslint-disable @typescript-eslint/no-unused-vars */
import { DataValue } from './DataValue';
import { DiagnosticInfo } from './DiagnosticInfo';
import { ExpandedNodeId } from './ExpandedNodeId';
import { ExtensionObject } from './ExtensionObject';
import { Guid } from './Guid';
import { LocalizedText } from './LocalizedText';
import { NodeId } from './NodeId';
import { NodeIds } from './NodeIds';
import { QualifiedName } from './QualifiedName';
import { Variant } from './Variant';
import { StatusCode } from './StatusCode';
import {
  SByte,
  Byte,
  Int16,
  UInt16,
  Int32,
  UInt32,
  Int64,
  Float,
  Double,
  UaString,
  ByteString
} from './Primitives';
import { BinaryDataEncoder, BinaryDataDecoder } from '../BinaryDataEncoding';
import { decode, encode, typeId } from '../symbols';
export enum NodeIdType {
    TwoByte = 0,
    FourByte = 1,
    Numeric = 2,
    String = 3,
    Guid = 4,
    ByteString = 5
}
export enum NamingRuleType {
    Mandatory = 1,
    Optional = 2,
    Constraint = 3
}
export interface KeyValuePairOptions {
    key?: QualifiedName | undefined;
    value?: Variant | undefined;
}
export class KeyValuePair implements KeyValuePairOptions {
    readonly key: QualifiedName;
    readonly value: Variant;
    constructor(options?: KeyValuePairOptions) {
        this.key = options?.key ?? new QualifiedName();
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.KeyValuePair_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.key);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): KeyValuePair {
        return new KeyValuePair({
            key: decoder.readType(QualifiedName),
            value: decoder.readType(Variant)
        });
    }
}
export interface AdditionalParametersTypeOptions {
    parameters?: KeyValuePair[] | undefined;
}
export class AdditionalParametersType implements AdditionalParametersTypeOptions {
    readonly parameters?: KeyValuePair[];
    constructor(options?: AdditionalParametersTypeOptions) {
        this.parameters = options?.parameters;
    }
    static [typeId] = NodeIds.AdditionalParametersType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.parameters);
    }
    static [decode](decoder: BinaryDataDecoder): AdditionalParametersType {
        return new AdditionalParametersType({
            parameters: decoder.readTypeArray(KeyValuePair)
        });
    }
}
export interface EphemeralKeyTypeOptions {
    publicKey?: ByteString | undefined;
    signature?: ByteString | undefined;
}
export class EphemeralKeyType implements EphemeralKeyTypeOptions {
    readonly publicKey?: ByteString;
    readonly signature?: ByteString;
    constructor(options?: EphemeralKeyTypeOptions) {
        this.publicKey = options?.publicKey;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.EphemeralKeyType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.publicKey);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): EphemeralKeyType {
        return new EphemeralKeyType({
            publicKey: decoder.readByteString(),
            signature: decoder.readByteString()
        });
    }
}
export interface EndpointTypeOptions {
    endpointUrl?: UaString | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityPolicyUri?: UaString | undefined;
    transportProfileUri?: UaString | undefined;
}
export class EndpointType implements EndpointTypeOptions {
    readonly endpointUrl?: UaString;
    readonly securityMode: MessageSecurityMode;
    readonly securityPolicyUri?: UaString;
    readonly transportProfileUri?: UaString;
    constructor(options?: EndpointTypeOptions) {
        this.endpointUrl = options?.endpointUrl;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.transportProfileUri = options?.transportProfileUri;
    }
    static [typeId] = NodeIds.EndpointType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.endpointUrl);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeString(this.transportProfileUri);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointType {
        return new EndpointType({
            endpointUrl: decoder.readString(),
            securityMode: decoder.readUInt32(),
            securityPolicyUri: decoder.readString(),
            transportProfileUri: decoder.readString()
        });
    }
}
export interface RationalNumberOptions {
    numerator?: Int32 | undefined;
    denominator?: UInt32 | undefined;
}
export class RationalNumber implements RationalNumberOptions {
    readonly numerator: Int32;
    readonly denominator: UInt32;
    constructor(options?: RationalNumberOptions) {
        this.numerator = options?.numerator ?? 0;
        this.denominator = options?.denominator ?? 0;
    }
    static [typeId] = NodeIds.RationalNumber_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt32(this.numerator);
        encoder.writeUInt32(this.denominator);
    }
    static [decode](decoder: BinaryDataDecoder): RationalNumber {
        return new RationalNumber({
            numerator: decoder.readInt32(),
            denominator: decoder.readUInt32()
        });
    }
}
export class Vector {
    static [typeId] = NodeIds.Vector_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Vector {
        return new Vector();
    }
}
export interface ThreeDVectorOptions {
    x?: Double | undefined;
    y?: Double | undefined;
    z?: Double | undefined;
}
export class ThreeDVector implements ThreeDVectorOptions {
    readonly x: Double;
    readonly y: Double;
    readonly z: Double;
    constructor(options?: ThreeDVectorOptions) {
        this.x = options?.x ?? 0;
        this.y = options?.y ?? 0;
        this.z = options?.z ?? 0;
    }
    static [typeId] = NodeIds.ThreeDVector_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeDouble(this.y);
        encoder.writeDouble(this.z);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDVector {
        return new ThreeDVector({
            x: decoder.readDouble(),
            y: decoder.readDouble(),
            z: decoder.readDouble()
        });
    }
}
export class CartesianCoordinates {
    static [typeId] = NodeIds.CartesianCoordinates_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): CartesianCoordinates {
        return new CartesianCoordinates();
    }
}
export interface ThreeDCartesianCoordinatesOptions {
    x?: Double | undefined;
    y?: Double | undefined;
    z?: Double | undefined;
}
export class ThreeDCartesianCoordinates implements ThreeDCartesianCoordinatesOptions {
    readonly x: Double;
    readonly y: Double;
    readonly z: Double;
    constructor(options?: ThreeDCartesianCoordinatesOptions) {
        this.x = options?.x ?? 0;
        this.y = options?.y ?? 0;
        this.z = options?.z ?? 0;
    }
    static [typeId] = NodeIds.ThreeDCartesianCoordinates_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeDouble(this.y);
        encoder.writeDouble(this.z);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDCartesianCoordinates {
        return new ThreeDCartesianCoordinates({
            x: decoder.readDouble(),
            y: decoder.readDouble(),
            z: decoder.readDouble()
        });
    }
}
export class Orientation {
    static [typeId] = NodeIds.Orientation_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Orientation {
        return new Orientation();
    }
}
export interface ThreeDOrientationOptions {
    a?: Double | undefined;
    b?: Double | undefined;
    c?: Double | undefined;
}
export class ThreeDOrientation implements ThreeDOrientationOptions {
    readonly a: Double;
    readonly b: Double;
    readonly c: Double;
    constructor(options?: ThreeDOrientationOptions) {
        this.a = options?.a ?? 0;
        this.b = options?.b ?? 0;
        this.c = options?.c ?? 0;
    }
    static [typeId] = NodeIds.ThreeDOrientation_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.a);
        encoder.writeDouble(this.b);
        encoder.writeDouble(this.c);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDOrientation {
        return new ThreeDOrientation({
            a: decoder.readDouble(),
            b: decoder.readDouble(),
            c: decoder.readDouble()
        });
    }
}
export class Frame {
    static [typeId] = NodeIds.Frame_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Frame {
        return new Frame();
    }
}
export interface ThreeDFrameOptions {
    cartesianCoordinates?: ThreeDCartesianCoordinates | undefined;
    orientation?: ThreeDOrientation | undefined;
}
export class ThreeDFrame implements ThreeDFrameOptions {
    readonly cartesianCoordinates: ThreeDCartesianCoordinates;
    readonly orientation: ThreeDOrientation;
    constructor(options?: ThreeDFrameOptions) {
        this.cartesianCoordinates = options?.cartesianCoordinates ?? new ThreeDCartesianCoordinates();
        this.orientation = options?.orientation ?? new ThreeDOrientation();
    }
    static [typeId] = NodeIds.ThreeDFrame_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.cartesianCoordinates);
        encoder.writeType(this.orientation);
    }
    static [decode](decoder: BinaryDataDecoder): ThreeDFrame {
        return new ThreeDFrame({
            cartesianCoordinates: decoder.readType(ThreeDCartesianCoordinates),
            orientation: decoder.readType(ThreeDOrientation)
        });
    }
}
export enum OpenFileMode {
    Read = 1,
    Write = 2,
    EraseExisting = 4,
    Append = 8
}
export enum IdentityCriteriaType {
    UserName = 1,
    Thumbprint = 2,
    Role = 3,
    GroupId = 4,
    Anonymous = 5,
    AuthenticatedUser = 6
}
export interface IdentityMappingRuleTypeOptions {
    criteriaType?: IdentityCriteriaType | undefined;
    criteria?: UaString | undefined;
}
export class IdentityMappingRuleType implements IdentityMappingRuleTypeOptions {
    readonly criteriaType: IdentityCriteriaType;
    readonly criteria?: UaString;
    constructor(options?: IdentityMappingRuleTypeOptions) {
        this.criteriaType = options?.criteriaType ?? IdentityCriteriaType.UserName;
        this.criteria = options?.criteria;
    }
    static [typeId] = NodeIds.IdentityMappingRuleType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.criteriaType);
        encoder.writeString(this.criteria);
    }
    static [decode](decoder: BinaryDataDecoder): IdentityMappingRuleType {
        return new IdentityMappingRuleType({
            criteriaType: decoder.readUInt32(),
            criteria: decoder.readString()
        });
    }
}
export interface CurrencyUnitTypeOptions {
    numericCode?: Int16 | undefined;
    exponent?: SByte | undefined;
    alphabeticCode?: UaString | undefined;
    currency?: LocalizedText | undefined;
}
export class CurrencyUnitType implements CurrencyUnitTypeOptions {
    readonly numericCode: Int16;
    readonly exponent: SByte;
    readonly alphabeticCode?: UaString;
    readonly currency: LocalizedText;
    constructor(options?: CurrencyUnitTypeOptions) {
        this.numericCode = options?.numericCode ?? 0;
        this.exponent = options?.exponent ?? 0;
        this.alphabeticCode = options?.alphabeticCode;
        this.currency = options?.currency ?? new LocalizedText();
    }
    static [typeId] = NodeIds.CurrencyUnitType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.numericCode);
        encoder.writeSByte(this.exponent);
        encoder.writeString(this.alphabeticCode);
        encoder.writeType(this.currency);
    }
    static [decode](decoder: BinaryDataDecoder): CurrencyUnitType {
        return new CurrencyUnitType({
            numericCode: decoder.readInt16(),
            exponent: decoder.readSByte(),
            alphabeticCode: decoder.readString(),
            currency: decoder.readType(LocalizedText)
        });
    }
}
export enum TrustListMasks {
    None = 0,
    TrustedCertificates = 1,
    TrustedCrls = 2,
    IssuerCertificates = 4,
    IssuerCrls = 8,
    All = 15
}
export interface TrustListDataTypeOptions {
    specifiedLists?: UInt32 | undefined;
    trustedCertificates?: ByteString[] | undefined;
    trustedCrls?: ByteString[] | undefined;
    issuerCertificates?: ByteString[] | undefined;
    issuerCrls?: ByteString[] | undefined;
}
export class TrustListDataType implements TrustListDataTypeOptions {
    readonly specifiedLists: UInt32;
    readonly trustedCertificates?: ByteString[];
    readonly trustedCrls?: ByteString[];
    readonly issuerCertificates?: ByteString[];
    readonly issuerCrls?: ByteString[];
    constructor(options?: TrustListDataTypeOptions) {
        this.specifiedLists = options?.specifiedLists ?? 0;
        this.trustedCertificates = options?.trustedCertificates;
        this.trustedCrls = options?.trustedCrls;
        this.issuerCertificates = options?.issuerCertificates;
        this.issuerCrls = options?.issuerCrls;
    }
    static [typeId] = NodeIds.TrustListDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedLists);
        encoder.writeByteStringArray(this.trustedCertificates);
        encoder.writeByteStringArray(this.trustedCrls);
        encoder.writeByteStringArray(this.issuerCertificates);
        encoder.writeByteStringArray(this.issuerCrls);
    }
    static [decode](decoder: BinaryDataDecoder): TrustListDataType {
        return new TrustListDataType({
            specifiedLists: decoder.readUInt32(),
            trustedCertificates: decoder.readByteStringArray(),
            trustedCrls: decoder.readByteStringArray(),
            issuerCertificates: decoder.readByteStringArray(),
            issuerCrls: decoder.readByteStringArray()
        });
    }
}
export interface DecimalDataTypeOptions {
    scale?: Int16 | undefined;
    value?: ByteString | undefined;
}
export class DecimalDataType implements DecimalDataTypeOptions {
    readonly scale: Int16;
    readonly value?: ByteString;
    constructor(options?: DecimalDataTypeOptions) {
        this.scale = options?.scale ?? 0;
        this.value = options?.value;
    }
    static [typeId] = NodeIds.DecimalDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.scale);
        encoder.writeByteString(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): DecimalDataType {
        return new DecimalDataType({
            scale: decoder.readInt16(),
            value: decoder.readByteString()
        });
    }
}
export interface DataTypeSchemaHeaderOptions {
    namespaces?: UaString[] | undefined;
    structureDataTypes?: StructureDescription[] | undefined;
    enumDataTypes?: EnumDescription[] | undefined;
    simpleDataTypes?: SimpleTypeDescription[] | undefined;
}
export class DataTypeSchemaHeader implements DataTypeSchemaHeaderOptions {
    readonly namespaces?: UaString[];
    readonly structureDataTypes?: StructureDescription[];
    readonly enumDataTypes?: EnumDescription[];
    readonly simpleDataTypes?: SimpleTypeDescription[];
    constructor(options?: DataTypeSchemaHeaderOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
    }
    static [typeId] = NodeIds.DataTypeSchemaHeader_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeSchemaHeader {
        return new DataTypeSchemaHeader({
            namespaces: decoder.readStringArray(),
            structureDataTypes: decoder.readTypeArray(StructureDescription),
            enumDataTypes: decoder.readTypeArray(EnumDescription),
            simpleDataTypes: decoder.readTypeArray(SimpleTypeDescription)
        });
    }
}
export interface DataTypeDescriptionOptions {
    dataTypeId?: NodeId | undefined;
    name?: QualifiedName | undefined;
}
export class DataTypeDescription implements DataTypeDescriptionOptions {
    readonly dataTypeId: NodeId;
    readonly name: QualifiedName;
    constructor(options?: DataTypeDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
    }
    static [typeId] = NodeIds.DataTypeDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeDescription {
        return new DataTypeDescription({
            dataTypeId: decoder.readType(NodeId),
            name: decoder.readType(QualifiedName)
        });
    }
}
export interface StructureDescriptionOptions {
    dataTypeId?: NodeId | undefined;
    name?: QualifiedName | undefined;
    structureDefinition?: StructureDefinition | undefined;
}
export class StructureDescription implements StructureDescriptionOptions {
    readonly dataTypeId: NodeId;
    readonly name: QualifiedName;
    readonly structureDefinition: StructureDefinition;
    constructor(options?: StructureDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.structureDefinition = options?.structureDefinition ?? new StructureDefinition();
    }
    static [typeId] = NodeIds.StructureDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.structureDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): StructureDescription {
        return new StructureDescription({
            dataTypeId: decoder.readType(NodeId),
            name: decoder.readType(QualifiedName),
            structureDefinition: decoder.readType(StructureDefinition)
        });
    }
}
export interface EnumDescriptionOptions {
    dataTypeId?: NodeId | undefined;
    name?: QualifiedName | undefined;
    enumDefinition?: EnumDefinition | undefined;
    builtInType?: Byte | undefined;
}
export class EnumDescription implements EnumDescriptionOptions {
    readonly dataTypeId: NodeId;
    readonly name: QualifiedName;
    readonly enumDefinition: EnumDefinition;
    readonly builtInType: Byte;
    constructor(options?: EnumDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.enumDefinition = options?.enumDefinition ?? new EnumDefinition();
        this.builtInType = options?.builtInType ?? 0;
    }
    static [typeId] = NodeIds.EnumDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.enumDefinition);
        encoder.writeByte(this.builtInType);
    }
    static [decode](decoder: BinaryDataDecoder): EnumDescription {
        return new EnumDescription({
            dataTypeId: decoder.readType(NodeId),
            name: decoder.readType(QualifiedName),
            enumDefinition: decoder.readType(EnumDefinition),
            builtInType: decoder.readByte()
        });
    }
}
export interface SimpleTypeDescriptionOptions {
    dataTypeId?: NodeId | undefined;
    name?: QualifiedName | undefined;
    baseDataType?: NodeId | undefined;
    builtInType?: Byte | undefined;
}
export class SimpleTypeDescription implements SimpleTypeDescriptionOptions {
    readonly dataTypeId: NodeId;
    readonly name: QualifiedName;
    readonly baseDataType: NodeId;
    readonly builtInType: Byte;
    constructor(options?: SimpleTypeDescriptionOptions) {
        this.dataTypeId = options?.dataTypeId ?? NodeId.null();
        this.name = options?.name ?? new QualifiedName();
        this.baseDataType = options?.baseDataType ?? NodeId.null();
        this.builtInType = options?.builtInType ?? 0;
    }
    static [typeId] = NodeIds.SimpleTypeDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataTypeId);
        encoder.writeType(this.name);
        encoder.writeType(this.baseDataType);
        encoder.writeByte(this.builtInType);
    }
    static [decode](decoder: BinaryDataDecoder): SimpleTypeDescription {
        return new SimpleTypeDescription({
            dataTypeId: decoder.readType(NodeId),
            name: decoder.readType(QualifiedName),
            baseDataType: decoder.readType(NodeId),
            builtInType: decoder.readByte()
        });
    }
}
export interface UABinaryFileDataTypeOptions {
    namespaces?: UaString[] | undefined;
    structureDataTypes?: StructureDescription[] | undefined;
    enumDataTypes?: EnumDescription[] | undefined;
    simpleDataTypes?: SimpleTypeDescription[] | undefined;
    schemaLocation?: UaString | undefined;
    fileHeader?: KeyValuePair[] | undefined;
    body?: Variant | undefined;
}
export class UABinaryFileDataType implements UABinaryFileDataTypeOptions {
    readonly namespaces?: UaString[];
    readonly structureDataTypes?: StructureDescription[];
    readonly enumDataTypes?: EnumDescription[];
    readonly simpleDataTypes?: SimpleTypeDescription[];
    readonly schemaLocation?: UaString;
    readonly fileHeader?: KeyValuePair[];
    readonly body: Variant;
    constructor(options?: UABinaryFileDataTypeOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
        this.schemaLocation = options?.schemaLocation;
        this.fileHeader = options?.fileHeader;
        this.body = options?.body ?? Variant.null();
    }
    static [typeId] = NodeIds.UABinaryFileDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
        encoder.writeString(this.schemaLocation);
        encoder.writeTypeArray(this.fileHeader);
        encoder.writeType(this.body);
    }
    static [decode](decoder: BinaryDataDecoder): UABinaryFileDataType {
        return new UABinaryFileDataType({
            namespaces: decoder.readStringArray(),
            structureDataTypes: decoder.readTypeArray(StructureDescription),
            enumDataTypes: decoder.readTypeArray(EnumDescription),
            simpleDataTypes: decoder.readTypeArray(SimpleTypeDescription),
            schemaLocation: decoder.readString(),
            fileHeader: decoder.readTypeArray(KeyValuePair),
            body: decoder.readType(Variant)
        });
    }
}
export enum PubSubState {
    Disabled = 0,
    Paused = 1,
    Operational = 2,
    Error = 3
}
export interface DataSetMetaDataTypeOptions {
    namespaces?: UaString[] | undefined;
    structureDataTypes?: StructureDescription[] | undefined;
    enumDataTypes?: EnumDescription[] | undefined;
    simpleDataTypes?: SimpleTypeDescription[] | undefined;
    name?: UaString | undefined;
    description?: LocalizedText | undefined;
    fields?: FieldMetaData[] | undefined;
    dataSetClassId?: Guid | undefined;
    configurationVersion?: ConfigurationVersionDataType | undefined;
}
export class DataSetMetaDataType implements DataSetMetaDataTypeOptions {
    readonly namespaces?: UaString[];
    readonly structureDataTypes?: StructureDescription[];
    readonly enumDataTypes?: EnumDescription[];
    readonly simpleDataTypes?: SimpleTypeDescription[];
    readonly name?: UaString;
    readonly description: LocalizedText;
    readonly fields?: FieldMetaData[];
    readonly dataSetClassId: Guid;
    readonly configurationVersion: ConfigurationVersionDataType;
    constructor(options?: DataSetMetaDataTypeOptions) {
        this.namespaces = options?.namespaces;
        this.structureDataTypes = options?.structureDataTypes;
        this.enumDataTypes = options?.enumDataTypes;
        this.simpleDataTypes = options?.simpleDataTypes;
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.fields = options?.fields;
        this.dataSetClassId = options?.dataSetClassId ?? new Guid();
        this.configurationVersion = options?.configurationVersion ?? new ConfigurationVersionDataType();
    }
    static [typeId] = NodeIds.DataSetMetaDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaces);
        encoder.writeTypeArray(this.structureDataTypes);
        encoder.writeTypeArray(this.enumDataTypes);
        encoder.writeTypeArray(this.simpleDataTypes);
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeTypeArray(this.fields);
        encoder.writeType(this.dataSetClassId);
        encoder.writeType(this.configurationVersion);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetMetaDataType {
        return new DataSetMetaDataType({
            namespaces: decoder.readStringArray(),
            structureDataTypes: decoder.readTypeArray(StructureDescription),
            enumDataTypes: decoder.readTypeArray(EnumDescription),
            simpleDataTypes: decoder.readTypeArray(SimpleTypeDescription),
            name: decoder.readString(),
            description: decoder.readType(LocalizedText),
            fields: decoder.readTypeArray(FieldMetaData),
            dataSetClassId: decoder.readType(Guid),
            configurationVersion: decoder.readType(ConfigurationVersionDataType)
        });
    }
}
export interface FieldMetaDataOptions {
    name?: UaString | undefined;
    description?: LocalizedText | undefined;
    fieldFlags?: DataSetFieldFlags | undefined;
    builtInType?: Byte | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    maxStringLength?: UInt32 | undefined;
    dataSetFieldId?: Guid | undefined;
    properties?: KeyValuePair[] | undefined;
}
export class FieldMetaData implements FieldMetaDataOptions {
    readonly name?: UaString;
    readonly description: LocalizedText;
    readonly fieldFlags: DataSetFieldFlags;
    readonly builtInType: Byte;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly maxStringLength: UInt32;
    readonly dataSetFieldId: Guid;
    readonly properties?: KeyValuePair[];
    constructor(options?: FieldMetaDataOptions) {
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.fieldFlags = options?.fieldFlags ?? DataSetFieldFlags.None;
        this.builtInType = options?.builtInType ?? 0;
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.dataSetFieldId = options?.dataSetFieldId ?? new Guid();
        this.properties = options?.properties;
    }
    static [typeId] = NodeIds.FieldMetaData_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.fieldFlags);
        encoder.writeByte(this.builtInType);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeUInt32(this.maxStringLength);
        encoder.writeType(this.dataSetFieldId);
        encoder.writeTypeArray(this.properties);
    }
    static [decode](decoder: BinaryDataDecoder): FieldMetaData {
        return new FieldMetaData({
            name: decoder.readString(),
            description: decoder.readType(LocalizedText),
            fieldFlags: decoder.readUInt32(),
            builtInType: decoder.readByte(),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            maxStringLength: decoder.readUInt32(),
            dataSetFieldId: decoder.readType(Guid),
            properties: decoder.readTypeArray(KeyValuePair)
        });
    }
}
export enum DataSetFieldFlags {
    None = 0,
    PromotedField = 1
}
export interface ConfigurationVersionDataTypeOptions {
    majorVersion?: UInt32 | undefined;
    minorVersion?: UInt32 | undefined;
}
export class ConfigurationVersionDataType implements ConfigurationVersionDataTypeOptions {
    readonly majorVersion: UInt32;
    readonly minorVersion: UInt32;
    constructor(options?: ConfigurationVersionDataTypeOptions) {
        this.majorVersion = options?.majorVersion ?? 0;
        this.minorVersion = options?.minorVersion ?? 0;
    }
    static [typeId] = NodeIds.ConfigurationVersionDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.majorVersion);
        encoder.writeUInt32(this.minorVersion);
    }
    static [decode](decoder: BinaryDataDecoder): ConfigurationVersionDataType {
        return new ConfigurationVersionDataType({
            majorVersion: decoder.readUInt32(),
            minorVersion: decoder.readUInt32()
        });
    }
}
export interface PublishedDataSetDataTypeOptions {
    name?: UaString | undefined;
    dataSetFolder?: UaString[] | undefined;
    dataSetMetaData?: DataSetMetaDataType | undefined;
    extensionFields?: KeyValuePair[] | undefined;
    dataSetSource?: ExtensionObject | undefined;
}
export class PublishedDataSetDataType implements PublishedDataSetDataTypeOptions {
    readonly name?: UaString;
    readonly dataSetFolder?: UaString[];
    readonly dataSetMetaData: DataSetMetaDataType;
    readonly extensionFields?: KeyValuePair[];
    readonly dataSetSource: ExtensionObject;
    constructor(options?: PublishedDataSetDataTypeOptions) {
        this.name = options?.name;
        this.dataSetFolder = options?.dataSetFolder;
        this.dataSetMetaData = options?.dataSetMetaData ?? new DataSetMetaDataType();
        this.extensionFields = options?.extensionFields;
        this.dataSetSource = options?.dataSetSource ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.PublishedDataSetDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeStringArray(this.dataSetFolder);
        encoder.writeType(this.dataSetMetaData);
        encoder.writeTypeArray(this.extensionFields);
        encoder.writeType(this.dataSetSource);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataSetDataType {
        return new PublishedDataSetDataType({
            name: decoder.readString(),
            dataSetFolder: decoder.readStringArray(),
            dataSetMetaData: decoder.readType(DataSetMetaDataType),
            extensionFields: decoder.readTypeArray(KeyValuePair),
            dataSetSource: decoder.readType(ExtensionObject)
        });
    }
}
export class PublishedDataSetSourceDataType {
    static [typeId] = NodeIds.PublishedDataSetSourceDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataSetSourceDataType {
        return new PublishedDataSetSourceDataType();
    }
}
export interface PublishedVariableDataTypeOptions {
    publishedVariable?: NodeId | undefined;
    attributeId?: UInt32 | undefined;
    samplingIntervalHint?: Double | undefined;
    deadbandType?: UInt32 | undefined;
    deadbandValue?: Double | undefined;
    indexRange?: UaString | undefined;
    substituteValue?: Variant | undefined;
    metaDataProperties?: QualifiedName[] | undefined;
}
export class PublishedVariableDataType implements PublishedVariableDataTypeOptions {
    readonly publishedVariable: NodeId;
    readonly attributeId: UInt32;
    readonly samplingIntervalHint: Double;
    readonly deadbandType: UInt32;
    readonly deadbandValue: Double;
    readonly indexRange?: UaString;
    readonly substituteValue: Variant;
    readonly metaDataProperties?: QualifiedName[];
    constructor(options?: PublishedVariableDataTypeOptions) {
        this.publishedVariable = options?.publishedVariable ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.samplingIntervalHint = options?.samplingIntervalHint ?? 0;
        this.deadbandType = options?.deadbandType ?? 0;
        this.deadbandValue = options?.deadbandValue ?? 0;
        this.indexRange = options?.indexRange;
        this.substituteValue = options?.substituteValue ?? Variant.null();
        this.metaDataProperties = options?.metaDataProperties;
    }
    static [typeId] = NodeIds.PublishedVariableDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.publishedVariable);
        encoder.writeUInt32(this.attributeId);
        encoder.writeDouble(this.samplingIntervalHint);
        encoder.writeUInt32(this.deadbandType);
        encoder.writeDouble(this.deadbandValue);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.substituteValue);
        encoder.writeTypeArray(this.metaDataProperties);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedVariableDataType {
        return new PublishedVariableDataType({
            publishedVariable: decoder.readType(NodeId),
            attributeId: decoder.readUInt32(),
            samplingIntervalHint: decoder.readDouble(),
            deadbandType: decoder.readUInt32(),
            deadbandValue: decoder.readDouble(),
            indexRange: decoder.readString(),
            substituteValue: decoder.readType(Variant),
            metaDataProperties: decoder.readTypeArray(QualifiedName)
        });
    }
}
export interface PublishedDataItemsDataTypeOptions {
    publishedData?: PublishedVariableDataType[] | undefined;
}
export class PublishedDataItemsDataType implements PublishedDataItemsDataTypeOptions {
    readonly publishedData?: PublishedVariableDataType[];
    constructor(options?: PublishedDataItemsDataTypeOptions) {
        this.publishedData = options?.publishedData;
    }
    static [typeId] = NodeIds.PublishedDataItemsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.publishedData);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedDataItemsDataType {
        return new PublishedDataItemsDataType({
            publishedData: decoder.readTypeArray(PublishedVariableDataType)
        });
    }
}
export interface PublishedEventsDataTypeOptions {
    eventNotifier?: NodeId | undefined;
    selectedFields?: SimpleAttributeOperand[] | undefined;
    filter?: ContentFilter | undefined;
}
export class PublishedEventsDataType implements PublishedEventsDataTypeOptions {
    readonly eventNotifier: NodeId;
    readonly selectedFields?: SimpleAttributeOperand[];
    readonly filter: ContentFilter;
    constructor(options?: PublishedEventsDataTypeOptions) {
        this.eventNotifier = options?.eventNotifier ?? NodeId.null();
        this.selectedFields = options?.selectedFields;
        this.filter = options?.filter ?? new ContentFilter();
    }
    static [typeId] = NodeIds.PublishedEventsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.eventNotifier);
        encoder.writeTypeArray(this.selectedFields);
        encoder.writeType(this.filter);
    }
    static [decode](decoder: BinaryDataDecoder): PublishedEventsDataType {
        return new PublishedEventsDataType({
            eventNotifier: decoder.readType(NodeId),
            selectedFields: decoder.readTypeArray(SimpleAttributeOperand),
            filter: decoder.readType(ContentFilter)
        });
    }
}
export enum DataSetFieldContentMask {
    None = 0,
    StatusCode = 1,
    SourceTimestamp = 2,
    ServerTimestamp = 4,
    SourcePicoSeconds = 8,
    ServerPicoSeconds = 16,
    RawData = 32
}
export interface DataSetWriterDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    dataSetWriterId?: UInt16 | undefined;
    dataSetFieldContentMask?: DataSetFieldContentMask | undefined;
    keyFrameCount?: UInt32 | undefined;
    dataSetName?: UaString | undefined;
    dataSetWriterProperties?: KeyValuePair[] | undefined;
    transportSettings?: ExtensionObject | undefined;
    messageSettings?: ExtensionObject | undefined;
}
export class DataSetWriterDataType implements DataSetWriterDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly dataSetWriterId: UInt16;
    readonly dataSetFieldContentMask: DataSetFieldContentMask;
    readonly keyFrameCount: UInt32;
    readonly dataSetName?: UaString;
    readonly dataSetWriterProperties?: KeyValuePair[];
    readonly transportSettings: ExtensionObject;
    readonly messageSettings: ExtensionObject;
    constructor(options?: DataSetWriterDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.dataSetWriterId = options?.dataSetWriterId ?? 0;
        this.dataSetFieldContentMask = options?.dataSetFieldContentMask ?? DataSetFieldContentMask.None;
        this.keyFrameCount = options?.keyFrameCount ?? 0;
        this.dataSetName = options?.dataSetName;
        this.dataSetWriterProperties = options?.dataSetWriterProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataSetWriterDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt16(this.dataSetWriterId);
        encoder.writeUInt32(this.dataSetFieldContentMask);
        encoder.writeUInt32(this.keyFrameCount);
        encoder.writeString(this.dataSetName);
        encoder.writeTypeArray(this.dataSetWriterProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterDataType {
        return new DataSetWriterDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            dataSetWriterId: decoder.readUInt16(),
            dataSetFieldContentMask: decoder.readUInt32(),
            keyFrameCount: decoder.readUInt32(),
            dataSetName: decoder.readString(),
            dataSetWriterProperties: decoder.readTypeArray(KeyValuePair),
            transportSettings: decoder.readType(ExtensionObject),
            messageSettings: decoder.readType(ExtensionObject)
        });
    }
}
export class DataSetWriterTransportDataType {
    static [typeId] = NodeIds.DataSetWriterTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterTransportDataType {
        return new DataSetWriterTransportDataType();
    }
}
export class DataSetWriterMessageDataType {
    static [typeId] = NodeIds.DataSetWriterMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetWriterMessageDataType {
        return new DataSetWriterMessageDataType();
    }
}
export interface PubSubGroupDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityGroupId?: UaString | undefined;
    securityKeyServices?: EndpointDescription[] | undefined;
    maxNetworkMessageSize?: UInt32 | undefined;
    groupProperties?: KeyValuePair[] | undefined;
}
export class PubSubGroupDataType implements PubSubGroupDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly securityMode: MessageSecurityMode;
    readonly securityGroupId?: UaString;
    readonly securityKeyServices?: EndpointDescription[];
    readonly maxNetworkMessageSize: UInt32;
    readonly groupProperties?: KeyValuePair[];
    constructor(options?: PubSubGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
    }
    static [typeId] = NodeIds.PubSubGroupDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubGroupDataType {
        return new PubSubGroupDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            securityMode: decoder.readUInt32(),
            securityGroupId: decoder.readString(),
            securityKeyServices: decoder.readTypeArray(EndpointDescription),
            maxNetworkMessageSize: decoder.readUInt32(),
            groupProperties: decoder.readTypeArray(KeyValuePair)
        });
    }
}
export interface WriterGroupDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityGroupId?: UaString | undefined;
    securityKeyServices?: EndpointDescription[] | undefined;
    maxNetworkMessageSize?: UInt32 | undefined;
    groupProperties?: KeyValuePair[] | undefined;
    writerGroupId?: UInt16 | undefined;
    publishingInterval?: Double | undefined;
    keepAliveTime?: Double | undefined;
    priority?: Byte | undefined;
    localeIds?: UaString[] | undefined;
    headerLayoutUri?: UaString | undefined;
    transportSettings?: ExtensionObject | undefined;
    messageSettings?: ExtensionObject | undefined;
    dataSetWriters?: DataSetWriterDataType[] | undefined;
}
export class WriterGroupDataType implements WriterGroupDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly securityMode: MessageSecurityMode;
    readonly securityGroupId?: UaString;
    readonly securityKeyServices?: EndpointDescription[];
    readonly maxNetworkMessageSize: UInt32;
    readonly groupProperties?: KeyValuePair[];
    readonly writerGroupId: UInt16;
    readonly publishingInterval: Double;
    readonly keepAliveTime: Double;
    readonly priority: Byte;
    readonly localeIds?: UaString[];
    readonly headerLayoutUri?: UaString;
    readonly transportSettings: ExtensionObject;
    readonly messageSettings: ExtensionObject;
    readonly dataSetWriters?: DataSetWriterDataType[];
    constructor(options?: WriterGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
        this.writerGroupId = options?.writerGroupId ?? 0;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.keepAliveTime = options?.keepAliveTime ?? 0;
        this.priority = options?.priority ?? 0;
        this.localeIds = options?.localeIds;
        this.headerLayoutUri = options?.headerLayoutUri;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.dataSetWriters = options?.dataSetWriters;
    }
    static [typeId] = NodeIds.WriterGroupDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
        encoder.writeUInt16(this.writerGroupId);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeDouble(this.keepAliveTime);
        encoder.writeByte(this.priority);
        encoder.writeStringArray(this.localeIds);
        encoder.writeString(this.headerLayoutUri);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeTypeArray(this.dataSetWriters);
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupDataType {
        return new WriterGroupDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            securityMode: decoder.readUInt32(),
            securityGroupId: decoder.readString(),
            securityKeyServices: decoder.readTypeArray(EndpointDescription),
            maxNetworkMessageSize: decoder.readUInt32(),
            groupProperties: decoder.readTypeArray(KeyValuePair),
            writerGroupId: decoder.readUInt16(),
            publishingInterval: decoder.readDouble(),
            keepAliveTime: decoder.readDouble(),
            priority: decoder.readByte(),
            localeIds: decoder.readStringArray(),
            headerLayoutUri: decoder.readString(),
            transportSettings: decoder.readType(ExtensionObject),
            messageSettings: decoder.readType(ExtensionObject),
            dataSetWriters: decoder.readTypeArray(DataSetWriterDataType)
        });
    }
}
export class WriterGroupTransportDataType {
    static [typeId] = NodeIds.WriterGroupTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupTransportDataType {
        return new WriterGroupTransportDataType();
    }
}
export class WriterGroupMessageDataType {
    static [typeId] = NodeIds.WriterGroupMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): WriterGroupMessageDataType {
        return new WriterGroupMessageDataType();
    }
}
export interface PubSubConnectionDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    publisherId?: Variant | undefined;
    transportProfileUri?: UaString | undefined;
    address?: ExtensionObject | undefined;
    connectionProperties?: KeyValuePair[] | undefined;
    transportSettings?: ExtensionObject | undefined;
    writerGroups?: WriterGroupDataType[] | undefined;
    readerGroups?: ReaderGroupDataType[] | undefined;
}
export class PubSubConnectionDataType implements PubSubConnectionDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly publisherId: Variant;
    readonly transportProfileUri?: UaString;
    readonly address: ExtensionObject;
    readonly connectionProperties?: KeyValuePair[];
    readonly transportSettings: ExtensionObject;
    readonly writerGroups?: WriterGroupDataType[];
    readonly readerGroups?: ReaderGroupDataType[];
    constructor(options?: PubSubConnectionDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.publisherId = options?.publisherId ?? Variant.null();
        this.transportProfileUri = options?.transportProfileUri;
        this.address = options?.address ?? new ExtensionObject();
        this.connectionProperties = options?.connectionProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.writerGroups = options?.writerGroups;
        this.readerGroups = options?.readerGroups;
    }
    static [typeId] = NodeIds.PubSubConnectionDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeType(this.publisherId);
        encoder.writeString(this.transportProfileUri);
        encoder.writeType(this.address);
        encoder.writeTypeArray(this.connectionProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeTypeArray(this.writerGroups);
        encoder.writeTypeArray(this.readerGroups);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubConnectionDataType {
        return new PubSubConnectionDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            publisherId: decoder.readType(Variant),
            transportProfileUri: decoder.readString(),
            address: decoder.readType(ExtensionObject),
            connectionProperties: decoder.readTypeArray(KeyValuePair),
            transportSettings: decoder.readType(ExtensionObject),
            writerGroups: decoder.readTypeArray(WriterGroupDataType),
            readerGroups: decoder.readTypeArray(ReaderGroupDataType)
        });
    }
}
export class ConnectionTransportDataType {
    static [typeId] = NodeIds.ConnectionTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ConnectionTransportDataType {
        return new ConnectionTransportDataType();
    }
}
export interface NetworkAddressDataTypeOptions {
    networkInterface?: UaString | undefined;
}
export class NetworkAddressDataType implements NetworkAddressDataTypeOptions {
    readonly networkInterface?: UaString;
    constructor(options?: NetworkAddressDataTypeOptions) {
        this.networkInterface = options?.networkInterface;
    }
    static [typeId] = NodeIds.NetworkAddressDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.networkInterface);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkAddressDataType {
        return new NetworkAddressDataType({
            networkInterface: decoder.readString()
        });
    }
}
export interface NetworkAddressUrlDataTypeOptions {
    networkInterface?: UaString | undefined;
    url?: UaString | undefined;
}
export class NetworkAddressUrlDataType implements NetworkAddressUrlDataTypeOptions {
    readonly networkInterface?: UaString;
    readonly url?: UaString;
    constructor(options?: NetworkAddressUrlDataTypeOptions) {
        this.networkInterface = options?.networkInterface;
        this.url = options?.url;
    }
    static [typeId] = NodeIds.NetworkAddressUrlDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.networkInterface);
        encoder.writeString(this.url);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkAddressUrlDataType {
        return new NetworkAddressUrlDataType({
            networkInterface: decoder.readString(),
            url: decoder.readString()
        });
    }
}
export interface ReaderGroupDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityGroupId?: UaString | undefined;
    securityKeyServices?: EndpointDescription[] | undefined;
    maxNetworkMessageSize?: UInt32 | undefined;
    groupProperties?: KeyValuePair[] | undefined;
    transportSettings?: ExtensionObject | undefined;
    messageSettings?: ExtensionObject | undefined;
    dataSetReaders?: DataSetReaderDataType[] | undefined;
}
export class ReaderGroupDataType implements ReaderGroupDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly securityMode: MessageSecurityMode;
    readonly securityGroupId?: UaString;
    readonly securityKeyServices?: EndpointDescription[];
    readonly maxNetworkMessageSize: UInt32;
    readonly groupProperties?: KeyValuePair[];
    readonly transportSettings: ExtensionObject;
    readonly messageSettings: ExtensionObject;
    readonly dataSetReaders?: DataSetReaderDataType[];
    constructor(options?: ReaderGroupDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.maxNetworkMessageSize = options?.maxNetworkMessageSize ?? 0;
        this.groupProperties = options?.groupProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.dataSetReaders = options?.dataSetReaders;
    }
    static [typeId] = NodeIds.ReaderGroupDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeUInt32(this.maxNetworkMessageSize);
        encoder.writeTypeArray(this.groupProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeTypeArray(this.dataSetReaders);
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupDataType {
        return new ReaderGroupDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            securityMode: decoder.readUInt32(),
            securityGroupId: decoder.readString(),
            securityKeyServices: decoder.readTypeArray(EndpointDescription),
            maxNetworkMessageSize: decoder.readUInt32(),
            groupProperties: decoder.readTypeArray(KeyValuePair),
            transportSettings: decoder.readType(ExtensionObject),
            messageSettings: decoder.readType(ExtensionObject),
            dataSetReaders: decoder.readTypeArray(DataSetReaderDataType)
        });
    }
}
export class ReaderGroupTransportDataType {
    static [typeId] = NodeIds.ReaderGroupTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupTransportDataType {
        return new ReaderGroupTransportDataType();
    }
}
export class ReaderGroupMessageDataType {
    static [typeId] = NodeIds.ReaderGroupMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): ReaderGroupMessageDataType {
        return new ReaderGroupMessageDataType();
    }
}
export interface DataSetReaderDataTypeOptions {
    name?: UaString | undefined;
    enabled?: boolean | undefined;
    publisherId?: Variant | undefined;
    writerGroupId?: UInt16 | undefined;
    dataSetWriterId?: UInt16 | undefined;
    dataSetMetaData?: DataSetMetaDataType | undefined;
    dataSetFieldContentMask?: DataSetFieldContentMask | undefined;
    messageReceiveTimeout?: Double | undefined;
    keyFrameCount?: UInt32 | undefined;
    headerLayoutUri?: UaString | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityGroupId?: UaString | undefined;
    securityKeyServices?: EndpointDescription[] | undefined;
    dataSetReaderProperties?: KeyValuePair[] | undefined;
    transportSettings?: ExtensionObject | undefined;
    messageSettings?: ExtensionObject | undefined;
    subscribedDataSet?: ExtensionObject | undefined;
}
export class DataSetReaderDataType implements DataSetReaderDataTypeOptions {
    readonly name?: UaString;
    readonly enabled: boolean;
    readonly publisherId: Variant;
    readonly writerGroupId: UInt16;
    readonly dataSetWriterId: UInt16;
    readonly dataSetMetaData: DataSetMetaDataType;
    readonly dataSetFieldContentMask: DataSetFieldContentMask;
    readonly messageReceiveTimeout: Double;
    readonly keyFrameCount: UInt32;
    readonly headerLayoutUri?: UaString;
    readonly securityMode: MessageSecurityMode;
    readonly securityGroupId?: UaString;
    readonly securityKeyServices?: EndpointDescription[];
    readonly dataSetReaderProperties?: KeyValuePair[];
    readonly transportSettings: ExtensionObject;
    readonly messageSettings: ExtensionObject;
    readonly subscribedDataSet: ExtensionObject;
    constructor(options?: DataSetReaderDataTypeOptions) {
        this.name = options?.name;
        this.enabled = options?.enabled ?? false;
        this.publisherId = options?.publisherId ?? Variant.null();
        this.writerGroupId = options?.writerGroupId ?? 0;
        this.dataSetWriterId = options?.dataSetWriterId ?? 0;
        this.dataSetMetaData = options?.dataSetMetaData ?? new DataSetMetaDataType();
        this.dataSetFieldContentMask = options?.dataSetFieldContentMask ?? DataSetFieldContentMask.None;
        this.messageReceiveTimeout = options?.messageReceiveTimeout ?? 0;
        this.keyFrameCount = options?.keyFrameCount ?? 0;
        this.headerLayoutUri = options?.headerLayoutUri;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityGroupId = options?.securityGroupId;
        this.securityKeyServices = options?.securityKeyServices;
        this.dataSetReaderProperties = options?.dataSetReaderProperties;
        this.transportSettings = options?.transportSettings ?? new ExtensionObject();
        this.messageSettings = options?.messageSettings ?? new ExtensionObject();
        this.subscribedDataSet = options?.subscribedDataSet ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataSetReaderDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeBoolean(this.enabled);
        encoder.writeType(this.publisherId);
        encoder.writeUInt16(this.writerGroupId);
        encoder.writeUInt16(this.dataSetWriterId);
        encoder.writeType(this.dataSetMetaData);
        encoder.writeUInt32(this.dataSetFieldContentMask);
        encoder.writeDouble(this.messageReceiveTimeout);
        encoder.writeUInt32(this.keyFrameCount);
        encoder.writeString(this.headerLayoutUri);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityGroupId);
        encoder.writeTypeArray(this.securityKeyServices);
        encoder.writeTypeArray(this.dataSetReaderProperties);
        encoder.writeType(this.transportSettings);
        encoder.writeType(this.messageSettings);
        encoder.writeType(this.subscribedDataSet);
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderDataType {
        return new DataSetReaderDataType({
            name: decoder.readString(),
            enabled: decoder.readBoolean(),
            publisherId: decoder.readType(Variant),
            writerGroupId: decoder.readUInt16(),
            dataSetWriterId: decoder.readUInt16(),
            dataSetMetaData: decoder.readType(DataSetMetaDataType),
            dataSetFieldContentMask: decoder.readUInt32(),
            messageReceiveTimeout: decoder.readDouble(),
            keyFrameCount: decoder.readUInt32(),
            headerLayoutUri: decoder.readString(),
            securityMode: decoder.readUInt32(),
            securityGroupId: decoder.readString(),
            securityKeyServices: decoder.readTypeArray(EndpointDescription),
            dataSetReaderProperties: decoder.readTypeArray(KeyValuePair),
            transportSettings: decoder.readType(ExtensionObject),
            messageSettings: decoder.readType(ExtensionObject),
            subscribedDataSet: decoder.readType(ExtensionObject)
        });
    }
}
export class DataSetReaderTransportDataType {
    static [typeId] = NodeIds.DataSetReaderTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderTransportDataType {
        return new DataSetReaderTransportDataType();
    }
}
export class DataSetReaderMessageDataType {
    static [typeId] = NodeIds.DataSetReaderMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DataSetReaderMessageDataType {
        return new DataSetReaderMessageDataType();
    }
}
export class SubscribedDataSetDataType {
    static [typeId] = NodeIds.SubscribedDataSetDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): SubscribedDataSetDataType {
        return new SubscribedDataSetDataType();
    }
}
export interface TargetVariablesDataTypeOptions {
    targetVariables?: FieldTargetDataType[] | undefined;
}
export class TargetVariablesDataType implements TargetVariablesDataTypeOptions {
    readonly targetVariables?: FieldTargetDataType[];
    constructor(options?: TargetVariablesDataTypeOptions) {
        this.targetVariables = options?.targetVariables;
    }
    static [typeId] = NodeIds.TargetVariablesDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.targetVariables);
    }
    static [decode](decoder: BinaryDataDecoder): TargetVariablesDataType {
        return new TargetVariablesDataType({
            targetVariables: decoder.readTypeArray(FieldTargetDataType)
        });
    }
}
export interface FieldTargetDataTypeOptions {
    dataSetFieldId?: Guid | undefined;
    receiverIndexRange?: UaString | undefined;
    targetNodeId?: NodeId | undefined;
    attributeId?: UInt32 | undefined;
    writeIndexRange?: UaString | undefined;
    overrideValueHandling?: OverrideValueHandling | undefined;
    overrideValue?: Variant | undefined;
}
export class FieldTargetDataType implements FieldTargetDataTypeOptions {
    readonly dataSetFieldId: Guid;
    readonly receiverIndexRange?: UaString;
    readonly targetNodeId: NodeId;
    readonly attributeId: UInt32;
    readonly writeIndexRange?: UaString;
    readonly overrideValueHandling: OverrideValueHandling;
    readonly overrideValue: Variant;
    constructor(options?: FieldTargetDataTypeOptions) {
        this.dataSetFieldId = options?.dataSetFieldId ?? new Guid();
        this.receiverIndexRange = options?.receiverIndexRange;
        this.targetNodeId = options?.targetNodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.writeIndexRange = options?.writeIndexRange;
        this.overrideValueHandling = options?.overrideValueHandling ?? OverrideValueHandling.Disabled;
        this.overrideValue = options?.overrideValue ?? Variant.null();
    }
    static [typeId] = NodeIds.FieldTargetDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.dataSetFieldId);
        encoder.writeString(this.receiverIndexRange);
        encoder.writeType(this.targetNodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.writeIndexRange);
        encoder.writeUInt32(this.overrideValueHandling);
        encoder.writeType(this.overrideValue);
    }
    static [decode](decoder: BinaryDataDecoder): FieldTargetDataType {
        return new FieldTargetDataType({
            dataSetFieldId: decoder.readType(Guid),
            receiverIndexRange: decoder.readString(),
            targetNodeId: decoder.readType(NodeId),
            attributeId: decoder.readUInt32(),
            writeIndexRange: decoder.readString(),
            overrideValueHandling: decoder.readUInt32(),
            overrideValue: decoder.readType(Variant)
        });
    }
}
export enum OverrideValueHandling {
    Disabled = 0,
    LastUsableValue = 1,
    OverrideValue = 2
}
export interface SubscribedDataSetMirrorDataTypeOptions {
    parentNodeName?: UaString | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
}
export class SubscribedDataSetMirrorDataType implements SubscribedDataSetMirrorDataTypeOptions {
    readonly parentNodeName?: UaString;
    readonly rolePermissions?: RolePermissionType[];
    constructor(options?: SubscribedDataSetMirrorDataTypeOptions) {
        this.parentNodeName = options?.parentNodeName;
        this.rolePermissions = options?.rolePermissions;
    }
    static [typeId] = NodeIds.SubscribedDataSetMirrorDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.parentNodeName);
        encoder.writeTypeArray(this.rolePermissions);
    }
    static [decode](decoder: BinaryDataDecoder): SubscribedDataSetMirrorDataType {
        return new SubscribedDataSetMirrorDataType({
            parentNodeName: decoder.readString(),
            rolePermissions: decoder.readTypeArray(RolePermissionType)
        });
    }
}
export interface PubSubConfigurationDataTypeOptions {
    publishedDataSets?: PublishedDataSetDataType[] | undefined;
    connections?: PubSubConnectionDataType[] | undefined;
    enabled?: boolean | undefined;
}
export class PubSubConfigurationDataType implements PubSubConfigurationDataTypeOptions {
    readonly publishedDataSets?: PublishedDataSetDataType[];
    readonly connections?: PubSubConnectionDataType[];
    readonly enabled: boolean;
    constructor(options?: PubSubConfigurationDataTypeOptions) {
        this.publishedDataSets = options?.publishedDataSets;
        this.connections = options?.connections;
        this.enabled = options?.enabled ?? false;
    }
    static [typeId] = NodeIds.PubSubConfigurationDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.publishedDataSets);
        encoder.writeTypeArray(this.connections);
        encoder.writeBoolean(this.enabled);
    }
    static [decode](decoder: BinaryDataDecoder): PubSubConfigurationDataType {
        return new PubSubConfigurationDataType({
            publishedDataSets: decoder.readTypeArray(PublishedDataSetDataType),
            connections: decoder.readTypeArray(PubSubConnectionDataType),
            enabled: decoder.readBoolean()
        });
    }
}
export enum DataSetOrderingType {
    Undefined = 0,
    AscendingWriterId = 1,
    AscendingWriterIdSingle = 2
}
export enum UadpNetworkMessageContentMask {
    None = 0,
    PublisherId = 1,
    GroupHeader = 2,
    WriterGroupId = 4,
    GroupVersion = 8,
    NetworkMessageNumber = 16,
    SequenceNumber = 32,
    PayloadHeader = 64,
    Timestamp = 128,
    PicoSeconds = 256,
    DataSetClassId = 512,
    PromotedFields = 1024
}
export interface UadpWriterGroupMessageDataTypeOptions {
    groupVersion?: UInt32 | undefined;
    dataSetOrdering?: DataSetOrderingType | undefined;
    networkMessageContentMask?: UadpNetworkMessageContentMask | undefined;
    samplingOffset?: Double | undefined;
    publishingOffset?: Double[] | undefined;
}
export class UadpWriterGroupMessageDataType implements UadpWriterGroupMessageDataTypeOptions {
    readonly groupVersion: UInt32;
    readonly dataSetOrdering: DataSetOrderingType;
    readonly networkMessageContentMask: UadpNetworkMessageContentMask;
    readonly samplingOffset: Double;
    readonly publishingOffset?: Double[];
    constructor(options?: UadpWriterGroupMessageDataTypeOptions) {
        this.groupVersion = options?.groupVersion ?? 0;
        this.dataSetOrdering = options?.dataSetOrdering ?? DataSetOrderingType.Undefined;
        this.networkMessageContentMask = options?.networkMessageContentMask ?? UadpNetworkMessageContentMask.None;
        this.samplingOffset = options?.samplingOffset ?? 0;
        this.publishingOffset = options?.publishingOffset;
    }
    static [typeId] = NodeIds.UadpWriterGroupMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.groupVersion);
        encoder.writeUInt32(this.dataSetOrdering);
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeDouble(this.samplingOffset);
        encoder.writeDoubleArray(this.publishingOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpWriterGroupMessageDataType {
        return new UadpWriterGroupMessageDataType({
            groupVersion: decoder.readUInt32(),
            dataSetOrdering: decoder.readUInt32(),
            networkMessageContentMask: decoder.readUInt32(),
            samplingOffset: decoder.readDouble(),
            publishingOffset: decoder.readDoubleArray()
        });
    }
}
export enum UadpDataSetMessageContentMask {
    None = 0,
    Timestamp = 1,
    PicoSeconds = 2,
    Status = 4,
    MajorVersion = 8,
    MinorVersion = 16,
    SequenceNumber = 32
}
export interface UadpDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask?: UadpDataSetMessageContentMask | undefined;
    configuredSize?: UInt16 | undefined;
    networkMessageNumber?: UInt16 | undefined;
    dataSetOffset?: UInt16 | undefined;
}
export class UadpDataSetWriterMessageDataType implements UadpDataSetWriterMessageDataTypeOptions {
    readonly dataSetMessageContentMask: UadpDataSetMessageContentMask;
    readonly configuredSize: UInt16;
    readonly networkMessageNumber: UInt16;
    readonly dataSetOffset: UInt16;
    constructor(options?: UadpDataSetWriterMessageDataTypeOptions) {
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? UadpDataSetMessageContentMask.None;
        this.configuredSize = options?.configuredSize ?? 0;
        this.networkMessageNumber = options?.networkMessageNumber ?? 0;
        this.dataSetOffset = options?.dataSetOffset ?? 0;
    }
    static [typeId] = NodeIds.UadpDataSetWriterMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.dataSetMessageContentMask);
        encoder.writeUInt16(this.configuredSize);
        encoder.writeUInt16(this.networkMessageNumber);
        encoder.writeUInt16(this.dataSetOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpDataSetWriterMessageDataType {
        return new UadpDataSetWriterMessageDataType({
            dataSetMessageContentMask: decoder.readUInt32(),
            configuredSize: decoder.readUInt16(),
            networkMessageNumber: decoder.readUInt16(),
            dataSetOffset: decoder.readUInt16()
        });
    }
}
export interface UadpDataSetReaderMessageDataTypeOptions {
    groupVersion?: UInt32 | undefined;
    networkMessageNumber?: UInt16 | undefined;
    dataSetOffset?: UInt16 | undefined;
    dataSetClassId?: Guid | undefined;
    networkMessageContentMask?: UadpNetworkMessageContentMask | undefined;
    dataSetMessageContentMask?: UadpDataSetMessageContentMask | undefined;
    publishingInterval?: Double | undefined;
    receiveOffset?: Double | undefined;
    processingOffset?: Double | undefined;
}
export class UadpDataSetReaderMessageDataType implements UadpDataSetReaderMessageDataTypeOptions {
    readonly groupVersion: UInt32;
    readonly networkMessageNumber: UInt16;
    readonly dataSetOffset: UInt16;
    readonly dataSetClassId: Guid;
    readonly networkMessageContentMask: UadpNetworkMessageContentMask;
    readonly dataSetMessageContentMask: UadpDataSetMessageContentMask;
    readonly publishingInterval: Double;
    readonly receiveOffset: Double;
    readonly processingOffset: Double;
    constructor(options?: UadpDataSetReaderMessageDataTypeOptions) {
        this.groupVersion = options?.groupVersion ?? 0;
        this.networkMessageNumber = options?.networkMessageNumber ?? 0;
        this.dataSetOffset = options?.dataSetOffset ?? 0;
        this.dataSetClassId = options?.dataSetClassId ?? new Guid();
        this.networkMessageContentMask = options?.networkMessageContentMask ?? UadpNetworkMessageContentMask.None;
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? UadpDataSetMessageContentMask.None;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.receiveOffset = options?.receiveOffset ?? 0;
        this.processingOffset = options?.processingOffset ?? 0;
    }
    static [typeId] = NodeIds.UadpDataSetReaderMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.groupVersion);
        encoder.writeUInt16(this.networkMessageNumber);
        encoder.writeUInt16(this.dataSetOffset);
        encoder.writeType(this.dataSetClassId);
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeUInt32(this.dataSetMessageContentMask);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeDouble(this.receiveOffset);
        encoder.writeDouble(this.processingOffset);
    }
    static [decode](decoder: BinaryDataDecoder): UadpDataSetReaderMessageDataType {
        return new UadpDataSetReaderMessageDataType({
            groupVersion: decoder.readUInt32(),
            networkMessageNumber: decoder.readUInt16(),
            dataSetOffset: decoder.readUInt16(),
            dataSetClassId: decoder.readType(Guid),
            networkMessageContentMask: decoder.readUInt32(),
            dataSetMessageContentMask: decoder.readUInt32(),
            publishingInterval: decoder.readDouble(),
            receiveOffset: decoder.readDouble(),
            processingOffset: decoder.readDouble()
        });
    }
}
export enum JsonNetworkMessageContentMask {
    None = 0,
    NetworkMessageHeader = 1,
    DataSetMessageHeader = 2,
    SingleDataSetMessage = 4,
    PublisherId = 8,
    DataSetClassId = 16,
    ReplyTo = 32
}
export interface JsonWriterGroupMessageDataTypeOptions {
    networkMessageContentMask?: JsonNetworkMessageContentMask | undefined;
}
export class JsonWriterGroupMessageDataType implements JsonWriterGroupMessageDataTypeOptions {
    readonly networkMessageContentMask: JsonNetworkMessageContentMask;
    constructor(options?: JsonWriterGroupMessageDataTypeOptions) {
        this.networkMessageContentMask = options?.networkMessageContentMask ?? JsonNetworkMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonWriterGroupMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.networkMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonWriterGroupMessageDataType {
        return new JsonWriterGroupMessageDataType({
            networkMessageContentMask: decoder.readUInt32()
        });
    }
}
export enum JsonDataSetMessageContentMask {
    None = 0,
    DataSetWriterId = 1,
    MetaDataVersion = 2,
    SequenceNumber = 4,
    Timestamp = 8,
    Status = 16
}
export interface JsonDataSetWriterMessageDataTypeOptions {
    dataSetMessageContentMask?: JsonDataSetMessageContentMask | undefined;
}
export class JsonDataSetWriterMessageDataType implements JsonDataSetWriterMessageDataTypeOptions {
    readonly dataSetMessageContentMask: JsonDataSetMessageContentMask;
    constructor(options?: JsonDataSetWriterMessageDataTypeOptions) {
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? JsonDataSetMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonDataSetWriterMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.dataSetMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonDataSetWriterMessageDataType {
        return new JsonDataSetWriterMessageDataType({
            dataSetMessageContentMask: decoder.readUInt32()
        });
    }
}
export interface JsonDataSetReaderMessageDataTypeOptions {
    networkMessageContentMask?: JsonNetworkMessageContentMask | undefined;
    dataSetMessageContentMask?: JsonDataSetMessageContentMask | undefined;
}
export class JsonDataSetReaderMessageDataType implements JsonDataSetReaderMessageDataTypeOptions {
    readonly networkMessageContentMask: JsonNetworkMessageContentMask;
    readonly dataSetMessageContentMask: JsonDataSetMessageContentMask;
    constructor(options?: JsonDataSetReaderMessageDataTypeOptions) {
        this.networkMessageContentMask = options?.networkMessageContentMask ?? JsonNetworkMessageContentMask.None;
        this.dataSetMessageContentMask = options?.dataSetMessageContentMask ?? JsonDataSetMessageContentMask.None;
    }
    static [typeId] = NodeIds.JsonDataSetReaderMessageDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.networkMessageContentMask);
        encoder.writeUInt32(this.dataSetMessageContentMask);
    }
    static [decode](decoder: BinaryDataDecoder): JsonDataSetReaderMessageDataType {
        return new JsonDataSetReaderMessageDataType({
            networkMessageContentMask: decoder.readUInt32(),
            dataSetMessageContentMask: decoder.readUInt32()
        });
    }
}
export interface DatagramConnectionTransportDataTypeOptions {
    discoveryAddress?: ExtensionObject | undefined;
}
export class DatagramConnectionTransportDataType implements DatagramConnectionTransportDataTypeOptions {
    readonly discoveryAddress: ExtensionObject;
    constructor(options?: DatagramConnectionTransportDataTypeOptions) {
        this.discoveryAddress = options?.discoveryAddress ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DatagramConnectionTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.discoveryAddress);
    }
    static [decode](decoder: BinaryDataDecoder): DatagramConnectionTransportDataType {
        return new DatagramConnectionTransportDataType({
            discoveryAddress: decoder.readType(ExtensionObject)
        });
    }
}
export interface DatagramWriterGroupTransportDataTypeOptions {
    messageRepeatCount?: Byte | undefined;
    messageRepeatDelay?: Double | undefined;
}
export class DatagramWriterGroupTransportDataType implements DatagramWriterGroupTransportDataTypeOptions {
    readonly messageRepeatCount: Byte;
    readonly messageRepeatDelay: Double;
    constructor(options?: DatagramWriterGroupTransportDataTypeOptions) {
        this.messageRepeatCount = options?.messageRepeatCount ?? 0;
        this.messageRepeatDelay = options?.messageRepeatDelay ?? 0;
    }
    static [typeId] = NodeIds.DatagramWriterGroupTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByte(this.messageRepeatCount);
        encoder.writeDouble(this.messageRepeatDelay);
    }
    static [decode](decoder: BinaryDataDecoder): DatagramWriterGroupTransportDataType {
        return new DatagramWriterGroupTransportDataType({
            messageRepeatCount: decoder.readByte(),
            messageRepeatDelay: decoder.readDouble()
        });
    }
}
export interface BrokerConnectionTransportDataTypeOptions {
    resourceUri?: UaString | undefined;
    authenticationProfileUri?: UaString | undefined;
}
export class BrokerConnectionTransportDataType implements BrokerConnectionTransportDataTypeOptions {
    readonly resourceUri?: UaString;
    readonly authenticationProfileUri?: UaString;
    constructor(options?: BrokerConnectionTransportDataTypeOptions) {
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
    }
    static [typeId] = NodeIds.BrokerConnectionTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerConnectionTransportDataType {
        return new BrokerConnectionTransportDataType({
            resourceUri: decoder.readString(),
            authenticationProfileUri: decoder.readString()
        });
    }
}
export enum BrokerTransportQualityOfService {
    NotSpecified = 0,
    BestEffort = 1,
    AtLeastOnce = 2,
    AtMostOnce = 3,
    ExactlyOnce = 4
}
export interface BrokerWriterGroupTransportDataTypeOptions {
    queueName?: UaString | undefined;
    resourceUri?: UaString | undefined;
    authenticationProfileUri?: UaString | undefined;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService | undefined;
}
export class BrokerWriterGroupTransportDataType implements BrokerWriterGroupTransportDataTypeOptions {
    readonly queueName?: UaString;
    readonly resourceUri?: UaString;
    readonly authenticationProfileUri?: UaString;
    readonly requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    constructor(options?: BrokerWriterGroupTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
    }
    static [typeId] = NodeIds.BrokerWriterGroupTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerWriterGroupTransportDataType {
        return new BrokerWriterGroupTransportDataType({
            queueName: decoder.readString(),
            resourceUri: decoder.readString(),
            authenticationProfileUri: decoder.readString(),
            requestedDeliveryGuarantee: decoder.readUInt32()
        });
    }
}
export interface BrokerDataSetWriterTransportDataTypeOptions {
    queueName?: UaString | undefined;
    resourceUri?: UaString | undefined;
    authenticationProfileUri?: UaString | undefined;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService | undefined;
    metaDataQueueName?: UaString | undefined;
    metaDataUpdateTime?: Double | undefined;
}
export class BrokerDataSetWriterTransportDataType implements BrokerDataSetWriterTransportDataTypeOptions {
    readonly queueName?: UaString;
    readonly resourceUri?: UaString;
    readonly authenticationProfileUri?: UaString;
    readonly requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    readonly metaDataQueueName?: UaString;
    readonly metaDataUpdateTime: Double;
    constructor(options?: BrokerDataSetWriterTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
        this.metaDataQueueName = options?.metaDataQueueName;
        this.metaDataUpdateTime = options?.metaDataUpdateTime ?? 0;
    }
    static [typeId] = NodeIds.BrokerDataSetWriterTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
        encoder.writeString(this.metaDataQueueName);
        encoder.writeDouble(this.metaDataUpdateTime);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerDataSetWriterTransportDataType {
        return new BrokerDataSetWriterTransportDataType({
            queueName: decoder.readString(),
            resourceUri: decoder.readString(),
            authenticationProfileUri: decoder.readString(),
            requestedDeliveryGuarantee: decoder.readUInt32(),
            metaDataQueueName: decoder.readString(),
            metaDataUpdateTime: decoder.readDouble()
        });
    }
}
export interface BrokerDataSetReaderTransportDataTypeOptions {
    queueName?: UaString | undefined;
    resourceUri?: UaString | undefined;
    authenticationProfileUri?: UaString | undefined;
    requestedDeliveryGuarantee?: BrokerTransportQualityOfService | undefined;
    metaDataQueueName?: UaString | undefined;
}
export class BrokerDataSetReaderTransportDataType implements BrokerDataSetReaderTransportDataTypeOptions {
    readonly queueName?: UaString;
    readonly resourceUri?: UaString;
    readonly authenticationProfileUri?: UaString;
    readonly requestedDeliveryGuarantee: BrokerTransportQualityOfService;
    readonly metaDataQueueName?: UaString;
    constructor(options?: BrokerDataSetReaderTransportDataTypeOptions) {
        this.queueName = options?.queueName;
        this.resourceUri = options?.resourceUri;
        this.authenticationProfileUri = options?.authenticationProfileUri;
        this.requestedDeliveryGuarantee = options?.requestedDeliveryGuarantee ?? BrokerTransportQualityOfService.NotSpecified;
        this.metaDataQueueName = options?.metaDataQueueName;
    }
    static [typeId] = NodeIds.BrokerDataSetReaderTransportDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.queueName);
        encoder.writeString(this.resourceUri);
        encoder.writeString(this.authenticationProfileUri);
        encoder.writeUInt32(this.requestedDeliveryGuarantee);
        encoder.writeString(this.metaDataQueueName);
    }
    static [decode](decoder: BinaryDataDecoder): BrokerDataSetReaderTransportDataType {
        return new BrokerDataSetReaderTransportDataType({
            queueName: decoder.readString(),
            resourceUri: decoder.readString(),
            authenticationProfileUri: decoder.readString(),
            requestedDeliveryGuarantee: decoder.readUInt32(),
            metaDataQueueName: decoder.readString()
        });
    }
}
export enum DiagnosticsLevel {
    Basic = 0,
    Advanced = 1,
    Info = 2,
    Log = 3,
    Debug = 4
}
export enum PubSubDiagnosticsCounterClassification {
    Information = 0,
    Error = 1
}
export interface AliasNameDataTypeOptions {
    aliasName?: QualifiedName | undefined;
    referencedNodes?: ExpandedNodeId[] | undefined;
}
export class AliasNameDataType implements AliasNameDataTypeOptions {
    readonly aliasName: QualifiedName;
    readonly referencedNodes?: ExpandedNodeId[];
    constructor(options?: AliasNameDataTypeOptions) {
        this.aliasName = options?.aliasName ?? new QualifiedName();
        this.referencedNodes = options?.referencedNodes;
    }
    static [typeId] = NodeIds.AliasNameDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.aliasName);
        encoder.writeTypeArray(this.referencedNodes);
    }
    static [decode](decoder: BinaryDataDecoder): AliasNameDataType {
        return new AliasNameDataType({
            aliasName: decoder.readType(QualifiedName),
            referencedNodes: decoder.readTypeArray(ExpandedNodeId)
        });
    }
}
export enum IdType {
    Numeric = 0,
    String = 1,
    Guid = 2,
    Opaque = 3
}
export enum NodeClass {
    Unspecified = 0,
    Object = 1,
    Variable = 2,
    Method = 4,
    ObjectType = 8,
    VariableType = 16,
    ReferenceType = 32,
    DataType = 64,
    View = 128
}
export enum PermissionType {
    None = 0,
    Browse = 1,
    ReadRolePermissions = 2,
    WriteAttribute = 4,
    WriteRolePermissions = 8,
    WriteHistorizing = 16,
    Read = 32,
    Write = 64,
    ReadHistory = 128,
    InsertHistory = 256,
    ModifyHistory = 512,
    DeleteHistory = 1024,
    ReceiveEvents = 2048,
    Call = 4096,
    AddReference = 8192,
    RemoveReference = 16384,
    DeleteNode = 32768,
    AddNode = 65536
}
export enum AccessLevelType {
    None = 0,
    CurrentRead = 1,
    CurrentWrite = 2,
    HistoryRead = 4,
    HistoryWrite = 8,
    SemanticChange = 16,
    StatusWrite = 32,
    TimestampWrite = 64
}
export enum AccessLevelExType {
    None = 0,
    CurrentRead = 1,
    CurrentWrite = 2,
    HistoryRead = 4,
    HistoryWrite = 8,
    SemanticChange = 16,
    StatusWrite = 32,
    TimestampWrite = 64,
    NonatomicRead = 256,
    NonatomicWrite = 512,
    WriteFullArrayOnly = 1024,
    NoSubDataTypes = 2048
}
export enum EventNotifierType {
    None = 0,
    SubscribeToEvents = 1,
    HistoryRead = 4,
    HistoryWrite = 8
}
export enum AccessRestrictionType {
    None = 0,
    SigningRequired = 1,
    EncryptionRequired = 2,
    SessionRequired = 4,
    ApplyRestrictionsToBrowse = 8
}
export interface RolePermissionTypeOptions {
    roleId?: NodeId | undefined;
    permissions?: PermissionType | undefined;
}
export class RolePermissionType implements RolePermissionTypeOptions {
    readonly roleId: NodeId;
    readonly permissions: PermissionType;
    constructor(options?: RolePermissionTypeOptions) {
        this.roleId = options?.roleId ?? NodeId.null();
        this.permissions = options?.permissions ?? PermissionType.None;
    }
    static [typeId] = NodeIds.RolePermissionType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.roleId);
        encoder.writeUInt32(this.permissions);
    }
    static [decode](decoder: BinaryDataDecoder): RolePermissionType {
        return new RolePermissionType({
            roleId: decoder.readType(NodeId),
            permissions: decoder.readUInt32()
        });
    }
}
export enum StructureType {
    Structure = 0,
    StructureWithOptionalFields = 1,
    Union = 2
}
export interface StructureFieldOptions {
    name?: UaString | undefined;
    description?: LocalizedText | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    maxStringLength?: UInt32 | undefined;
    isOptional?: boolean | undefined;
}
export class StructureField implements StructureFieldOptions {
    readonly name?: UaString;
    readonly description: LocalizedText;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly maxStringLength: UInt32;
    readonly isOptional: boolean;
    constructor(options?: StructureFieldOptions) {
        this.name = options?.name;
        this.description = options?.description ?? new LocalizedText();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.isOptional = options?.isOptional ?? false;
    }
    static [typeId] = NodeIds.StructureField_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.description);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeUInt32(this.maxStringLength);
        encoder.writeBoolean(this.isOptional);
    }
    static [decode](decoder: BinaryDataDecoder): StructureField {
        return new StructureField({
            name: decoder.readString(),
            description: decoder.readType(LocalizedText),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            maxStringLength: decoder.readUInt32(),
            isOptional: decoder.readBoolean()
        });
    }
}
export interface StructureDefinitionOptions {
    defaultEncodingId?: NodeId | undefined;
    baseDataType?: NodeId | undefined;
    structureType?: StructureType | undefined;
    fields?: StructureField[] | undefined;
}
export class StructureDefinition implements StructureDefinitionOptions {
    readonly defaultEncodingId: NodeId;
    readonly baseDataType: NodeId;
    readonly structureType: StructureType;
    readonly fields?: StructureField[];
    constructor(options?: StructureDefinitionOptions) {
        this.defaultEncodingId = options?.defaultEncodingId ?? NodeId.null();
        this.baseDataType = options?.baseDataType ?? NodeId.null();
        this.structureType = options?.structureType ?? StructureType.Structure;
        this.fields = options?.fields;
    }
    static [typeId] = NodeIds.StructureDefinition_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.defaultEncodingId);
        encoder.writeType(this.baseDataType);
        encoder.writeUInt32(this.structureType);
        encoder.writeTypeArray(this.fields);
    }
    static [decode](decoder: BinaryDataDecoder): StructureDefinition {
        return new StructureDefinition({
            defaultEncodingId: decoder.readType(NodeId),
            baseDataType: decoder.readType(NodeId),
            structureType: decoder.readUInt32(),
            fields: decoder.readTypeArray(StructureField)
        });
    }
}
export interface EnumDefinitionOptions {
    fields?: EnumField[] | undefined;
}
export class EnumDefinition implements EnumDefinitionOptions {
    readonly fields?: EnumField[];
    constructor(options?: EnumDefinitionOptions) {
        this.fields = options?.fields;
    }
    static [typeId] = NodeIds.EnumDefinition_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.fields);
    }
    static [decode](decoder: BinaryDataDecoder): EnumDefinition {
        return new EnumDefinition({
            fields: decoder.readTypeArray(EnumField)
        });
    }
}
export interface NodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
}
export class Node implements NodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    constructor(options?: NodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.Node_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): Node {
        return new Node({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode)
        });
    }
}
export interface InstanceNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
}
export class InstanceNode implements InstanceNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    constructor(options?: InstanceNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.InstanceNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): InstanceNode {
        return new InstanceNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode)
        });
    }
}
export interface TypeNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
}
export class TypeNode implements TypeNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    constructor(options?: TypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.TypeNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): TypeNode {
        return new TypeNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode)
        });
    }
}
export interface ObjectNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    eventNotifier?: Byte | undefined;
}
export class ObjectNode implements ObjectNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly eventNotifier: Byte;
    constructor(options?: ObjectNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ObjectNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectNode {
        return new ObjectNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            eventNotifier: decoder.readByte()
        });
    }
}
export interface ObjectTypeNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    isAbstract?: boolean | undefined;
}
export class ObjectTypeNode implements ObjectTypeNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly isAbstract: boolean;
    constructor(options?: ObjectTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.ObjectTypeNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectTypeNode {
        return new ObjectTypeNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            isAbstract: decoder.readBoolean()
        });
    }
}
export interface VariableNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    value?: Variant | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    accessLevel?: Byte | undefined;
    userAccessLevel?: Byte | undefined;
    minimumSamplingInterval?: Double | undefined;
    historizing?: boolean | undefined;
    accessLevelEx?: UInt32 | undefined;
}
export class VariableNode implements VariableNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly value: Variant;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly accessLevel: Byte;
    readonly userAccessLevel: Byte;
    readonly minimumSamplingInterval: Double;
    readonly historizing: boolean;
    readonly accessLevelEx: UInt32;
    constructor(options?: VariableNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.accessLevel = options?.accessLevel ?? 0;
        this.userAccessLevel = options?.userAccessLevel ?? 0;
        this.minimumSamplingInterval = options?.minimumSamplingInterval ?? 0;
        this.historizing = options?.historizing ?? false;
        this.accessLevelEx = options?.accessLevelEx ?? 0;
    }
    static [typeId] = NodeIds.VariableNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeByte(this.accessLevel);
        encoder.writeByte(this.userAccessLevel);
        encoder.writeDouble(this.minimumSamplingInterval);
        encoder.writeBoolean(this.historizing);
        encoder.writeUInt32(this.accessLevelEx);
    }
    static [decode](decoder: BinaryDataDecoder): VariableNode {
        return new VariableNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            value: decoder.readType(Variant),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            accessLevel: decoder.readByte(),
            userAccessLevel: decoder.readByte(),
            minimumSamplingInterval: decoder.readDouble(),
            historizing: decoder.readBoolean(),
            accessLevelEx: decoder.readUInt32()
        });
    }
}
export interface VariableTypeNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    value?: Variant | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    isAbstract?: boolean | undefined;
}
export class VariableTypeNode implements VariableTypeNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly value: Variant;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly isAbstract: boolean;
    constructor(options?: VariableTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.VariableTypeNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): VariableTypeNode {
        return new VariableTypeNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            value: decoder.readType(Variant),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            isAbstract: decoder.readBoolean()
        });
    }
}
export interface ReferenceTypeNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    isAbstract?: boolean | undefined;
    symmetric?: boolean | undefined;
    inverseName?: LocalizedText | undefined;
}
export class ReferenceTypeNode implements ReferenceTypeNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly isAbstract: boolean;
    readonly symmetric: boolean;
    readonly inverseName: LocalizedText;
    constructor(options?: ReferenceTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
        this.symmetric = options?.symmetric ?? false;
        this.inverseName = options?.inverseName ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ReferenceTypeNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeBoolean(this.symmetric);
        encoder.writeType(this.inverseName);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceTypeNode {
        return new ReferenceTypeNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            isAbstract: decoder.readBoolean(),
            symmetric: decoder.readBoolean(),
            inverseName: decoder.readType(LocalizedText)
        });
    }
}
export interface MethodNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    executable?: boolean | undefined;
    userExecutable?: boolean | undefined;
}
export class MethodNode implements MethodNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly executable: boolean;
    readonly userExecutable: boolean;
    constructor(options?: MethodNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.executable = options?.executable ?? false;
        this.userExecutable = options?.userExecutable ?? false;
    }
    static [typeId] = NodeIds.MethodNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.executable);
        encoder.writeBoolean(this.userExecutable);
    }
    static [decode](decoder: BinaryDataDecoder): MethodNode {
        return new MethodNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            executable: decoder.readBoolean(),
            userExecutable: decoder.readBoolean()
        });
    }
}
export interface ViewNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    containsNoLoops?: boolean | undefined;
    eventNotifier?: Byte | undefined;
}
export class ViewNode implements ViewNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly containsNoLoops: boolean;
    readonly eventNotifier: Byte;
    constructor(options?: ViewNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.containsNoLoops = options?.containsNoLoops ?? false;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ViewNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.containsNoLoops);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ViewNode {
        return new ViewNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            containsNoLoops: decoder.readBoolean(),
            eventNotifier: decoder.readByte()
        });
    }
}
export interface DataTypeNodeOptions {
    nodeId?: NodeId | undefined;
    nodeClass?: NodeClass | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    rolePermissions?: RolePermissionType[] | undefined;
    userRolePermissions?: RolePermissionType[] | undefined;
    accessRestrictions?: UInt16 | undefined;
    references?: ReferenceNode[] | undefined;
    isAbstract?: boolean | undefined;
    dataTypeDefinition?: ExtensionObject | undefined;
}
export class DataTypeNode implements DataTypeNodeOptions {
    readonly nodeId: NodeId;
    readonly nodeClass: NodeClass;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly rolePermissions?: RolePermissionType[];
    readonly userRolePermissions?: RolePermissionType[];
    readonly accessRestrictions: UInt16;
    readonly references?: ReferenceNode[];
    readonly isAbstract: boolean;
    readonly dataTypeDefinition: ExtensionObject;
    constructor(options?: DataTypeNodeOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.rolePermissions = options?.rolePermissions;
        this.userRolePermissions = options?.userRolePermissions;
        this.accessRestrictions = options?.accessRestrictions ?? 0;
        this.references = options?.references;
        this.isAbstract = options?.isAbstract ?? false;
        this.dataTypeDefinition = options?.dataTypeDefinition ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.DataTypeNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.rolePermissions);
        encoder.writeTypeArray(this.userRolePermissions);
        encoder.writeUInt16(this.accessRestrictions);
        encoder.writeTypeArray(this.references);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeType(this.dataTypeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeNode {
        return new DataTypeNode({
            nodeId: decoder.readType(NodeId),
            nodeClass: decoder.readUInt32(),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            rolePermissions: decoder.readTypeArray(RolePermissionType),
            userRolePermissions: decoder.readTypeArray(RolePermissionType),
            accessRestrictions: decoder.readUInt16(),
            references: decoder.readTypeArray(ReferenceNode),
            isAbstract: decoder.readBoolean(),
            dataTypeDefinition: decoder.readType(ExtensionObject)
        });
    }
}
export interface ReferenceNodeOptions {
    referenceTypeId?: NodeId | undefined;
    isInverse?: boolean | undefined;
    targetId?: ExpandedNodeId | undefined;
}
export class ReferenceNode implements ReferenceNodeOptions {
    readonly referenceTypeId: NodeId;
    readonly isInverse: boolean;
    readonly targetId: ExpandedNodeId;
    constructor(options?: ReferenceNodeOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isInverse = options?.isInverse ?? false;
        this.targetId = options?.targetId ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.ReferenceNode_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isInverse);
        encoder.writeType(this.targetId);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceNode {
        return new ReferenceNode({
            referenceTypeId: decoder.readType(NodeId),
            isInverse: decoder.readBoolean(),
            targetId: decoder.readType(ExpandedNodeId)
        });
    }
}
export interface ArgumentOptions {
    name?: UaString | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    description?: LocalizedText | undefined;
}
export class Argument implements ArgumentOptions {
    readonly name?: UaString;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly description: LocalizedText;
    constructor(options?: ArgumentOptions) {
        this.name = options?.name;
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.Argument_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.name);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): Argument {
        return new Argument({
            name: decoder.readString(),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            description: decoder.readType(LocalizedText)
        });
    }
}
export interface EnumValueTypeOptions {
    value?: Int64 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
}
export class EnumValueType implements EnumValueTypeOptions {
    readonly value: Int64;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    constructor(options?: EnumValueTypeOptions) {
        this.value = options?.value ?? BigInt(0);
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.EnumValueType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt64(this.value);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): EnumValueType {
        return new EnumValueType({
            value: decoder.readInt64(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText)
        });
    }
}
export interface EnumFieldOptions {
    value?: Int64 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    name?: UaString | undefined;
}
export class EnumField implements EnumFieldOptions {
    readonly value: Int64;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly name?: UaString;
    constructor(options?: EnumFieldOptions) {
        this.value = options?.value ?? BigInt(0);
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.name = options?.name;
    }
    static [typeId] = NodeIds.EnumField_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt64(this.value);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeString(this.name);
    }
    static [decode](decoder: BinaryDataDecoder): EnumField {
        return new EnumField({
            value: decoder.readInt64(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            name: decoder.readString()
        });
    }
}
export interface OptionSetOptions {
    value?: ByteString | undefined;
    validBits?: ByteString | undefined;
}
export class OptionSet implements OptionSetOptions {
    readonly value?: ByteString;
    readonly validBits?: ByteString;
    constructor(options?: OptionSetOptions) {
        this.value = options?.value;
        this.validBits = options?.validBits;
    }
    static [typeId] = NodeIds.OptionSet_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.value);
        encoder.writeByteString(this.validBits);
    }
    static [decode](decoder: BinaryDataDecoder): OptionSet {
        return new OptionSet({
            value: decoder.readByteString(),
            validBits: decoder.readByteString()
        });
    }
}
export class Union {
    static [typeId] = NodeIds.Union_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): Union {
        return new Union();
    }
}
export interface TimeZoneDataTypeOptions {
    offset?: Int16 | undefined;
    daylightSavingInOffset?: boolean | undefined;
}
export class TimeZoneDataType implements TimeZoneDataTypeOptions {
    readonly offset: Int16;
    readonly daylightSavingInOffset: boolean;
    constructor(options?: TimeZoneDataTypeOptions) {
        this.offset = options?.offset ?? 0;
        this.daylightSavingInOffset = options?.daylightSavingInOffset ?? false;
    }
    static [typeId] = NodeIds.TimeZoneDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt16(this.offset);
        encoder.writeBoolean(this.daylightSavingInOffset);
    }
    static [decode](decoder: BinaryDataDecoder): TimeZoneDataType {
        return new TimeZoneDataType({
            offset: decoder.readInt16(),
            daylightSavingInOffset: decoder.readBoolean()
        });
    }
}
export enum ApplicationType {
    Server = 0,
    Client = 1,
    ClientAndServer = 2,
    DiscoveryServer = 3
}
export interface ApplicationDescriptionOptions {
    applicationUri?: UaString | undefined;
    productUri?: UaString | undefined;
    applicationName?: LocalizedText | undefined;
    applicationType?: ApplicationType | undefined;
    gatewayServerUri?: UaString | undefined;
    discoveryProfileUri?: UaString | undefined;
    discoveryUrls?: UaString[] | undefined;
}
export class ApplicationDescription implements ApplicationDescriptionOptions {
    readonly applicationUri?: UaString;
    readonly productUri?: UaString;
    readonly applicationName: LocalizedText;
    readonly applicationType: ApplicationType;
    readonly gatewayServerUri?: UaString;
    readonly discoveryProfileUri?: UaString;
    readonly discoveryUrls?: UaString[];
    constructor(options?: ApplicationDescriptionOptions) {
        this.applicationUri = options?.applicationUri;
        this.productUri = options?.productUri;
        this.applicationName = options?.applicationName ?? new LocalizedText();
        this.applicationType = options?.applicationType ?? ApplicationType.Server;
        this.gatewayServerUri = options?.gatewayServerUri;
        this.discoveryProfileUri = options?.discoveryProfileUri;
        this.discoveryUrls = options?.discoveryUrls;
    }
    static [typeId] = NodeIds.ApplicationDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.applicationUri);
        encoder.writeString(this.productUri);
        encoder.writeType(this.applicationName);
        encoder.writeUInt32(this.applicationType);
        encoder.writeString(this.gatewayServerUri);
        encoder.writeString(this.discoveryProfileUri);
        encoder.writeStringArray(this.discoveryUrls);
    }
    static [decode](decoder: BinaryDataDecoder): ApplicationDescription {
        return new ApplicationDescription({
            applicationUri: decoder.readString(),
            productUri: decoder.readString(),
            applicationName: decoder.readType(LocalizedText),
            applicationType: decoder.readUInt32(),
            gatewayServerUri: decoder.readString(),
            discoveryProfileUri: decoder.readString(),
            discoveryUrls: decoder.readStringArray()
        });
    }
}
export interface RequestHeaderOptions {
    authenticationToken?: NodeId | undefined;
    timestamp?: Date | undefined;
    requestHandle?: UInt32 | undefined;
    returnDiagnostics?: UInt32 | undefined;
    auditEntryId?: UaString | undefined;
    timeoutHint?: UInt32 | undefined;
    additionalHeader?: ExtensionObject | undefined;
}
export class RequestHeader implements RequestHeaderOptions {
    readonly authenticationToken: NodeId;
    readonly timestamp: Date;
    readonly requestHandle: UInt32;
    readonly returnDiagnostics: UInt32;
    readonly auditEntryId?: UaString;
    readonly timeoutHint: UInt32;
    readonly additionalHeader: ExtensionObject;
    constructor(options?: RequestHeaderOptions) {
        this.authenticationToken = options?.authenticationToken ?? NodeId.null();
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.requestHandle = options?.requestHandle ?? 0;
        this.returnDiagnostics = options?.returnDiagnostics ?? 0;
        this.auditEntryId = options?.auditEntryId;
        this.timeoutHint = options?.timeoutHint ?? 0;
        this.additionalHeader = options?.additionalHeader ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.RequestHeader_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.authenticationToken);
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.requestHandle);
        encoder.writeUInt32(this.returnDiagnostics);
        encoder.writeString(this.auditEntryId);
        encoder.writeUInt32(this.timeoutHint);
        encoder.writeType(this.additionalHeader);
    }
    static [decode](decoder: BinaryDataDecoder): RequestHeader {
        return new RequestHeader({
            authenticationToken: decoder.readType(NodeId),
            timestamp: decoder.readDateTime(),
            requestHandle: decoder.readUInt32(),
            returnDiagnostics: decoder.readUInt32(),
            auditEntryId: decoder.readString(),
            timeoutHint: decoder.readUInt32(),
            additionalHeader: decoder.readType(ExtensionObject)
        });
    }
}
export interface ResponseHeaderOptions {
    timestamp?: Date | undefined;
    requestHandle?: UInt32 | undefined;
    serviceResult?: StatusCode | undefined;
    serviceDiagnostics?: DiagnosticInfo | undefined;
    stringTable?: UaString[] | undefined;
    additionalHeader?: ExtensionObject | undefined;
}
export class ResponseHeader implements ResponseHeaderOptions {
    readonly timestamp: Date;
    readonly requestHandle: UInt32;
    readonly serviceResult: StatusCode;
    readonly serviceDiagnostics: DiagnosticInfo;
    readonly stringTable?: UaString[];
    readonly additionalHeader: ExtensionObject;
    constructor(options?: ResponseHeaderOptions) {
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.requestHandle = options?.requestHandle ?? 0;
        this.serviceResult = options?.serviceResult ?? StatusCode.Good;
        this.serviceDiagnostics = options?.serviceDiagnostics ?? new DiagnosticInfo();
        this.stringTable = options?.stringTable;
        this.additionalHeader = options?.additionalHeader ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.ResponseHeader_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.requestHandle);
        encoder.writeType(this.serviceResult);
        encoder.writeType(this.serviceDiagnostics);
        encoder.writeStringArray(this.stringTable);
        encoder.writeType(this.additionalHeader);
    }
    static [decode](decoder: BinaryDataDecoder): ResponseHeader {
        return new ResponseHeader({
            timestamp: decoder.readDateTime(),
            requestHandle: decoder.readUInt32(),
            serviceResult: decoder.readType(StatusCode),
            serviceDiagnostics: decoder.readType(DiagnosticInfo),
            stringTable: decoder.readStringArray(),
            additionalHeader: decoder.readType(ExtensionObject)
        });
    }
}
export interface SessionlessInvokeRequestTypeOptions {
    urisVersion?: UInt32 | undefined;
    namespaceUris?: UaString[] | undefined;
    serverUris?: UaString[] | undefined;
    localeIds?: UaString[] | undefined;
    serviceId?: UInt32 | undefined;
}
export class SessionlessInvokeRequestType implements SessionlessInvokeRequestTypeOptions {
    readonly urisVersion: UInt32;
    readonly namespaceUris?: UaString[];
    readonly serverUris?: UaString[];
    readonly localeIds?: UaString[];
    readonly serviceId: UInt32;
    constructor(options?: SessionlessInvokeRequestTypeOptions) {
        this.urisVersion = options?.urisVersion ?? 0;
        this.namespaceUris = options?.namespaceUris;
        this.serverUris = options?.serverUris;
        this.localeIds = options?.localeIds;
        this.serviceId = options?.serviceId ?? 0;
    }
    static [typeId] = NodeIds.SessionlessInvokeRequestType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.urisVersion);
        encoder.writeStringArray(this.namespaceUris);
        encoder.writeStringArray(this.serverUris);
        encoder.writeStringArray(this.localeIds);
        encoder.writeUInt32(this.serviceId);
    }
    static [decode](decoder: BinaryDataDecoder): SessionlessInvokeRequestType {
        return new SessionlessInvokeRequestType({
            urisVersion: decoder.readUInt32(),
            namespaceUris: decoder.readStringArray(),
            serverUris: decoder.readStringArray(),
            localeIds: decoder.readStringArray(),
            serviceId: decoder.readUInt32()
        });
    }
}
export interface SessionlessInvokeResponseTypeOptions {
    namespaceUris?: UaString[] | undefined;
    serverUris?: UaString[] | undefined;
    serviceId?: UInt32 | undefined;
}
export class SessionlessInvokeResponseType implements SessionlessInvokeResponseTypeOptions {
    readonly namespaceUris?: UaString[];
    readonly serverUris?: UaString[];
    readonly serviceId: UInt32;
    constructor(options?: SessionlessInvokeResponseTypeOptions) {
        this.namespaceUris = options?.namespaceUris;
        this.serverUris = options?.serverUris;
        this.serviceId = options?.serviceId ?? 0;
    }
    static [typeId] = NodeIds.SessionlessInvokeResponseType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.namespaceUris);
        encoder.writeStringArray(this.serverUris);
        encoder.writeUInt32(this.serviceId);
    }
    static [decode](decoder: BinaryDataDecoder): SessionlessInvokeResponseType {
        return new SessionlessInvokeResponseType({
            namespaceUris: decoder.readStringArray(),
            serverUris: decoder.readStringArray(),
            serviceId: decoder.readUInt32()
        });
    }
}
export interface FindServersRequestOptions {
    requestHeader?: RequestHeader | undefined;
    endpointUrl?: UaString | undefined;
    localeIds?: UaString[] | undefined;
    serverUris?: UaString[] | undefined;
}
export class FindServersRequest implements FindServersRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly endpointUrl?: UaString;
    readonly localeIds?: UaString[];
    readonly serverUris?: UaString[];
    constructor(options?: FindServersRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.serverUris = options?.serverUris;
    }
    static [typeId] = NodeIds.FindServersRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeStringArray(this.serverUris);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersRequest {
        return new FindServersRequest({
            requestHeader: decoder.readType(RequestHeader),
            endpointUrl: decoder.readString(),
            localeIds: decoder.readStringArray(),
            serverUris: decoder.readStringArray()
        });
    }
}
export interface FindServersResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    servers?: ApplicationDescription[] | undefined;
}
export class FindServersResponse implements FindServersResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly servers?: ApplicationDescription[];
    constructor(options?: FindServersResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.servers = options?.servers;
    }
    static [typeId] = NodeIds.FindServersResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.servers);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersResponse {
        return new FindServersResponse({
            responseHeader: decoder.readType(ResponseHeader),
            servers: decoder.readTypeArray(ApplicationDescription)
        });
    }
}
export interface ServerOnNetworkOptions {
    recordId?: UInt32 | undefined;
    serverName?: UaString | undefined;
    discoveryUrl?: UaString | undefined;
    serverCapabilities?: UaString[] | undefined;
}
export class ServerOnNetwork implements ServerOnNetworkOptions {
    readonly recordId: UInt32;
    readonly serverName?: UaString;
    readonly discoveryUrl?: UaString;
    readonly serverCapabilities?: UaString[];
    constructor(options?: ServerOnNetworkOptions) {
        this.recordId = options?.recordId ?? 0;
        this.serverName = options?.serverName;
        this.discoveryUrl = options?.discoveryUrl;
        this.serverCapabilities = options?.serverCapabilities;
    }
    static [typeId] = NodeIds.ServerOnNetwork_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.recordId);
        encoder.writeString(this.serverName);
        encoder.writeString(this.discoveryUrl);
        encoder.writeStringArray(this.serverCapabilities);
    }
    static [decode](decoder: BinaryDataDecoder): ServerOnNetwork {
        return new ServerOnNetwork({
            recordId: decoder.readUInt32(),
            serverName: decoder.readString(),
            discoveryUrl: decoder.readString(),
            serverCapabilities: decoder.readStringArray()
        });
    }
}
export interface FindServersOnNetworkRequestOptions {
    requestHeader?: RequestHeader | undefined;
    startingRecordId?: UInt32 | undefined;
    maxRecordsToReturn?: UInt32 | undefined;
    serverCapabilityFilter?: UaString[] | undefined;
}
export class FindServersOnNetworkRequest implements FindServersOnNetworkRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly startingRecordId: UInt32;
    readonly maxRecordsToReturn: UInt32;
    readonly serverCapabilityFilter?: UaString[];
    constructor(options?: FindServersOnNetworkRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.startingRecordId = options?.startingRecordId ?? 0;
        this.maxRecordsToReturn = options?.maxRecordsToReturn ?? 0;
        this.serverCapabilityFilter = options?.serverCapabilityFilter;
    }
    static [typeId] = NodeIds.FindServersOnNetworkRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.startingRecordId);
        encoder.writeUInt32(this.maxRecordsToReturn);
        encoder.writeStringArray(this.serverCapabilityFilter);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersOnNetworkRequest {
        return new FindServersOnNetworkRequest({
            requestHeader: decoder.readType(RequestHeader),
            startingRecordId: decoder.readUInt32(),
            maxRecordsToReturn: decoder.readUInt32(),
            serverCapabilityFilter: decoder.readStringArray()
        });
    }
}
export interface FindServersOnNetworkResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    lastCounterResetTime?: Date | undefined;
    servers?: ServerOnNetwork[] | undefined;
}
export class FindServersOnNetworkResponse implements FindServersOnNetworkResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly lastCounterResetTime: Date;
    readonly servers?: ServerOnNetwork[];
    constructor(options?: FindServersOnNetworkResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.lastCounterResetTime = options?.lastCounterResetTime ?? new Date(-11644473600000);
        this.servers = options?.servers;
    }
    static [typeId] = NodeIds.FindServersOnNetworkResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeDateTime(this.lastCounterResetTime);
        encoder.writeTypeArray(this.servers);
    }
    static [decode](decoder: BinaryDataDecoder): FindServersOnNetworkResponse {
        return new FindServersOnNetworkResponse({
            responseHeader: decoder.readType(ResponseHeader),
            lastCounterResetTime: decoder.readDateTime(),
            servers: decoder.readTypeArray(ServerOnNetwork)
        });
    }
}
export enum MessageSecurityMode {
    Invalid = 0,
    None = 1,
    Sign = 2,
    SignAndEncrypt = 3
}
export enum UserTokenType {
    Anonymous = 0,
    UserName = 1,
    Certificate = 2,
    IssuedToken = 3
}
export interface UserTokenPolicyOptions {
    policyId?: UaString | undefined;
    tokenType?: UserTokenType | undefined;
    issuedTokenType?: UaString | undefined;
    issuerEndpointUrl?: UaString | undefined;
    securityPolicyUri?: UaString | undefined;
}
export class UserTokenPolicy implements UserTokenPolicyOptions {
    readonly policyId?: UaString;
    readonly tokenType: UserTokenType;
    readonly issuedTokenType?: UaString;
    readonly issuerEndpointUrl?: UaString;
    readonly securityPolicyUri?: UaString;
    constructor(options?: UserTokenPolicyOptions) {
        this.policyId = options?.policyId;
        this.tokenType = options?.tokenType ?? UserTokenType.Anonymous;
        this.issuedTokenType = options?.issuedTokenType;
        this.issuerEndpointUrl = options?.issuerEndpointUrl;
        this.securityPolicyUri = options?.securityPolicyUri;
    }
    static [typeId] = NodeIds.UserTokenPolicy_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeUInt32(this.tokenType);
        encoder.writeString(this.issuedTokenType);
        encoder.writeString(this.issuerEndpointUrl);
        encoder.writeString(this.securityPolicyUri);
    }
    static [decode](decoder: BinaryDataDecoder): UserTokenPolicy {
        return new UserTokenPolicy({
            policyId: decoder.readString(),
            tokenType: decoder.readUInt32(),
            issuedTokenType: decoder.readString(),
            issuerEndpointUrl: decoder.readString(),
            securityPolicyUri: decoder.readString()
        });
    }
}
export interface EndpointDescriptionOptions {
    endpointUrl?: UaString | undefined;
    server?: ApplicationDescription | undefined;
    serverCertificate?: ByteString | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityPolicyUri?: UaString | undefined;
    userIdentityTokens?: UserTokenPolicy[] | undefined;
    transportProfileUri?: UaString | undefined;
    securityLevel?: Byte | undefined;
}
export class EndpointDescription implements EndpointDescriptionOptions {
    readonly endpointUrl?: UaString;
    readonly server: ApplicationDescription;
    readonly serverCertificate?: ByteString;
    readonly securityMode: MessageSecurityMode;
    readonly securityPolicyUri?: UaString;
    readonly userIdentityTokens?: UserTokenPolicy[];
    readonly transportProfileUri?: UaString;
    readonly securityLevel: Byte;
    constructor(options?: EndpointDescriptionOptions) {
        this.endpointUrl = options?.endpointUrl;
        this.server = options?.server ?? new ApplicationDescription();
        this.serverCertificate = options?.serverCertificate;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.userIdentityTokens = options?.userIdentityTokens;
        this.transportProfileUri = options?.transportProfileUri;
        this.securityLevel = options?.securityLevel ?? 0;
    }
    static [typeId] = NodeIds.EndpointDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.endpointUrl);
        encoder.writeType(this.server);
        encoder.writeByteString(this.serverCertificate);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeTypeArray(this.userIdentityTokens);
        encoder.writeString(this.transportProfileUri);
        encoder.writeByte(this.securityLevel);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointDescription {
        return new EndpointDescription({
            endpointUrl: decoder.readString(),
            server: decoder.readType(ApplicationDescription),
            serverCertificate: decoder.readByteString(),
            securityMode: decoder.readUInt32(),
            securityPolicyUri: decoder.readString(),
            userIdentityTokens: decoder.readTypeArray(UserTokenPolicy),
            transportProfileUri: decoder.readString(),
            securityLevel: decoder.readByte()
        });
    }
}
export interface GetEndpointsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    endpointUrl?: UaString | undefined;
    localeIds?: UaString[] | undefined;
    profileUris?: UaString[] | undefined;
}
export class GetEndpointsRequest implements GetEndpointsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly endpointUrl?: UaString;
    readonly localeIds?: UaString[];
    readonly profileUris?: UaString[];
    constructor(options?: GetEndpointsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.profileUris = options?.profileUris;
    }
    static [typeId] = NodeIds.GetEndpointsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeStringArray(this.profileUris);
    }
    static [decode](decoder: BinaryDataDecoder): GetEndpointsRequest {
        return new GetEndpointsRequest({
            requestHeader: decoder.readType(RequestHeader),
            endpointUrl: decoder.readString(),
            localeIds: decoder.readStringArray(),
            profileUris: decoder.readStringArray()
        });
    }
}
export interface GetEndpointsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    endpoints?: EndpointDescription[] | undefined;
}
export class GetEndpointsResponse implements GetEndpointsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly endpoints?: EndpointDescription[];
    constructor(options?: GetEndpointsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.endpoints = options?.endpoints;
    }
    static [typeId] = NodeIds.GetEndpointsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.endpoints);
    }
    static [decode](decoder: BinaryDataDecoder): GetEndpointsResponse {
        return new GetEndpointsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            endpoints: decoder.readTypeArray(EndpointDescription)
        });
    }
}
export interface RegisteredServerOptions {
    serverUri?: UaString | undefined;
    productUri?: UaString | undefined;
    serverNames?: LocalizedText[] | undefined;
    serverType?: ApplicationType | undefined;
    gatewayServerUri?: UaString | undefined;
    discoveryUrls?: UaString[] | undefined;
    semaphoreFilePath?: UaString | undefined;
    isOnline?: boolean | undefined;
}
export class RegisteredServer implements RegisteredServerOptions {
    readonly serverUri?: UaString;
    readonly productUri?: UaString;
    readonly serverNames?: LocalizedText[];
    readonly serverType: ApplicationType;
    readonly gatewayServerUri?: UaString;
    readonly discoveryUrls?: UaString[];
    readonly semaphoreFilePath?: UaString;
    readonly isOnline: boolean;
    constructor(options?: RegisteredServerOptions) {
        this.serverUri = options?.serverUri;
        this.productUri = options?.productUri;
        this.serverNames = options?.serverNames;
        this.serverType = options?.serverType ?? ApplicationType.Server;
        this.gatewayServerUri = options?.gatewayServerUri;
        this.discoveryUrls = options?.discoveryUrls;
        this.semaphoreFilePath = options?.semaphoreFilePath;
        this.isOnline = options?.isOnline ?? false;
    }
    static [typeId] = NodeIds.RegisteredServer_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverUri);
        encoder.writeString(this.productUri);
        encoder.writeTypeArray(this.serverNames);
        encoder.writeUInt32(this.serverType);
        encoder.writeString(this.gatewayServerUri);
        encoder.writeStringArray(this.discoveryUrls);
        encoder.writeString(this.semaphoreFilePath);
        encoder.writeBoolean(this.isOnline);
    }
    static [decode](decoder: BinaryDataDecoder): RegisteredServer {
        return new RegisteredServer({
            serverUri: decoder.readString(),
            productUri: decoder.readString(),
            serverNames: decoder.readTypeArray(LocalizedText),
            serverType: decoder.readUInt32(),
            gatewayServerUri: decoder.readString(),
            discoveryUrls: decoder.readStringArray(),
            semaphoreFilePath: decoder.readString(),
            isOnline: decoder.readBoolean()
        });
    }
}
export interface RegisterServerRequestOptions {
    requestHeader?: RequestHeader | undefined;
    server?: RegisteredServer | undefined;
}
export class RegisterServerRequest implements RegisterServerRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly server: RegisteredServer;
    constructor(options?: RegisterServerRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.server = options?.server ?? new RegisteredServer();
    }
    static [typeId] = NodeIds.RegisterServerRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.server);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServerRequest {
        return new RegisterServerRequest({
            requestHeader: decoder.readType(RequestHeader),
            server: decoder.readType(RegisteredServer)
        });
    }
}
export interface RegisterServerResponseOptions {
    responseHeader?: ResponseHeader | undefined;
}
export class RegisterServerResponse implements RegisterServerResponseOptions {
    readonly responseHeader: ResponseHeader;
    constructor(options?: RegisterServerResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.RegisterServerResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServerResponse {
        return new RegisterServerResponse({
            responseHeader: decoder.readType(ResponseHeader)
        });
    }
}
export class DiscoveryConfiguration {
    static [typeId] = NodeIds.DiscoveryConfiguration_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): DiscoveryConfiguration {
        return new DiscoveryConfiguration();
    }
}
export interface MdnsDiscoveryConfigurationOptions {
    mdnsServerName?: UaString | undefined;
    serverCapabilities?: UaString[] | undefined;
}
export class MdnsDiscoveryConfiguration implements MdnsDiscoveryConfigurationOptions {
    readonly mdnsServerName?: UaString;
    readonly serverCapabilities?: UaString[];
    constructor(options?: MdnsDiscoveryConfigurationOptions) {
        this.mdnsServerName = options?.mdnsServerName;
        this.serverCapabilities = options?.serverCapabilities;
    }
    static [typeId] = NodeIds.MdnsDiscoveryConfiguration_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.mdnsServerName);
        encoder.writeStringArray(this.serverCapabilities);
    }
    static [decode](decoder: BinaryDataDecoder): MdnsDiscoveryConfiguration {
        return new MdnsDiscoveryConfiguration({
            mdnsServerName: decoder.readString(),
            serverCapabilities: decoder.readStringArray()
        });
    }
}
export interface RegisterServer2RequestOptions {
    requestHeader?: RequestHeader | undefined;
    server?: RegisteredServer | undefined;
    discoveryConfiguration?: ExtensionObject[] | undefined;
}
export class RegisterServer2Request implements RegisterServer2RequestOptions {
    readonly requestHeader: RequestHeader;
    readonly server: RegisteredServer;
    readonly discoveryConfiguration?: ExtensionObject[];
    constructor(options?: RegisterServer2RequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.server = options?.server ?? new RegisteredServer();
        this.discoveryConfiguration = options?.discoveryConfiguration;
    }
    static [typeId] = NodeIds.RegisterServer2Request_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.server);
        encoder.writeTypeArray(this.discoveryConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServer2Request {
        return new RegisterServer2Request({
            requestHeader: decoder.readType(RequestHeader),
            server: decoder.readType(RegisteredServer),
            discoveryConfiguration: decoder.readTypeArray(ExtensionObject)
        });
    }
}
export interface RegisterServer2ResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    configurationResults?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class RegisterServer2Response implements RegisterServer2ResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly configurationResults?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: RegisterServer2ResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.configurationResults = options?.configurationResults;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.RegisterServer2Response_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.configurationResults);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterServer2Response {
        return new RegisterServer2Response({
            responseHeader: decoder.readType(ResponseHeader),
            configurationResults: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export enum SecurityTokenRequestType {
    Issue = 0,
    Renew = 1
}
export interface ChannelSecurityTokenOptions {
    channelId?: UInt32 | undefined;
    tokenId?: UInt32 | undefined;
    createdAt?: Date | undefined;
    revisedLifetime?: UInt32 | undefined;
}
export class ChannelSecurityToken implements ChannelSecurityTokenOptions {
    readonly channelId: UInt32;
    readonly tokenId: UInt32;
    readonly createdAt: Date;
    readonly revisedLifetime: UInt32;
    constructor(options?: ChannelSecurityTokenOptions) {
        this.channelId = options?.channelId ?? 0;
        this.tokenId = options?.tokenId ?? 0;
        this.createdAt = options?.createdAt ?? new Date(-11644473600000);
        this.revisedLifetime = options?.revisedLifetime ?? 0;
    }
    static [typeId] = NodeIds.ChannelSecurityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.channelId);
        encoder.writeUInt32(this.tokenId);
        encoder.writeDateTime(this.createdAt);
        encoder.writeUInt32(this.revisedLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): ChannelSecurityToken {
        return new ChannelSecurityToken({
            channelId: decoder.readUInt32(),
            tokenId: decoder.readUInt32(),
            createdAt: decoder.readDateTime(),
            revisedLifetime: decoder.readUInt32()
        });
    }
}
export interface OpenSecureChannelRequestOptions {
    requestHeader?: RequestHeader | undefined;
    clientProtocolVersion?: UInt32 | undefined;
    requestType?: SecurityTokenRequestType | undefined;
    securityMode?: MessageSecurityMode | undefined;
    clientNonce?: ByteString | undefined;
    requestedLifetime?: UInt32 | undefined;
}
export class OpenSecureChannelRequest implements OpenSecureChannelRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly clientProtocolVersion: UInt32;
    readonly requestType: SecurityTokenRequestType;
    readonly securityMode: MessageSecurityMode;
    readonly clientNonce?: ByteString;
    readonly requestedLifetime: UInt32;
    constructor(options?: OpenSecureChannelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientProtocolVersion = options?.clientProtocolVersion ?? 0;
        this.requestType = options?.requestType ?? SecurityTokenRequestType.Issue;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.clientNonce = options?.clientNonce;
        this.requestedLifetime = options?.requestedLifetime ?? 0;
    }
    static [typeId] = NodeIds.OpenSecureChannelRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.clientProtocolVersion);
        encoder.writeUInt32(this.requestType);
        encoder.writeUInt32(this.securityMode);
        encoder.writeByteString(this.clientNonce);
        encoder.writeUInt32(this.requestedLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): OpenSecureChannelRequest {
        return new OpenSecureChannelRequest({
            requestHeader: decoder.readType(RequestHeader),
            clientProtocolVersion: decoder.readUInt32(),
            requestType: decoder.readUInt32(),
            securityMode: decoder.readUInt32(),
            clientNonce: decoder.readByteString(),
            requestedLifetime: decoder.readUInt32()
        });
    }
}
export interface OpenSecureChannelResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    serverProtocolVersion?: UInt32 | undefined;
    securityToken?: ChannelSecurityToken | undefined;
    serverNonce?: ByteString | undefined;
}
export class OpenSecureChannelResponse implements OpenSecureChannelResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly serverProtocolVersion: UInt32;
    readonly securityToken: ChannelSecurityToken;
    readonly serverNonce?: ByteString;
    constructor(options?: OpenSecureChannelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.serverProtocolVersion = options?.serverProtocolVersion ?? 0;
        this.securityToken = options?.securityToken ?? new ChannelSecurityToken();
        this.serverNonce = options?.serverNonce;
    }
    static [typeId] = NodeIds.OpenSecureChannelResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.serverProtocolVersion);
        encoder.writeType(this.securityToken);
        encoder.writeByteString(this.serverNonce);
    }
    static [decode](decoder: BinaryDataDecoder): OpenSecureChannelResponse {
        return new OpenSecureChannelResponse({
            responseHeader: decoder.readType(ResponseHeader),
            serverProtocolVersion: decoder.readUInt32(),
            securityToken: decoder.readType(ChannelSecurityToken),
            serverNonce: decoder.readByteString()
        });
    }
}
export interface CloseSecureChannelRequestOptions {
    requestHeader?: RequestHeader | undefined;
}
export class CloseSecureChannelRequest implements CloseSecureChannelRequestOptions {
    readonly requestHeader: RequestHeader;
    constructor(options?: CloseSecureChannelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
    }
    static [typeId] = NodeIds.CloseSecureChannelRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSecureChannelRequest {
        return new CloseSecureChannelRequest({
            requestHeader: decoder.readType(RequestHeader)
        });
    }
}
export interface CloseSecureChannelResponseOptions {
    responseHeader?: ResponseHeader | undefined;
}
export class CloseSecureChannelResponse implements CloseSecureChannelResponseOptions {
    readonly responseHeader: ResponseHeader;
    constructor(options?: CloseSecureChannelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.CloseSecureChannelResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSecureChannelResponse {
        return new CloseSecureChannelResponse({
            responseHeader: decoder.readType(ResponseHeader)
        });
    }
}
export interface SignedSoftwareCertificateOptions {
    certificateData?: ByteString | undefined;
    signature?: ByteString | undefined;
}
export class SignedSoftwareCertificate implements SignedSoftwareCertificateOptions {
    readonly certificateData?: ByteString;
    readonly signature?: ByteString;
    constructor(options?: SignedSoftwareCertificateOptions) {
        this.certificateData = options?.certificateData;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.SignedSoftwareCertificate_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeByteString(this.certificateData);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): SignedSoftwareCertificate {
        return new SignedSoftwareCertificate({
            certificateData: decoder.readByteString(),
            signature: decoder.readByteString()
        });
    }
}
export interface SignatureDataOptions {
    algorithm?: UaString | undefined;
    signature?: ByteString | undefined;
}
export class SignatureData implements SignatureDataOptions {
    readonly algorithm?: UaString;
    readonly signature?: ByteString;
    constructor(options?: SignatureDataOptions) {
        this.algorithm = options?.algorithm;
        this.signature = options?.signature;
    }
    static [typeId] = NodeIds.SignatureData_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.algorithm);
        encoder.writeByteString(this.signature);
    }
    static [decode](decoder: BinaryDataDecoder): SignatureData {
        return new SignatureData({
            algorithm: decoder.readString(),
            signature: decoder.readByteString()
        });
    }
}
export interface CreateSessionRequestOptions {
    requestHeader?: RequestHeader | undefined;
    clientDescription?: ApplicationDescription | undefined;
    serverUri?: UaString | undefined;
    endpointUrl?: UaString | undefined;
    sessionName?: UaString | undefined;
    clientNonce?: ByteString | undefined;
    clientCertificate?: ByteString | undefined;
    requestedSessionTimeout?: Double | undefined;
    maxResponseMessageSize?: UInt32 | undefined;
}
export class CreateSessionRequest implements CreateSessionRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly clientDescription: ApplicationDescription;
    readonly serverUri?: UaString;
    readonly endpointUrl?: UaString;
    readonly sessionName?: UaString;
    readonly clientNonce?: ByteString;
    readonly clientCertificate?: ByteString;
    readonly requestedSessionTimeout: Double;
    readonly maxResponseMessageSize: UInt32;
    constructor(options?: CreateSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientDescription = options?.clientDescription ?? new ApplicationDescription();
        this.serverUri = options?.serverUri;
        this.endpointUrl = options?.endpointUrl;
        this.sessionName = options?.sessionName;
        this.clientNonce = options?.clientNonce;
        this.clientCertificate = options?.clientCertificate;
        this.requestedSessionTimeout = options?.requestedSessionTimeout ?? 0;
        this.maxResponseMessageSize = options?.maxResponseMessageSize ?? 0;
    }
    static [typeId] = NodeIds.CreateSessionRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.clientDescription);
        encoder.writeString(this.serverUri);
        encoder.writeString(this.endpointUrl);
        encoder.writeString(this.sessionName);
        encoder.writeByteString(this.clientNonce);
        encoder.writeByteString(this.clientCertificate);
        encoder.writeDouble(this.requestedSessionTimeout);
        encoder.writeUInt32(this.maxResponseMessageSize);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSessionRequest {
        return new CreateSessionRequest({
            requestHeader: decoder.readType(RequestHeader),
            clientDescription: decoder.readType(ApplicationDescription),
            serverUri: decoder.readString(),
            endpointUrl: decoder.readString(),
            sessionName: decoder.readString(),
            clientNonce: decoder.readByteString(),
            clientCertificate: decoder.readByteString(),
            requestedSessionTimeout: decoder.readDouble(),
            maxResponseMessageSize: decoder.readUInt32()
        });
    }
}
export interface CreateSessionResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    sessionId?: NodeId | undefined;
    authenticationToken?: NodeId | undefined;
    revisedSessionTimeout?: Double | undefined;
    serverNonce?: ByteString | undefined;
    serverCertificate?: ByteString | undefined;
    serverEndpoints?: EndpointDescription[] | undefined;
    serverSoftwareCertificates?: SignedSoftwareCertificate[] | undefined;
    serverSignature?: SignatureData | undefined;
    maxRequestMessageSize?: UInt32 | undefined;
}
export class CreateSessionResponse implements CreateSessionResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly sessionId: NodeId;
    readonly authenticationToken: NodeId;
    readonly revisedSessionTimeout: Double;
    readonly serverNonce?: ByteString;
    readonly serverCertificate?: ByteString;
    readonly serverEndpoints?: EndpointDescription[];
    readonly serverSoftwareCertificates?: SignedSoftwareCertificate[];
    readonly serverSignature: SignatureData;
    readonly maxRequestMessageSize: UInt32;
    constructor(options?: CreateSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.authenticationToken = options?.authenticationToken ?? NodeId.null();
        this.revisedSessionTimeout = options?.revisedSessionTimeout ?? 0;
        this.serverNonce = options?.serverNonce;
        this.serverCertificate = options?.serverCertificate;
        this.serverEndpoints = options?.serverEndpoints;
        this.serverSoftwareCertificates = options?.serverSoftwareCertificates;
        this.serverSignature = options?.serverSignature ?? new SignatureData();
        this.maxRequestMessageSize = options?.maxRequestMessageSize ?? 0;
    }
    static [typeId] = NodeIds.CreateSessionResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeType(this.sessionId);
        encoder.writeType(this.authenticationToken);
        encoder.writeDouble(this.revisedSessionTimeout);
        encoder.writeByteString(this.serverNonce);
        encoder.writeByteString(this.serverCertificate);
        encoder.writeTypeArray(this.serverEndpoints);
        encoder.writeTypeArray(this.serverSoftwareCertificates);
        encoder.writeType(this.serverSignature);
        encoder.writeUInt32(this.maxRequestMessageSize);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSessionResponse {
        return new CreateSessionResponse({
            responseHeader: decoder.readType(ResponseHeader),
            sessionId: decoder.readType(NodeId),
            authenticationToken: decoder.readType(NodeId),
            revisedSessionTimeout: decoder.readDouble(),
            serverNonce: decoder.readByteString(),
            serverCertificate: decoder.readByteString(),
            serverEndpoints: decoder.readTypeArray(EndpointDescription),
            serverSoftwareCertificates: decoder.readTypeArray(SignedSoftwareCertificate),
            serverSignature: decoder.readType(SignatureData),
            maxRequestMessageSize: decoder.readUInt32()
        });
    }
}
export interface UserIdentityTokenOptions {
    policyId?: UaString | undefined;
}
export class UserIdentityToken implements UserIdentityTokenOptions {
    readonly policyId?: UaString;
    constructor(options?: UserIdentityTokenOptions) {
        this.policyId = options?.policyId;
    }
    static [typeId] = NodeIds.UserIdentityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
    }
    static [decode](decoder: BinaryDataDecoder): UserIdentityToken {
        return new UserIdentityToken({
            policyId: decoder.readString()
        });
    }
}
export interface AnonymousIdentityTokenOptions {
    policyId?: UaString | undefined;
}
export class AnonymousIdentityToken implements AnonymousIdentityTokenOptions {
    readonly policyId?: UaString;
    constructor(options?: AnonymousIdentityTokenOptions) {
        this.policyId = options?.policyId;
    }
    static [typeId] = NodeIds.AnonymousIdentityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
    }
    static [decode](decoder: BinaryDataDecoder): AnonymousIdentityToken {
        return new AnonymousIdentityToken({
            policyId: decoder.readString()
        });
    }
}
export interface UserNameIdentityTokenOptions {
    policyId?: UaString | undefined;
    userName?: UaString | undefined;
    password?: ByteString | undefined;
    encryptionAlgorithm?: UaString | undefined;
}
export class UserNameIdentityToken implements UserNameIdentityTokenOptions {
    readonly policyId?: UaString;
    readonly userName?: UaString;
    readonly password?: ByteString;
    readonly encryptionAlgorithm?: UaString;
    constructor(options?: UserNameIdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.userName = options?.userName;
        this.password = options?.password;
        this.encryptionAlgorithm = options?.encryptionAlgorithm;
    }
    static [typeId] = NodeIds.UserNameIdentityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeString(this.userName);
        encoder.writeByteString(this.password);
        encoder.writeString(this.encryptionAlgorithm);
    }
    static [decode](decoder: BinaryDataDecoder): UserNameIdentityToken {
        return new UserNameIdentityToken({
            policyId: decoder.readString(),
            userName: decoder.readString(),
            password: decoder.readByteString(),
            encryptionAlgorithm: decoder.readString()
        });
    }
}
export interface X509IdentityTokenOptions {
    policyId?: UaString | undefined;
    certificateData?: ByteString | undefined;
}
export class X509IdentityToken implements X509IdentityTokenOptions {
    readonly policyId?: UaString;
    readonly certificateData?: ByteString;
    constructor(options?: X509IdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.certificateData = options?.certificateData;
    }
    static [typeId] = NodeIds.X509IdentityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeByteString(this.certificateData);
    }
    static [decode](decoder: BinaryDataDecoder): X509IdentityToken {
        return new X509IdentityToken({
            policyId: decoder.readString(),
            certificateData: decoder.readByteString()
        });
    }
}
export interface IssuedIdentityTokenOptions {
    policyId?: UaString | undefined;
    tokenData?: ByteString | undefined;
    encryptionAlgorithm?: UaString | undefined;
}
export class IssuedIdentityToken implements IssuedIdentityTokenOptions {
    readonly policyId?: UaString;
    readonly tokenData?: ByteString;
    readonly encryptionAlgorithm?: UaString;
    constructor(options?: IssuedIdentityTokenOptions) {
        this.policyId = options?.policyId;
        this.tokenData = options?.tokenData;
        this.encryptionAlgorithm = options?.encryptionAlgorithm;
    }
    static [typeId] = NodeIds.IssuedIdentityToken_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.policyId);
        encoder.writeByteString(this.tokenData);
        encoder.writeString(this.encryptionAlgorithm);
    }
    static [decode](decoder: BinaryDataDecoder): IssuedIdentityToken {
        return new IssuedIdentityToken({
            policyId: decoder.readString(),
            tokenData: decoder.readByteString(),
            encryptionAlgorithm: decoder.readString()
        });
    }
}
export interface ActivateSessionRequestOptions {
    requestHeader?: RequestHeader | undefined;
    clientSignature?: SignatureData | undefined;
    clientSoftwareCertificates?: SignedSoftwareCertificate[] | undefined;
    localeIds?: UaString[] | undefined;
    userIdentityToken?: ExtensionObject | undefined;
    userTokenSignature?: SignatureData | undefined;
}
export class ActivateSessionRequest implements ActivateSessionRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly clientSignature: SignatureData;
    readonly clientSoftwareCertificates?: SignedSoftwareCertificate[];
    readonly localeIds?: UaString[];
    readonly userIdentityToken: ExtensionObject;
    readonly userTokenSignature: SignatureData;
    constructor(options?: ActivateSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.clientSignature = options?.clientSignature ?? new SignatureData();
        this.clientSoftwareCertificates = options?.clientSoftwareCertificates;
        this.localeIds = options?.localeIds;
        this.userIdentityToken = options?.userIdentityToken ?? new ExtensionObject();
        this.userTokenSignature = options?.userTokenSignature ?? new SignatureData();
    }
    static [typeId] = NodeIds.ActivateSessionRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.clientSignature);
        encoder.writeTypeArray(this.clientSoftwareCertificates);
        encoder.writeStringArray(this.localeIds);
        encoder.writeType(this.userIdentityToken);
        encoder.writeType(this.userTokenSignature);
    }
    static [decode](decoder: BinaryDataDecoder): ActivateSessionRequest {
        return new ActivateSessionRequest({
            requestHeader: decoder.readType(RequestHeader),
            clientSignature: decoder.readType(SignatureData),
            clientSoftwareCertificates: decoder.readTypeArray(SignedSoftwareCertificate),
            localeIds: decoder.readStringArray(),
            userIdentityToken: decoder.readType(ExtensionObject),
            userTokenSignature: decoder.readType(SignatureData)
        });
    }
}
export interface ActivateSessionResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    serverNonce?: ByteString | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ActivateSessionResponse implements ActivateSessionResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly serverNonce?: ByteString;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ActivateSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.serverNonce = options?.serverNonce;
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ActivateSessionResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeByteString(this.serverNonce);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ActivateSessionResponse {
        return new ActivateSessionResponse({
            responseHeader: decoder.readType(ResponseHeader),
            serverNonce: decoder.readByteString(),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface CloseSessionRequestOptions {
    requestHeader?: RequestHeader | undefined;
    deleteSubscriptions?: boolean | undefined;
}
export class CloseSessionRequest implements CloseSessionRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly deleteSubscriptions: boolean;
    constructor(options?: CloseSessionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.deleteSubscriptions = options?.deleteSubscriptions ?? false;
    }
    static [typeId] = NodeIds.CloseSessionRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.deleteSubscriptions);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSessionRequest {
        return new CloseSessionRequest({
            requestHeader: decoder.readType(RequestHeader),
            deleteSubscriptions: decoder.readBoolean()
        });
    }
}
export interface CloseSessionResponseOptions {
    responseHeader?: ResponseHeader | undefined;
}
export class CloseSessionResponse implements CloseSessionResponseOptions {
    readonly responseHeader: ResponseHeader;
    constructor(options?: CloseSessionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.CloseSessionResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): CloseSessionResponse {
        return new CloseSessionResponse({
            responseHeader: decoder.readType(ResponseHeader)
        });
    }
}
export interface CancelRequestOptions {
    requestHeader?: RequestHeader | undefined;
    requestHandle?: UInt32 | undefined;
}
export class CancelRequest implements CancelRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly requestHandle: UInt32;
    constructor(options?: CancelRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.requestHandle = options?.requestHandle ?? 0;
    }
    static [typeId] = NodeIds.CancelRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.requestHandle);
    }
    static [decode](decoder: BinaryDataDecoder): CancelRequest {
        return new CancelRequest({
            requestHeader: decoder.readType(RequestHeader),
            requestHandle: decoder.readUInt32()
        });
    }
}
export interface CancelResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    cancelCount?: UInt32 | undefined;
}
export class CancelResponse implements CancelResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly cancelCount: UInt32;
    constructor(options?: CancelResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.cancelCount = options?.cancelCount ?? 0;
    }
    static [typeId] = NodeIds.CancelResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.cancelCount);
    }
    static [decode](decoder: BinaryDataDecoder): CancelResponse {
        return new CancelResponse({
            responseHeader: decoder.readType(ResponseHeader),
            cancelCount: decoder.readUInt32()
        });
    }
}
export enum NodeAttributesMask {
    None = 0,
    AccessLevel = 1,
    ArrayDimensions = 2,
    BrowseName = 4,
    ContainsNoLoops = 8,
    DataType = 16,
    Description = 32,
    DisplayName = 64,
    EventNotifier = 128,
    Executable = 256,
    Historizing = 512,
    InverseName = 1024,
    IsAbstract = 2048,
    MinimumSamplingInterval = 4096,
    NodeClass = 8192,
    NodeId = 16384,
    Symmetric = 32768,
    UserAccessLevel = 65536,
    UserExecutable = 131072,
    UserWriteMask = 262144,
    ValueRank = 524288,
    WriteMask = 1048576,
    Value = 2097152,
    DataTypeDefinition = 4194304,
    RolePermissions = 8388608,
    AccessRestrictions = 16777216,
    All = 33554431,
    BaseNode = 26501220,
    Object = 26501348,
    ObjectType = 26503268,
    Variable = 26571383,
    VariableType = 28600438,
    Method = 26632548,
    ReferenceType = 26537060,
    View = 26501356
}
export interface NodeAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
}
export class NodeAttributes implements NodeAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    constructor(options?: NodeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
    }
    static [typeId] = NodeIds.NodeAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
    }
    static [decode](decoder: BinaryDataDecoder): NodeAttributes {
        return new NodeAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32()
        });
    }
}
export interface ObjectAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    eventNotifier?: Byte | undefined;
}
export class ObjectAttributes implements ObjectAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly eventNotifier: Byte;
    constructor(options?: ObjectAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ObjectAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectAttributes {
        return new ObjectAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            eventNotifier: decoder.readByte()
        });
    }
}
export interface VariableAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    value?: Variant | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    accessLevel?: Byte | undefined;
    userAccessLevel?: Byte | undefined;
    minimumSamplingInterval?: Double | undefined;
    historizing?: boolean | undefined;
}
export class VariableAttributes implements VariableAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly value: Variant;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly accessLevel: Byte;
    readonly userAccessLevel: Byte;
    readonly minimumSamplingInterval: Double;
    readonly historizing: boolean;
    constructor(options?: VariableAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.accessLevel = options?.accessLevel ?? 0;
        this.userAccessLevel = options?.userAccessLevel ?? 0;
        this.minimumSamplingInterval = options?.minimumSamplingInterval ?? 0;
        this.historizing = options?.historizing ?? false;
    }
    static [typeId] = NodeIds.VariableAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeByte(this.accessLevel);
        encoder.writeByte(this.userAccessLevel);
        encoder.writeDouble(this.minimumSamplingInterval);
        encoder.writeBoolean(this.historizing);
    }
    static [decode](decoder: BinaryDataDecoder): VariableAttributes {
        return new VariableAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            value: decoder.readType(Variant),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            accessLevel: decoder.readByte(),
            userAccessLevel: decoder.readByte(),
            minimumSamplingInterval: decoder.readDouble(),
            historizing: decoder.readBoolean()
        });
    }
}
export interface MethodAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    executable?: boolean | undefined;
    userExecutable?: boolean | undefined;
}
export class MethodAttributes implements MethodAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly executable: boolean;
    readonly userExecutable: boolean;
    constructor(options?: MethodAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.executable = options?.executable ?? false;
        this.userExecutable = options?.userExecutable ?? false;
    }
    static [typeId] = NodeIds.MethodAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.executable);
        encoder.writeBoolean(this.userExecutable);
    }
    static [decode](decoder: BinaryDataDecoder): MethodAttributes {
        return new MethodAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            executable: decoder.readBoolean(),
            userExecutable: decoder.readBoolean()
        });
    }
}
export interface ObjectTypeAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    isAbstract?: boolean | undefined;
}
export class ObjectTypeAttributes implements ObjectTypeAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly isAbstract: boolean;
    constructor(options?: ObjectTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.ObjectTypeAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): ObjectTypeAttributes {
        return new ObjectTypeAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            isAbstract: decoder.readBoolean()
        });
    }
}
export interface VariableTypeAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    value?: Variant | undefined;
    dataType?: NodeId | undefined;
    valueRank?: Int32 | undefined;
    arrayDimensions?: UInt32[] | undefined;
    isAbstract?: boolean | undefined;
}
export class VariableTypeAttributes implements VariableTypeAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly value: Variant;
    readonly dataType: NodeId;
    readonly valueRank: Int32;
    readonly arrayDimensions?: UInt32[];
    readonly isAbstract: boolean;
    constructor(options?: VariableTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.value = options?.value ?? Variant.null();
        this.dataType = options?.dataType ?? NodeId.null();
        this.valueRank = options?.valueRank ?? 0;
        this.arrayDimensions = options?.arrayDimensions;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.VariableTypeAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeType(this.value);
        encoder.writeType(this.dataType);
        encoder.writeInt32(this.valueRank);
        encoder.writeUInt32Array(this.arrayDimensions);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): VariableTypeAttributes {
        return new VariableTypeAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            value: decoder.readType(Variant),
            dataType: decoder.readType(NodeId),
            valueRank: decoder.readInt32(),
            arrayDimensions: decoder.readUInt32Array(),
            isAbstract: decoder.readBoolean()
        });
    }
}
export interface ReferenceTypeAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    isAbstract?: boolean | undefined;
    symmetric?: boolean | undefined;
    inverseName?: LocalizedText | undefined;
}
export class ReferenceTypeAttributes implements ReferenceTypeAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly isAbstract: boolean;
    readonly symmetric: boolean;
    readonly inverseName: LocalizedText;
    constructor(options?: ReferenceTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
        this.symmetric = options?.symmetric ?? false;
        this.inverseName = options?.inverseName ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ReferenceTypeAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
        encoder.writeBoolean(this.symmetric);
        encoder.writeType(this.inverseName);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceTypeAttributes {
        return new ReferenceTypeAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            isAbstract: decoder.readBoolean(),
            symmetric: decoder.readBoolean(),
            inverseName: decoder.readType(LocalizedText)
        });
    }
}
export interface DataTypeAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    isAbstract?: boolean | undefined;
}
export class DataTypeAttributes implements DataTypeAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly isAbstract: boolean;
    constructor(options?: DataTypeAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.isAbstract = options?.isAbstract ?? false;
    }
    static [typeId] = NodeIds.DataTypeAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.isAbstract);
    }
    static [decode](decoder: BinaryDataDecoder): DataTypeAttributes {
        return new DataTypeAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            isAbstract: decoder.readBoolean()
        });
    }
}
export interface ViewAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    containsNoLoops?: boolean | undefined;
    eventNotifier?: Byte | undefined;
}
export class ViewAttributes implements ViewAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly containsNoLoops: boolean;
    readonly eventNotifier: Byte;
    constructor(options?: ViewAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.containsNoLoops = options?.containsNoLoops ?? false;
        this.eventNotifier = options?.eventNotifier ?? 0;
    }
    static [typeId] = NodeIds.ViewAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeBoolean(this.containsNoLoops);
        encoder.writeByte(this.eventNotifier);
    }
    static [decode](decoder: BinaryDataDecoder): ViewAttributes {
        return new ViewAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            containsNoLoops: decoder.readBoolean(),
            eventNotifier: decoder.readByte()
        });
    }
}
export interface GenericAttributeValueOptions {
    attributeId?: UInt32 | undefined;
    value?: Variant | undefined;
}
export class GenericAttributeValue implements GenericAttributeValueOptions {
    readonly attributeId: UInt32;
    readonly value: Variant;
    constructor(options?: GenericAttributeValueOptions) {
        this.attributeId = options?.attributeId ?? 0;
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.GenericAttributeValue_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.attributeId);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): GenericAttributeValue {
        return new GenericAttributeValue({
            attributeId: decoder.readUInt32(),
            value: decoder.readType(Variant)
        });
    }
}
export interface GenericAttributesOptions {
    specifiedAttributes?: UInt32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
    writeMask?: UInt32 | undefined;
    userWriteMask?: UInt32 | undefined;
    attributeValues?: GenericAttributeValue[] | undefined;
}
export class GenericAttributes implements GenericAttributesOptions {
    readonly specifiedAttributes: UInt32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    readonly writeMask: UInt32;
    readonly userWriteMask: UInt32;
    readonly attributeValues?: GenericAttributeValue[];
    constructor(options?: GenericAttributesOptions) {
        this.specifiedAttributes = options?.specifiedAttributes ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
        this.writeMask = options?.writeMask ?? 0;
        this.userWriteMask = options?.userWriteMask ?? 0;
        this.attributeValues = options?.attributeValues;
    }
    static [typeId] = NodeIds.GenericAttributes_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.specifiedAttributes);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
        encoder.writeUInt32(this.writeMask);
        encoder.writeUInt32(this.userWriteMask);
        encoder.writeTypeArray(this.attributeValues);
    }
    static [decode](decoder: BinaryDataDecoder): GenericAttributes {
        return new GenericAttributes({
            specifiedAttributes: decoder.readUInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText),
            writeMask: decoder.readUInt32(),
            userWriteMask: decoder.readUInt32(),
            attributeValues: decoder.readTypeArray(GenericAttributeValue)
        });
    }
}
export interface AddNodesItemOptions {
    parentNodeId?: ExpandedNodeId | undefined;
    referenceTypeId?: NodeId | undefined;
    requestedNewNodeId?: ExpandedNodeId | undefined;
    browseName?: QualifiedName | undefined;
    nodeClass?: NodeClass | undefined;
    nodeAttributes?: ExtensionObject | undefined;
    typeDefinition?: ExpandedNodeId | undefined;
}
export class AddNodesItem implements AddNodesItemOptions {
    readonly parentNodeId: ExpandedNodeId;
    readonly referenceTypeId: NodeId;
    readonly requestedNewNodeId: ExpandedNodeId;
    readonly browseName: QualifiedName;
    readonly nodeClass: NodeClass;
    readonly nodeAttributes: ExtensionObject;
    readonly typeDefinition: ExpandedNodeId;
    constructor(options?: AddNodesItemOptions) {
        this.parentNodeId = options?.parentNodeId ?? new ExpandedNodeId();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.requestedNewNodeId = options?.requestedNewNodeId ?? new ExpandedNodeId();
        this.browseName = options?.browseName ?? new QualifiedName();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.nodeAttributes = options?.nodeAttributes ?? new ExtensionObject();
        this.typeDefinition = options?.typeDefinition ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.AddNodesItem_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.parentNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeType(this.requestedNewNodeId);
        encoder.writeType(this.browseName);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.nodeAttributes);
        encoder.writeType(this.typeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesItem {
        return new AddNodesItem({
            parentNodeId: decoder.readType(ExpandedNodeId),
            referenceTypeId: decoder.readType(NodeId),
            requestedNewNodeId: decoder.readType(ExpandedNodeId),
            browseName: decoder.readType(QualifiedName),
            nodeClass: decoder.readUInt32(),
            nodeAttributes: decoder.readType(ExtensionObject),
            typeDefinition: decoder.readType(ExpandedNodeId)
        });
    }
}
export interface AddNodesResultOptions {
    statusCode?: StatusCode | undefined;
    addedNodeId?: NodeId | undefined;
}
export class AddNodesResult implements AddNodesResultOptions {
    readonly statusCode: StatusCode;
    readonly addedNodeId: NodeId;
    constructor(options?: AddNodesResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.addedNodeId = options?.addedNodeId ?? NodeId.null();
    }
    static [typeId] = NodeIds.AddNodesResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeType(this.addedNodeId);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesResult {
        return new AddNodesResult({
            statusCode: decoder.readType(StatusCode),
            addedNodeId: decoder.readType(NodeId)
        });
    }
}
export interface AddNodesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    nodesToAdd?: AddNodesItem[] | undefined;
}
export class AddNodesRequest implements AddNodesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly nodesToAdd?: AddNodesItem[];
    constructor(options?: AddNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToAdd = options?.nodesToAdd;
    }
    static [typeId] = NodeIds.AddNodesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToAdd);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesRequest {
        return new AddNodesRequest({
            requestHeader: decoder.readType(RequestHeader),
            nodesToAdd: decoder.readTypeArray(AddNodesItem)
        });
    }
}
export interface AddNodesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: AddNodesResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class AddNodesResponse implements AddNodesResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: AddNodesResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: AddNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.AddNodesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): AddNodesResponse {
        return new AddNodesResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(AddNodesResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface AddReferencesItemOptions {
    sourceNodeId?: NodeId | undefined;
    referenceTypeId?: NodeId | undefined;
    isForward?: boolean | undefined;
    targetServerUri?: UaString | undefined;
    targetNodeId?: ExpandedNodeId | undefined;
    targetNodeClass?: NodeClass | undefined;
}
export class AddReferencesItem implements AddReferencesItemOptions {
    readonly sourceNodeId: NodeId;
    readonly referenceTypeId: NodeId;
    readonly isForward: boolean;
    readonly targetServerUri?: UaString;
    readonly targetNodeId: ExpandedNodeId;
    readonly targetNodeClass: NodeClass;
    constructor(options?: AddReferencesItemOptions) {
        this.sourceNodeId = options?.sourceNodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.targetServerUri = options?.targetServerUri;
        this.targetNodeId = options?.targetNodeId ?? new ExpandedNodeId();
        this.targetNodeClass = options?.targetNodeClass ?? NodeClass.Unspecified;
    }
    static [typeId] = NodeIds.AddReferencesItem_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sourceNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeString(this.targetServerUri);
        encoder.writeType(this.targetNodeId);
        encoder.writeUInt32(this.targetNodeClass);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesItem {
        return new AddReferencesItem({
            sourceNodeId: decoder.readType(NodeId),
            referenceTypeId: decoder.readType(NodeId),
            isForward: decoder.readBoolean(),
            targetServerUri: decoder.readString(),
            targetNodeId: decoder.readType(ExpandedNodeId),
            targetNodeClass: decoder.readUInt32()
        });
    }
}
export interface AddReferencesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    referencesToAdd?: AddReferencesItem[] | undefined;
}
export class AddReferencesRequest implements AddReferencesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly referencesToAdd?: AddReferencesItem[];
    constructor(options?: AddReferencesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.referencesToAdd = options?.referencesToAdd;
    }
    static [typeId] = NodeIds.AddReferencesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.referencesToAdd);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesRequest {
        return new AddReferencesRequest({
            requestHeader: decoder.readType(RequestHeader),
            referencesToAdd: decoder.readTypeArray(AddReferencesItem)
        });
    }
}
export interface AddReferencesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class AddReferencesResponse implements AddReferencesResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: AddReferencesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.AddReferencesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): AddReferencesResponse {
        return new AddReferencesResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface DeleteNodesItemOptions {
    nodeId?: NodeId | undefined;
    deleteTargetReferences?: boolean | undefined;
}
export class DeleteNodesItem implements DeleteNodesItemOptions {
    readonly nodeId: NodeId;
    readonly deleteTargetReferences: boolean;
    constructor(options?: DeleteNodesItemOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.deleteTargetReferences = options?.deleteTargetReferences ?? false;
    }
    static [typeId] = NodeIds.DeleteNodesItem_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeBoolean(this.deleteTargetReferences);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesItem {
        return new DeleteNodesItem({
            nodeId: decoder.readType(NodeId),
            deleteTargetReferences: decoder.readBoolean()
        });
    }
}
export interface DeleteNodesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    nodesToDelete?: DeleteNodesItem[] | undefined;
}
export class DeleteNodesRequest implements DeleteNodesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly nodesToDelete?: DeleteNodesItem[];
    constructor(options?: DeleteNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToDelete = options?.nodesToDelete;
    }
    static [typeId] = NodeIds.DeleteNodesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToDelete);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesRequest {
        return new DeleteNodesRequest({
            requestHeader: decoder.readType(RequestHeader),
            nodesToDelete: decoder.readTypeArray(DeleteNodesItem)
        });
    }
}
export interface DeleteNodesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class DeleteNodesResponse implements DeleteNodesResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteNodesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteNodesResponse {
        return new DeleteNodesResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface DeleteReferencesItemOptions {
    sourceNodeId?: NodeId | undefined;
    referenceTypeId?: NodeId | undefined;
    isForward?: boolean | undefined;
    targetNodeId?: ExpandedNodeId | undefined;
    deleteBidirectional?: boolean | undefined;
}
export class DeleteReferencesItem implements DeleteReferencesItemOptions {
    readonly sourceNodeId: NodeId;
    readonly referenceTypeId: NodeId;
    readonly isForward: boolean;
    readonly targetNodeId: ExpandedNodeId;
    readonly deleteBidirectional: boolean;
    constructor(options?: DeleteReferencesItemOptions) {
        this.sourceNodeId = options?.sourceNodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.targetNodeId = options?.targetNodeId ?? new ExpandedNodeId();
        this.deleteBidirectional = options?.deleteBidirectional ?? false;
    }
    static [typeId] = NodeIds.DeleteReferencesItem_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sourceNodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeType(this.targetNodeId);
        encoder.writeBoolean(this.deleteBidirectional);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesItem {
        return new DeleteReferencesItem({
            sourceNodeId: decoder.readType(NodeId),
            referenceTypeId: decoder.readType(NodeId),
            isForward: decoder.readBoolean(),
            targetNodeId: decoder.readType(ExpandedNodeId),
            deleteBidirectional: decoder.readBoolean()
        });
    }
}
export interface DeleteReferencesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    referencesToDelete?: DeleteReferencesItem[] | undefined;
}
export class DeleteReferencesRequest implements DeleteReferencesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly referencesToDelete?: DeleteReferencesItem[];
    constructor(options?: DeleteReferencesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.referencesToDelete = options?.referencesToDelete;
    }
    static [typeId] = NodeIds.DeleteReferencesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.referencesToDelete);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesRequest {
        return new DeleteReferencesRequest({
            requestHeader: decoder.readType(RequestHeader),
            referencesToDelete: decoder.readTypeArray(DeleteReferencesItem)
        });
    }
}
export interface DeleteReferencesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class DeleteReferencesResponse implements DeleteReferencesResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteReferencesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteReferencesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteReferencesResponse {
        return new DeleteReferencesResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export enum AttributeWriteMask {
    None = 0,
    AccessLevel = 1,
    ArrayDimensions = 2,
    BrowseName = 4,
    ContainsNoLoops = 8,
    DataType = 16,
    Description = 32,
    DisplayName = 64,
    EventNotifier = 128,
    Executable = 256,
    Historizing = 512,
    InverseName = 1024,
    IsAbstract = 2048,
    MinimumSamplingInterval = 4096,
    NodeClass = 8192,
    NodeId = 16384,
    Symmetric = 32768,
    UserAccessLevel = 65536,
    UserExecutable = 131072,
    UserWriteMask = 262144,
    ValueRank = 524288,
    WriteMask = 1048576,
    ValueForVariableType = 2097152,
    DataTypeDefinition = 4194304,
    RolePermissions = 8388608,
    AccessRestrictions = 16777216,
    AccessLevelEx = 33554432
}
export enum BrowseDirection {
    Forward = 0,
    Inverse = 1,
    Both = 2,
    Invalid = 3
}
export interface ViewDescriptionOptions {
    viewId?: NodeId | undefined;
    timestamp?: Date | undefined;
    viewVersion?: UInt32 | undefined;
}
export class ViewDescription implements ViewDescriptionOptions {
    readonly viewId: NodeId;
    readonly timestamp: Date;
    readonly viewVersion: UInt32;
    constructor(options?: ViewDescriptionOptions) {
        this.viewId = options?.viewId ?? NodeId.null();
        this.timestamp = options?.timestamp ?? new Date(-11644473600000);
        this.viewVersion = options?.viewVersion ?? 0;
    }
    static [typeId] = NodeIds.ViewDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.viewId);
        encoder.writeDateTime(this.timestamp);
        encoder.writeUInt32(this.viewVersion);
    }
    static [decode](decoder: BinaryDataDecoder): ViewDescription {
        return new ViewDescription({
            viewId: decoder.readType(NodeId),
            timestamp: decoder.readDateTime(),
            viewVersion: decoder.readUInt32()
        });
    }
}
export interface BrowseDescriptionOptions {
    nodeId?: NodeId | undefined;
    browseDirection?: BrowseDirection | undefined;
    referenceTypeId?: NodeId | undefined;
    includeSubtypes?: boolean | undefined;
    nodeClassMask?: UInt32 | undefined;
    resultMask?: UInt32 | undefined;
}
export class BrowseDescription implements BrowseDescriptionOptions {
    readonly nodeId: NodeId;
    readonly browseDirection: BrowseDirection;
    readonly referenceTypeId: NodeId;
    readonly includeSubtypes: boolean;
    readonly nodeClassMask: UInt32;
    readonly resultMask: UInt32;
    constructor(options?: BrowseDescriptionOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.browseDirection = options?.browseDirection ?? BrowseDirection.Forward;
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.includeSubtypes = options?.includeSubtypes ?? false;
        this.nodeClassMask = options?.nodeClassMask ?? 0;
        this.resultMask = options?.resultMask ?? 0;
    }
    static [typeId] = NodeIds.BrowseDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.browseDirection);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.includeSubtypes);
        encoder.writeUInt32(this.nodeClassMask);
        encoder.writeUInt32(this.resultMask);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseDescription {
        return new BrowseDescription({
            nodeId: decoder.readType(NodeId),
            browseDirection: decoder.readUInt32(),
            referenceTypeId: decoder.readType(NodeId),
            includeSubtypes: decoder.readBoolean(),
            nodeClassMask: decoder.readUInt32(),
            resultMask: decoder.readUInt32()
        });
    }
}
export enum BrowseResultMask {
    None = 0,
    ReferenceTypeId = 1,
    IsForward = 2,
    NodeClass = 4,
    BrowseName = 8,
    DisplayName = 16,
    TypeDefinition = 32,
    All = 63,
    ReferenceTypeInfo = 3,
    TargetInfo = 60
}
export interface ReferenceDescriptionOptions {
    referenceTypeId?: NodeId | undefined;
    isForward?: boolean | undefined;
    nodeId?: ExpandedNodeId | undefined;
    browseName?: QualifiedName | undefined;
    displayName?: LocalizedText | undefined;
    nodeClass?: NodeClass | undefined;
    typeDefinition?: ExpandedNodeId | undefined;
}
export class ReferenceDescription implements ReferenceDescriptionOptions {
    readonly referenceTypeId: NodeId;
    readonly isForward: boolean;
    readonly nodeId: ExpandedNodeId;
    readonly browseName: QualifiedName;
    readonly displayName: LocalizedText;
    readonly nodeClass: NodeClass;
    readonly typeDefinition: ExpandedNodeId;
    constructor(options?: ReferenceDescriptionOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.nodeId = options?.nodeId ?? new ExpandedNodeId();
        this.browseName = options?.browseName ?? new QualifiedName();
        this.displayName = options?.displayName ?? new LocalizedText();
        this.nodeClass = options?.nodeClass ?? NodeClass.Unspecified;
        this.typeDefinition = options?.typeDefinition ?? new ExpandedNodeId();
    }
    static [typeId] = NodeIds.ReferenceDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeType(this.nodeId);
        encoder.writeType(this.browseName);
        encoder.writeType(this.displayName);
        encoder.writeUInt32(this.nodeClass);
        encoder.writeType(this.typeDefinition);
    }
    static [decode](decoder: BinaryDataDecoder): ReferenceDescription {
        return new ReferenceDescription({
            referenceTypeId: decoder.readType(NodeId),
            isForward: decoder.readBoolean(),
            nodeId: decoder.readType(ExpandedNodeId),
            browseName: decoder.readType(QualifiedName),
            displayName: decoder.readType(LocalizedText),
            nodeClass: decoder.readUInt32(),
            typeDefinition: decoder.readType(ExpandedNodeId)
        });
    }
}
export interface BrowseResultOptions {
    statusCode?: StatusCode | undefined;
    continuationPoint?: ByteString | undefined;
    references?: ReferenceDescription[] | undefined;
}
export class BrowseResult implements BrowseResultOptions {
    readonly statusCode: StatusCode;
    readonly continuationPoint?: ByteString;
    readonly references?: ReferenceDescription[];
    constructor(options?: BrowseResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.continuationPoint = options?.continuationPoint;
        this.references = options?.references;
    }
    static [typeId] = NodeIds.BrowseResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeTypeArray(this.references);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseResult {
        return new BrowseResult({
            statusCode: decoder.readType(StatusCode),
            continuationPoint: decoder.readByteString(),
            references: decoder.readTypeArray(ReferenceDescription)
        });
    }
}
export interface BrowseRequestOptions {
    requestHeader?: RequestHeader | undefined;
    view?: ViewDescription | undefined;
    requestedMaxReferencesPerNode?: UInt32 | undefined;
    nodesToBrowse?: BrowseDescription[] | undefined;
}
export class BrowseRequest implements BrowseRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly view: ViewDescription;
    readonly requestedMaxReferencesPerNode: UInt32;
    readonly nodesToBrowse?: BrowseDescription[];
    constructor(options?: BrowseRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.view = options?.view ?? new ViewDescription();
        this.requestedMaxReferencesPerNode = options?.requestedMaxReferencesPerNode ?? 0;
        this.nodesToBrowse = options?.nodesToBrowse;
    }
    static [typeId] = NodeIds.BrowseRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.view);
        encoder.writeUInt32(this.requestedMaxReferencesPerNode);
        encoder.writeTypeArray(this.nodesToBrowse);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseRequest {
        return new BrowseRequest({
            requestHeader: decoder.readType(RequestHeader),
            view: decoder.readType(ViewDescription),
            requestedMaxReferencesPerNode: decoder.readUInt32(),
            nodesToBrowse: decoder.readTypeArray(BrowseDescription)
        });
    }
}
export interface BrowseResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: BrowseResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class BrowseResponse implements BrowseResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: BrowseResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: BrowseResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.BrowseResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseResponse {
        return new BrowseResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(BrowseResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface BrowseNextRequestOptions {
    requestHeader?: RequestHeader | undefined;
    releaseContinuationPoints?: boolean | undefined;
    continuationPoints?: ByteString[] | undefined;
}
export class BrowseNextRequest implements BrowseNextRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly releaseContinuationPoints: boolean;
    readonly continuationPoints?: ByteString[];
    constructor(options?: BrowseNextRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.releaseContinuationPoints = options?.releaseContinuationPoints ?? false;
        this.continuationPoints = options?.continuationPoints;
    }
    static [typeId] = NodeIds.BrowseNextRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.releaseContinuationPoints);
        encoder.writeByteStringArray(this.continuationPoints);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseNextRequest {
        return new BrowseNextRequest({
            requestHeader: decoder.readType(RequestHeader),
            releaseContinuationPoints: decoder.readBoolean(),
            continuationPoints: decoder.readByteStringArray()
        });
    }
}
export interface BrowseNextResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: BrowseResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class BrowseNextResponse implements BrowseNextResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: BrowseResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: BrowseNextResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.BrowseNextResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): BrowseNextResponse {
        return new BrowseNextResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(BrowseResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface RelativePathElementOptions {
    referenceTypeId?: NodeId | undefined;
    isInverse?: boolean | undefined;
    includeSubtypes?: boolean | undefined;
    targetName?: QualifiedName | undefined;
}
export class RelativePathElement implements RelativePathElementOptions {
    readonly referenceTypeId: NodeId;
    readonly isInverse: boolean;
    readonly includeSubtypes: boolean;
    readonly targetName: QualifiedName;
    constructor(options?: RelativePathElementOptions) {
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isInverse = options?.isInverse ?? false;
        this.includeSubtypes = options?.includeSubtypes ?? false;
        this.targetName = options?.targetName ?? new QualifiedName();
    }
    static [typeId] = NodeIds.RelativePathElement_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isInverse);
        encoder.writeBoolean(this.includeSubtypes);
        encoder.writeType(this.targetName);
    }
    static [decode](decoder: BinaryDataDecoder): RelativePathElement {
        return new RelativePathElement({
            referenceTypeId: decoder.readType(NodeId),
            isInverse: decoder.readBoolean(),
            includeSubtypes: decoder.readBoolean(),
            targetName: decoder.readType(QualifiedName)
        });
    }
}
export interface RelativePathOptions {
    elements?: RelativePathElement[] | undefined;
}
export class RelativePath implements RelativePathOptions {
    readonly elements?: RelativePathElement[];
    constructor(options?: RelativePathOptions) {
        this.elements = options?.elements;
    }
    static [typeId] = NodeIds.RelativePath_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elements);
    }
    static [decode](decoder: BinaryDataDecoder): RelativePath {
        return new RelativePath({
            elements: decoder.readTypeArray(RelativePathElement)
        });
    }
}
export interface BrowsePathOptions {
    startingNode?: NodeId | undefined;
    relativePath?: RelativePath | undefined;
}
export class BrowsePath implements BrowsePathOptions {
    readonly startingNode: NodeId;
    readonly relativePath: RelativePath;
    constructor(options?: BrowsePathOptions) {
        this.startingNode = options?.startingNode ?? NodeId.null();
        this.relativePath = options?.relativePath ?? new RelativePath();
    }
    static [typeId] = NodeIds.BrowsePath_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.startingNode);
        encoder.writeType(this.relativePath);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePath {
        return new BrowsePath({
            startingNode: decoder.readType(NodeId),
            relativePath: decoder.readType(RelativePath)
        });
    }
}
export interface BrowsePathTargetOptions {
    targetId?: ExpandedNodeId | undefined;
    remainingPathIndex?: UInt32 | undefined;
}
export class BrowsePathTarget implements BrowsePathTargetOptions {
    readonly targetId: ExpandedNodeId;
    readonly remainingPathIndex: UInt32;
    constructor(options?: BrowsePathTargetOptions) {
        this.targetId = options?.targetId ?? new ExpandedNodeId();
        this.remainingPathIndex = options?.remainingPathIndex ?? 0;
    }
    static [typeId] = NodeIds.BrowsePathTarget_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.targetId);
        encoder.writeUInt32(this.remainingPathIndex);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePathTarget {
        return new BrowsePathTarget({
            targetId: decoder.readType(ExpandedNodeId),
            remainingPathIndex: decoder.readUInt32()
        });
    }
}
export interface BrowsePathResultOptions {
    statusCode?: StatusCode | undefined;
    targets?: BrowsePathTarget[] | undefined;
}
export class BrowsePathResult implements BrowsePathResultOptions {
    readonly statusCode: StatusCode;
    readonly targets?: BrowsePathTarget[];
    constructor(options?: BrowsePathResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.targets = options?.targets;
    }
    static [typeId] = NodeIds.BrowsePathResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.targets);
    }
    static [decode](decoder: BinaryDataDecoder): BrowsePathResult {
        return new BrowsePathResult({
            statusCode: decoder.readType(StatusCode),
            targets: decoder.readTypeArray(BrowsePathTarget)
        });
    }
}
export interface TranslateBrowsePathsToNodeIdsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    browsePaths?: BrowsePath[] | undefined;
}
export class TranslateBrowsePathsToNodeIdsRequest implements TranslateBrowsePathsToNodeIdsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly browsePaths?: BrowsePath[];
    constructor(options?: TranslateBrowsePathsToNodeIdsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.browsePaths = options?.browsePaths;
    }
    static [typeId] = NodeIds.TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.browsePaths);
    }
    static [decode](decoder: BinaryDataDecoder): TranslateBrowsePathsToNodeIdsRequest {
        return new TranslateBrowsePathsToNodeIdsRequest({
            requestHeader: decoder.readType(RequestHeader),
            browsePaths: decoder.readTypeArray(BrowsePath)
        });
    }
}
export interface TranslateBrowsePathsToNodeIdsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: BrowsePathResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class TranslateBrowsePathsToNodeIdsResponse implements TranslateBrowsePathsToNodeIdsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: BrowsePathResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: TranslateBrowsePathsToNodeIdsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.TranslateBrowsePathsToNodeIdsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): TranslateBrowsePathsToNodeIdsResponse {
        return new TranslateBrowsePathsToNodeIdsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(BrowsePathResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface RegisterNodesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    nodesToRegister?: NodeId[] | undefined;
}
export class RegisterNodesRequest implements RegisterNodesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly nodesToRegister?: NodeId[];
    constructor(options?: RegisterNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToRegister = options?.nodesToRegister;
    }
    static [typeId] = NodeIds.RegisterNodesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToRegister);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterNodesRequest {
        return new RegisterNodesRequest({
            requestHeader: decoder.readType(RequestHeader),
            nodesToRegister: decoder.readTypeArray(NodeId)
        });
    }
}
export interface RegisterNodesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    registeredNodeIds?: NodeId[] | undefined;
}
export class RegisterNodesResponse implements RegisterNodesResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly registeredNodeIds?: NodeId[];
    constructor(options?: RegisterNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.registeredNodeIds = options?.registeredNodeIds;
    }
    static [typeId] = NodeIds.RegisterNodesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.registeredNodeIds);
    }
    static [decode](decoder: BinaryDataDecoder): RegisterNodesResponse {
        return new RegisterNodesResponse({
            responseHeader: decoder.readType(ResponseHeader),
            registeredNodeIds: decoder.readTypeArray(NodeId)
        });
    }
}
export interface UnregisterNodesRequestOptions {
    requestHeader?: RequestHeader | undefined;
    nodesToUnregister?: NodeId[] | undefined;
}
export class UnregisterNodesRequest implements UnregisterNodesRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly nodesToUnregister?: NodeId[];
    constructor(options?: UnregisterNodesRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToUnregister = options?.nodesToUnregister;
    }
    static [typeId] = NodeIds.UnregisterNodesRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToUnregister);
    }
    static [decode](decoder: BinaryDataDecoder): UnregisterNodesRequest {
        return new UnregisterNodesRequest({
            requestHeader: decoder.readType(RequestHeader),
            nodesToUnregister: decoder.readTypeArray(NodeId)
        });
    }
}
export interface UnregisterNodesResponseOptions {
    responseHeader?: ResponseHeader | undefined;
}
export class UnregisterNodesResponse implements UnregisterNodesResponseOptions {
    readonly responseHeader: ResponseHeader;
    constructor(options?: UnregisterNodesResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
    }
    static [typeId] = NodeIds.UnregisterNodesResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
    }
    static [decode](decoder: BinaryDataDecoder): UnregisterNodesResponse {
        return new UnregisterNodesResponse({
            responseHeader: decoder.readType(ResponseHeader)
        });
    }
}
export interface EndpointConfigurationOptions {
    operationTimeout?: Int32 | undefined;
    useBinaryEncoding?: boolean | undefined;
    maxStringLength?: Int32 | undefined;
    maxByteStringLength?: Int32 | undefined;
    maxArrayLength?: Int32 | undefined;
    maxMessageSize?: Int32 | undefined;
    maxBufferSize?: Int32 | undefined;
    channelLifetime?: Int32 | undefined;
    securityTokenLifetime?: Int32 | undefined;
}
export class EndpointConfiguration implements EndpointConfigurationOptions {
    readonly operationTimeout: Int32;
    readonly useBinaryEncoding: boolean;
    readonly maxStringLength: Int32;
    readonly maxByteStringLength: Int32;
    readonly maxArrayLength: Int32;
    readonly maxMessageSize: Int32;
    readonly maxBufferSize: Int32;
    readonly channelLifetime: Int32;
    readonly securityTokenLifetime: Int32;
    constructor(options?: EndpointConfigurationOptions) {
        this.operationTimeout = options?.operationTimeout ?? 0;
        this.useBinaryEncoding = options?.useBinaryEncoding ?? false;
        this.maxStringLength = options?.maxStringLength ?? 0;
        this.maxByteStringLength = options?.maxByteStringLength ?? 0;
        this.maxArrayLength = options?.maxArrayLength ?? 0;
        this.maxMessageSize = options?.maxMessageSize ?? 0;
        this.maxBufferSize = options?.maxBufferSize ?? 0;
        this.channelLifetime = options?.channelLifetime ?? 0;
        this.securityTokenLifetime = options?.securityTokenLifetime ?? 0;
    }
    static [typeId] = NodeIds.EndpointConfiguration_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeInt32(this.operationTimeout);
        encoder.writeBoolean(this.useBinaryEncoding);
        encoder.writeInt32(this.maxStringLength);
        encoder.writeInt32(this.maxByteStringLength);
        encoder.writeInt32(this.maxArrayLength);
        encoder.writeInt32(this.maxMessageSize);
        encoder.writeInt32(this.maxBufferSize);
        encoder.writeInt32(this.channelLifetime);
        encoder.writeInt32(this.securityTokenLifetime);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointConfiguration {
        return new EndpointConfiguration({
            operationTimeout: decoder.readInt32(),
            useBinaryEncoding: decoder.readBoolean(),
            maxStringLength: decoder.readInt32(),
            maxByteStringLength: decoder.readInt32(),
            maxArrayLength: decoder.readInt32(),
            maxMessageSize: decoder.readInt32(),
            maxBufferSize: decoder.readInt32(),
            channelLifetime: decoder.readInt32(),
            securityTokenLifetime: decoder.readInt32()
        });
    }
}
export interface QueryDataDescriptionOptions {
    relativePath?: RelativePath | undefined;
    attributeId?: UInt32 | undefined;
    indexRange?: UaString | undefined;
}
export class QueryDataDescription implements QueryDataDescriptionOptions {
    readonly relativePath: RelativePath;
    readonly attributeId: UInt32;
    readonly indexRange?: UaString;
    constructor(options?: QueryDataDescriptionOptions) {
        this.relativePath = options?.relativePath ?? new RelativePath();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.QueryDataDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.relativePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): QueryDataDescription {
        return new QueryDataDescription({
            relativePath: decoder.readType(RelativePath),
            attributeId: decoder.readUInt32(),
            indexRange: decoder.readString()
        });
    }
}
export interface NodeTypeDescriptionOptions {
    typeDefinitionNode?: ExpandedNodeId | undefined;
    includeSubTypes?: boolean | undefined;
    dataToReturn?: QueryDataDescription[] | undefined;
}
export class NodeTypeDescription implements NodeTypeDescriptionOptions {
    readonly typeDefinitionNode: ExpandedNodeId;
    readonly includeSubTypes: boolean;
    readonly dataToReturn?: QueryDataDescription[];
    constructor(options?: NodeTypeDescriptionOptions) {
        this.typeDefinitionNode = options?.typeDefinitionNode ?? new ExpandedNodeId();
        this.includeSubTypes = options?.includeSubTypes ?? false;
        this.dataToReturn = options?.dataToReturn;
    }
    static [typeId] = NodeIds.NodeTypeDescription_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.typeDefinitionNode);
        encoder.writeBoolean(this.includeSubTypes);
        encoder.writeTypeArray(this.dataToReturn);
    }
    static [decode](decoder: BinaryDataDecoder): NodeTypeDescription {
        return new NodeTypeDescription({
            typeDefinitionNode: decoder.readType(ExpandedNodeId),
            includeSubTypes: decoder.readBoolean(),
            dataToReturn: decoder.readTypeArray(QueryDataDescription)
        });
    }
}
export enum FilterOperator {
    Equals = 0,
    IsNull = 1,
    GreaterThan = 2,
    LessThan = 3,
    GreaterThanOrEqual = 4,
    LessThanOrEqual = 5,
    Like = 6,
    Not = 7,
    Between = 8,
    InList = 9,
    And = 10,
    Or = 11,
    Cast = 12,
    InView = 13,
    OfType = 14,
    RelatedTo = 15,
    BitwiseAnd = 16,
    BitwiseOr = 17
}
export interface QueryDataSetOptions {
    nodeId?: ExpandedNodeId | undefined;
    typeDefinitionNode?: ExpandedNodeId | undefined;
    values?: Variant[] | undefined;
}
export class QueryDataSet implements QueryDataSetOptions {
    readonly nodeId: ExpandedNodeId;
    readonly typeDefinitionNode: ExpandedNodeId;
    readonly values?: Variant[];
    constructor(options?: QueryDataSetOptions) {
        this.nodeId = options?.nodeId ?? new ExpandedNodeId();
        this.typeDefinitionNode = options?.typeDefinitionNode ?? new ExpandedNodeId();
        this.values = options?.values;
    }
    static [typeId] = NodeIds.QueryDataSet_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeType(this.typeDefinitionNode);
        encoder.writeTypeArray(this.values);
    }
    static [decode](decoder: BinaryDataDecoder): QueryDataSet {
        return new QueryDataSet({
            nodeId: decoder.readType(ExpandedNodeId),
            typeDefinitionNode: decoder.readType(ExpandedNodeId),
            values: decoder.readTypeArray(Variant)
        });
    }
}
export interface NodeReferenceOptions {
    nodeId?: NodeId | undefined;
    referenceTypeId?: NodeId | undefined;
    isForward?: boolean | undefined;
    referencedNodeIds?: NodeId[] | undefined;
}
export class NodeReference implements NodeReferenceOptions {
    readonly nodeId: NodeId;
    readonly referenceTypeId: NodeId;
    readonly isForward: boolean;
    readonly referencedNodeIds?: NodeId[];
    constructor(options?: NodeReferenceOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.referenceTypeId = options?.referenceTypeId ?? NodeId.null();
        this.isForward = options?.isForward ?? false;
        this.referencedNodeIds = options?.referencedNodeIds;
    }
    static [typeId] = NodeIds.NodeReference_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeType(this.referenceTypeId);
        encoder.writeBoolean(this.isForward);
        encoder.writeTypeArray(this.referencedNodeIds);
    }
    static [decode](decoder: BinaryDataDecoder): NodeReference {
        return new NodeReference({
            nodeId: decoder.readType(NodeId),
            referenceTypeId: decoder.readType(NodeId),
            isForward: decoder.readBoolean(),
            referencedNodeIds: decoder.readTypeArray(NodeId)
        });
    }
}
export interface ContentFilterElementOptions {
    filterOperator?: FilterOperator | undefined;
    filterOperands?: ExtensionObject[] | undefined;
}
export class ContentFilterElement implements ContentFilterElementOptions {
    readonly filterOperator: FilterOperator;
    readonly filterOperands?: ExtensionObject[];
    constructor(options?: ContentFilterElementOptions) {
        this.filterOperator = options?.filterOperator ?? FilterOperator.Equals;
        this.filterOperands = options?.filterOperands;
    }
    static [typeId] = NodeIds.ContentFilterElement_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.filterOperator);
        encoder.writeTypeArray(this.filterOperands);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterElement {
        return new ContentFilterElement({
            filterOperator: decoder.readUInt32(),
            filterOperands: decoder.readTypeArray(ExtensionObject)
        });
    }
}
export interface ContentFilterOptions {
    elements?: ContentFilterElement[] | undefined;
}
export class ContentFilter implements ContentFilterOptions {
    readonly elements?: ContentFilterElement[];
    constructor(options?: ContentFilterOptions) {
        this.elements = options?.elements;
    }
    static [typeId] = NodeIds.ContentFilter_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elements);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilter {
        return new ContentFilter({
            elements: decoder.readTypeArray(ContentFilterElement)
        });
    }
}
export class FilterOperand {
    static [typeId] = NodeIds.FilterOperand_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): FilterOperand {
        return new FilterOperand();
    }
}
export interface ElementOperandOptions {
    index?: UInt32 | undefined;
}
export class ElementOperand implements ElementOperandOptions {
    readonly index: UInt32;
    constructor(options?: ElementOperandOptions) {
        this.index = options?.index ?? 0;
    }
    static [typeId] = NodeIds.ElementOperand_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.index);
    }
    static [decode](decoder: BinaryDataDecoder): ElementOperand {
        return new ElementOperand({
            index: decoder.readUInt32()
        });
    }
}
export interface LiteralOperandOptions {
    value?: Variant | undefined;
}
export class LiteralOperand implements LiteralOperandOptions {
    readonly value: Variant;
    constructor(options?: LiteralOperandOptions) {
        this.value = options?.value ?? Variant.null();
    }
    static [typeId] = NodeIds.LiteralOperand_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): LiteralOperand {
        return new LiteralOperand({
            value: decoder.readType(Variant)
        });
    }
}
export interface AttributeOperandOptions {
    nodeId?: NodeId | undefined;
    alias?: UaString | undefined;
    browsePath?: RelativePath | undefined;
    attributeId?: UInt32 | undefined;
    indexRange?: UaString | undefined;
}
export class AttributeOperand implements AttributeOperandOptions {
    readonly nodeId: NodeId;
    readonly alias?: UaString;
    readonly browsePath: RelativePath;
    readonly attributeId: UInt32;
    readonly indexRange?: UaString;
    constructor(options?: AttributeOperandOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.alias = options?.alias;
        this.browsePath = options?.browsePath ?? new RelativePath();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.AttributeOperand_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeString(this.alias);
        encoder.writeType(this.browsePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): AttributeOperand {
        return new AttributeOperand({
            nodeId: decoder.readType(NodeId),
            alias: decoder.readString(),
            browsePath: decoder.readType(RelativePath),
            attributeId: decoder.readUInt32(),
            indexRange: decoder.readString()
        });
    }
}
export interface SimpleAttributeOperandOptions {
    typeDefinitionId?: NodeId | undefined;
    browsePath?: QualifiedName[] | undefined;
    attributeId?: UInt32 | undefined;
    indexRange?: UaString | undefined;
}
export class SimpleAttributeOperand implements SimpleAttributeOperandOptions {
    readonly typeDefinitionId: NodeId;
    readonly browsePath?: QualifiedName[];
    readonly attributeId: UInt32;
    readonly indexRange?: UaString;
    constructor(options?: SimpleAttributeOperandOptions) {
        this.typeDefinitionId = options?.typeDefinitionId ?? NodeId.null();
        this.browsePath = options?.browsePath;
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
    }
    static [typeId] = NodeIds.SimpleAttributeOperand_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.typeDefinitionId);
        encoder.writeTypeArray(this.browsePath);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
    }
    static [decode](decoder: BinaryDataDecoder): SimpleAttributeOperand {
        return new SimpleAttributeOperand({
            typeDefinitionId: decoder.readType(NodeId),
            browsePath: decoder.readTypeArray(QualifiedName),
            attributeId: decoder.readUInt32(),
            indexRange: decoder.readString()
        });
    }
}
export interface ContentFilterElementResultOptions {
    statusCode?: StatusCode | undefined;
    operandStatusCodes?: StatusCode[] | undefined;
    operandDiagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ContentFilterElementResult implements ContentFilterElementResultOptions {
    readonly statusCode: StatusCode;
    readonly operandStatusCodes?: StatusCode[];
    readonly operandDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ContentFilterElementResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.operandStatusCodes = options?.operandStatusCodes;
        this.operandDiagnosticInfos = options?.operandDiagnosticInfos;
    }
    static [typeId] = NodeIds.ContentFilterElementResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.operandStatusCodes);
        encoder.writeTypeArray(this.operandDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterElementResult {
        return new ContentFilterElementResult({
            statusCode: decoder.readType(StatusCode),
            operandStatusCodes: decoder.readTypeArray(StatusCode),
            operandDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface ContentFilterResultOptions {
    elementResults?: ContentFilterElementResult[] | undefined;
    elementDiagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ContentFilterResult implements ContentFilterResultOptions {
    readonly elementResults?: ContentFilterElementResult[];
    readonly elementDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ContentFilterResultOptions) {
        this.elementResults = options?.elementResults;
        this.elementDiagnosticInfos = options?.elementDiagnosticInfos;
    }
    static [typeId] = NodeIds.ContentFilterResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.elementResults);
        encoder.writeTypeArray(this.elementDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ContentFilterResult {
        return new ContentFilterResult({
            elementResults: decoder.readTypeArray(ContentFilterElementResult),
            elementDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface ParsingResultOptions {
    statusCode?: StatusCode | undefined;
    dataStatusCodes?: StatusCode[] | undefined;
    dataDiagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ParsingResult implements ParsingResultOptions {
    readonly statusCode: StatusCode;
    readonly dataStatusCodes?: StatusCode[];
    readonly dataDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ParsingResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.dataStatusCodes = options?.dataStatusCodes;
        this.dataDiagnosticInfos = options?.dataDiagnosticInfos;
    }
    static [typeId] = NodeIds.ParsingResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.dataStatusCodes);
        encoder.writeTypeArray(this.dataDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ParsingResult {
        return new ParsingResult({
            statusCode: decoder.readType(StatusCode),
            dataStatusCodes: decoder.readTypeArray(StatusCode),
            dataDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface QueryFirstRequestOptions {
    requestHeader?: RequestHeader | undefined;
    view?: ViewDescription | undefined;
    nodeTypes?: NodeTypeDescription[] | undefined;
    filter?: ContentFilter | undefined;
    maxDataSetsToReturn?: UInt32 | undefined;
    maxReferencesToReturn?: UInt32 | undefined;
}
export class QueryFirstRequest implements QueryFirstRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly view: ViewDescription;
    readonly nodeTypes?: NodeTypeDescription[];
    readonly filter: ContentFilter;
    readonly maxDataSetsToReturn: UInt32;
    readonly maxReferencesToReturn: UInt32;
    constructor(options?: QueryFirstRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.view = options?.view ?? new ViewDescription();
        this.nodeTypes = options?.nodeTypes;
        this.filter = options?.filter ?? new ContentFilter();
        this.maxDataSetsToReturn = options?.maxDataSetsToReturn ?? 0;
        this.maxReferencesToReturn = options?.maxReferencesToReturn ?? 0;
    }
    static [typeId] = NodeIds.QueryFirstRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.view);
        encoder.writeTypeArray(this.nodeTypes);
        encoder.writeType(this.filter);
        encoder.writeUInt32(this.maxDataSetsToReturn);
        encoder.writeUInt32(this.maxReferencesToReturn);
    }
    static [decode](decoder: BinaryDataDecoder): QueryFirstRequest {
        return new QueryFirstRequest({
            requestHeader: decoder.readType(RequestHeader),
            view: decoder.readType(ViewDescription),
            nodeTypes: decoder.readTypeArray(NodeTypeDescription),
            filter: decoder.readType(ContentFilter),
            maxDataSetsToReturn: decoder.readUInt32(),
            maxReferencesToReturn: decoder.readUInt32()
        });
    }
}
export interface QueryFirstResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    queryDataSets?: QueryDataSet[] | undefined;
    continuationPoint?: ByteString | undefined;
    parsingResults?: ParsingResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
    filterResult?: ContentFilterResult | undefined;
}
export class QueryFirstResponse implements QueryFirstResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly queryDataSets?: QueryDataSet[];
    readonly continuationPoint?: ByteString;
    readonly parsingResults?: ParsingResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    readonly filterResult: ContentFilterResult;
    constructor(options?: QueryFirstResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.queryDataSets = options?.queryDataSets;
        this.continuationPoint = options?.continuationPoint;
        this.parsingResults = options?.parsingResults;
        this.diagnosticInfos = options?.diagnosticInfos;
        this.filterResult = options?.filterResult ?? new ContentFilterResult();
    }
    static [typeId] = NodeIds.QueryFirstResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.queryDataSets);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeTypeArray(this.parsingResults);
        encoder.writeTypeArray(this.diagnosticInfos);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): QueryFirstResponse {
        return new QueryFirstResponse({
            responseHeader: decoder.readType(ResponseHeader),
            queryDataSets: decoder.readTypeArray(QueryDataSet),
            continuationPoint: decoder.readByteString(),
            parsingResults: decoder.readTypeArray(ParsingResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo),
            filterResult: decoder.readType(ContentFilterResult)
        });
    }
}
export interface QueryNextRequestOptions {
    requestHeader?: RequestHeader | undefined;
    releaseContinuationPoint?: boolean | undefined;
    continuationPoint?: ByteString | undefined;
}
export class QueryNextRequest implements QueryNextRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly releaseContinuationPoint: boolean;
    readonly continuationPoint?: ByteString;
    constructor(options?: QueryNextRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.releaseContinuationPoint = options?.releaseContinuationPoint ?? false;
        this.continuationPoint = options?.continuationPoint;
    }
    static [typeId] = NodeIds.QueryNextRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.releaseContinuationPoint);
        encoder.writeByteString(this.continuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): QueryNextRequest {
        return new QueryNextRequest({
            requestHeader: decoder.readType(RequestHeader),
            releaseContinuationPoint: decoder.readBoolean(),
            continuationPoint: decoder.readByteString()
        });
    }
}
export interface QueryNextResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    queryDataSets?: QueryDataSet[] | undefined;
    revisedContinuationPoint?: ByteString | undefined;
}
export class QueryNextResponse implements QueryNextResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly queryDataSets?: QueryDataSet[];
    readonly revisedContinuationPoint?: ByteString;
    constructor(options?: QueryNextResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.queryDataSets = options?.queryDataSets;
        this.revisedContinuationPoint = options?.revisedContinuationPoint;
    }
    static [typeId] = NodeIds.QueryNextResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.queryDataSets);
        encoder.writeByteString(this.revisedContinuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): QueryNextResponse {
        return new QueryNextResponse({
            responseHeader: decoder.readType(ResponseHeader),
            queryDataSets: decoder.readTypeArray(QueryDataSet),
            revisedContinuationPoint: decoder.readByteString()
        });
    }
}
export enum TimestampsToReturn {
    Source = 0,
    Server = 1,
    Both = 2,
    Neither = 3,
    Invalid = 4
}
export interface ReadValueIdOptions {
    nodeId?: NodeId | undefined;
    attributeId?: UInt32 | undefined;
    indexRange?: UaString | undefined;
    dataEncoding?: QualifiedName | undefined;
}
export class ReadValueId implements ReadValueIdOptions {
    readonly nodeId: NodeId;
    readonly attributeId: UInt32;
    readonly indexRange?: UaString;
    readonly dataEncoding: QualifiedName;
    constructor(options?: ReadValueIdOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
        this.dataEncoding = options?.dataEncoding ?? new QualifiedName();
    }
    static [typeId] = NodeIds.ReadValueId_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.dataEncoding);
    }
    static [decode](decoder: BinaryDataDecoder): ReadValueId {
        return new ReadValueId({
            nodeId: decoder.readType(NodeId),
            attributeId: decoder.readUInt32(),
            indexRange: decoder.readString(),
            dataEncoding: decoder.readType(QualifiedName)
        });
    }
}
export interface ReadRequestOptions {
    requestHeader?: RequestHeader | undefined;
    maxAge?: Double | undefined;
    timestampsToReturn?: TimestampsToReturn | undefined;
    nodesToRead?: ReadValueId[] | undefined;
}
export class ReadRequest implements ReadRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly maxAge: Double;
    readonly timestampsToReturn: TimestampsToReturn;
    readonly nodesToRead?: ReadValueId[];
    constructor(options?: ReadRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.maxAge = options?.maxAge ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.nodesToRead = options?.nodesToRead;
    }
    static [typeId] = NodeIds.ReadRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeDouble(this.maxAge);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.nodesToRead);
    }
    static [decode](decoder: BinaryDataDecoder): ReadRequest {
        return new ReadRequest({
            requestHeader: decoder.readType(RequestHeader),
            maxAge: decoder.readDouble(),
            timestampsToReturn: decoder.readUInt32(),
            nodesToRead: decoder.readTypeArray(ReadValueId)
        });
    }
}
export interface ReadResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: DataValue[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ReadResponse implements ReadResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: DataValue[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ReadResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ReadResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ReadResponse {
        return new ReadResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(DataValue),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface HistoryReadValueIdOptions {
    nodeId?: NodeId | undefined;
    indexRange?: UaString | undefined;
    dataEncoding?: QualifiedName | undefined;
    continuationPoint?: ByteString | undefined;
}
export class HistoryReadValueId implements HistoryReadValueIdOptions {
    readonly nodeId: NodeId;
    readonly indexRange?: UaString;
    readonly dataEncoding: QualifiedName;
    readonly continuationPoint?: ByteString;
    constructor(options?: HistoryReadValueIdOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.indexRange = options?.indexRange;
        this.dataEncoding = options?.dataEncoding ?? new QualifiedName();
        this.continuationPoint = options?.continuationPoint;
    }
    static [typeId] = NodeIds.HistoryReadValueId_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.dataEncoding);
        encoder.writeByteString(this.continuationPoint);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadValueId {
        return new HistoryReadValueId({
            nodeId: decoder.readType(NodeId),
            indexRange: decoder.readString(),
            dataEncoding: decoder.readType(QualifiedName),
            continuationPoint: decoder.readByteString()
        });
    }
}
export interface HistoryReadResultOptions {
    statusCode?: StatusCode | undefined;
    continuationPoint?: ByteString | undefined;
    historyData?: ExtensionObject | undefined;
}
export class HistoryReadResult implements HistoryReadResultOptions {
    readonly statusCode: StatusCode;
    readonly continuationPoint?: ByteString;
    readonly historyData: ExtensionObject;
    constructor(options?: HistoryReadResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.continuationPoint = options?.continuationPoint;
        this.historyData = options?.historyData ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.HistoryReadResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeByteString(this.continuationPoint);
        encoder.writeType(this.historyData);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadResult {
        return new HistoryReadResult({
            statusCode: decoder.readType(StatusCode),
            continuationPoint: decoder.readByteString(),
            historyData: decoder.readType(ExtensionObject)
        });
    }
}
export class HistoryReadDetails {
    static [typeId] = NodeIds.HistoryReadDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadDetails {
        return new HistoryReadDetails();
    }
}
export interface ReadEventDetailsOptions {
    numValuesPerNode?: UInt32 | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    filter?: EventFilter | undefined;
}
export class ReadEventDetails implements ReadEventDetailsOptions {
    readonly numValuesPerNode: UInt32;
    readonly startTime: Date;
    readonly endTime: Date;
    readonly filter: EventFilter;
    constructor(options?: ReadEventDetailsOptions) {
        this.numValuesPerNode = options?.numValuesPerNode ?? 0;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.filter = options?.filter ?? new EventFilter();
    }
    static [typeId] = NodeIds.ReadEventDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.numValuesPerNode);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeType(this.filter);
    }
    static [decode](decoder: BinaryDataDecoder): ReadEventDetails {
        return new ReadEventDetails({
            numValuesPerNode: decoder.readUInt32(),
            startTime: decoder.readDateTime(),
            endTime: decoder.readDateTime(),
            filter: decoder.readType(EventFilter)
        });
    }
}
export interface ReadRawModifiedDetailsOptions {
    isReadModified?: boolean | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    numValuesPerNode?: UInt32 | undefined;
    returnBounds?: boolean | undefined;
}
export class ReadRawModifiedDetails implements ReadRawModifiedDetailsOptions {
    readonly isReadModified: boolean;
    readonly startTime: Date;
    readonly endTime: Date;
    readonly numValuesPerNode: UInt32;
    readonly returnBounds: boolean;
    constructor(options?: ReadRawModifiedDetailsOptions) {
        this.isReadModified = options?.isReadModified ?? false;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.numValuesPerNode = options?.numValuesPerNode ?? 0;
        this.returnBounds = options?.returnBounds ?? false;
    }
    static [typeId] = NodeIds.ReadRawModifiedDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeBoolean(this.isReadModified);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeUInt32(this.numValuesPerNode);
        encoder.writeBoolean(this.returnBounds);
    }
    static [decode](decoder: BinaryDataDecoder): ReadRawModifiedDetails {
        return new ReadRawModifiedDetails({
            isReadModified: decoder.readBoolean(),
            startTime: decoder.readDateTime(),
            endTime: decoder.readDateTime(),
            numValuesPerNode: decoder.readUInt32(),
            returnBounds: decoder.readBoolean()
        });
    }
}
export interface ReadProcessedDetailsOptions {
    startTime?: Date | undefined;
    endTime?: Date | undefined;
    processingInterval?: Double | undefined;
    aggregateType?: NodeId[] | undefined;
    aggregateConfiguration?: AggregateConfiguration | undefined;
}
export class ReadProcessedDetails implements ReadProcessedDetailsOptions {
    readonly startTime: Date;
    readonly endTime: Date;
    readonly processingInterval: Double;
    readonly aggregateType?: NodeId[];
    readonly aggregateConfiguration: AggregateConfiguration;
    constructor(options?: ReadProcessedDetailsOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
        this.processingInterval = options?.processingInterval ?? 0;
        this.aggregateType = options?.aggregateType;
        this.aggregateConfiguration = options?.aggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.ReadProcessedDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
        encoder.writeDouble(this.processingInterval);
        encoder.writeTypeArray(this.aggregateType);
        encoder.writeType(this.aggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): ReadProcessedDetails {
        return new ReadProcessedDetails({
            startTime: decoder.readDateTime(),
            endTime: decoder.readDateTime(),
            processingInterval: decoder.readDouble(),
            aggregateType: decoder.readTypeArray(NodeId),
            aggregateConfiguration: decoder.readType(AggregateConfiguration)
        });
    }
}
export interface ReadAtTimeDetailsOptions {
    reqTimes?: Date[] | undefined;
    useSimpleBounds?: boolean | undefined;
}
export class ReadAtTimeDetails implements ReadAtTimeDetailsOptions {
    readonly reqTimes?: Date[];
    readonly useSimpleBounds: boolean;
    constructor(options?: ReadAtTimeDetailsOptions) {
        this.reqTimes = options?.reqTimes;
        this.useSimpleBounds = options?.useSimpleBounds ?? false;
    }
    static [typeId] = NodeIds.ReadAtTimeDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTimeArray(this.reqTimes);
        encoder.writeBoolean(this.useSimpleBounds);
    }
    static [decode](decoder: BinaryDataDecoder): ReadAtTimeDetails {
        return new ReadAtTimeDetails({
            reqTimes: decoder.readDateTimeArray(),
            useSimpleBounds: decoder.readBoolean()
        });
    }
}
export interface ReadAnnotationDataDetailsOptions {
    reqTimes?: Date[] | undefined;
}
export class ReadAnnotationDataDetails implements ReadAnnotationDataDetailsOptions {
    readonly reqTimes?: Date[];
    constructor(options?: ReadAnnotationDataDetailsOptions) {
        this.reqTimes = options?.reqTimes;
    }
    static [typeId] = NodeIds.ReadAnnotationDataDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTimeArray(this.reqTimes);
    }
    static [decode](decoder: BinaryDataDecoder): ReadAnnotationDataDetails {
        return new ReadAnnotationDataDetails({
            reqTimes: decoder.readDateTimeArray()
        });
    }
}
export interface HistoryDataOptions {
    dataValues?: DataValue[] | undefined;
}
export class HistoryData implements HistoryDataOptions {
    readonly dataValues?: DataValue[];
    constructor(options?: HistoryDataOptions) {
        this.dataValues = options?.dataValues;
    }
    static [typeId] = NodeIds.HistoryData_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.dataValues);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryData {
        return new HistoryData({
            dataValues: decoder.readTypeArray(DataValue)
        });
    }
}
export interface ModificationInfoOptions {
    modificationTime?: Date | undefined;
    updateType?: HistoryUpdateType | undefined;
    userName?: UaString | undefined;
}
export class ModificationInfo implements ModificationInfoOptions {
    readonly modificationTime: Date;
    readonly updateType: HistoryUpdateType;
    readonly userName?: UaString;
    constructor(options?: ModificationInfoOptions) {
        this.modificationTime = options?.modificationTime ?? new Date(-11644473600000);
        this.updateType = options?.updateType ?? HistoryUpdateType.Insert;
        this.userName = options?.userName;
    }
    static [typeId] = NodeIds.ModificationInfo_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.modificationTime);
        encoder.writeUInt32(this.updateType);
        encoder.writeString(this.userName);
    }
    static [decode](decoder: BinaryDataDecoder): ModificationInfo {
        return new ModificationInfo({
            modificationTime: decoder.readDateTime(),
            updateType: decoder.readUInt32(),
            userName: decoder.readString()
        });
    }
}
export interface HistoryModifiedDataOptions {
    dataValues?: DataValue[] | undefined;
    modificationInfos?: ModificationInfo[] | undefined;
}
export class HistoryModifiedData implements HistoryModifiedDataOptions {
    readonly dataValues?: DataValue[];
    readonly modificationInfos?: ModificationInfo[];
    constructor(options?: HistoryModifiedDataOptions) {
        this.dataValues = options?.dataValues;
        this.modificationInfos = options?.modificationInfos;
    }
    static [typeId] = NodeIds.HistoryModifiedData_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.dataValues);
        encoder.writeTypeArray(this.modificationInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryModifiedData {
        return new HistoryModifiedData({
            dataValues: decoder.readTypeArray(DataValue),
            modificationInfos: decoder.readTypeArray(ModificationInfo)
        });
    }
}
export interface HistoryEventOptions {
    events?: HistoryEventFieldList[] | undefined;
}
export class HistoryEvent implements HistoryEventOptions {
    readonly events?: HistoryEventFieldList[];
    constructor(options?: HistoryEventOptions) {
        this.events = options?.events;
    }
    static [typeId] = NodeIds.HistoryEvent_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.events);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryEvent {
        return new HistoryEvent({
            events: decoder.readTypeArray(HistoryEventFieldList)
        });
    }
}
export interface HistoryReadRequestOptions {
    requestHeader?: RequestHeader | undefined;
    historyReadDetails?: ExtensionObject | undefined;
    timestampsToReturn?: TimestampsToReturn | undefined;
    releaseContinuationPoints?: boolean | undefined;
    nodesToRead?: HistoryReadValueId[] | undefined;
}
export class HistoryReadRequest implements HistoryReadRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly historyReadDetails: ExtensionObject;
    readonly timestampsToReturn: TimestampsToReturn;
    readonly releaseContinuationPoints: boolean;
    readonly nodesToRead?: HistoryReadValueId[];
    constructor(options?: HistoryReadRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.historyReadDetails = options?.historyReadDetails ?? new ExtensionObject();
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.releaseContinuationPoints = options?.releaseContinuationPoints ?? false;
        this.nodesToRead = options?.nodesToRead;
    }
    static [typeId] = NodeIds.HistoryReadRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeType(this.historyReadDetails);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeBoolean(this.releaseContinuationPoints);
        encoder.writeTypeArray(this.nodesToRead);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadRequest {
        return new HistoryReadRequest({
            requestHeader: decoder.readType(RequestHeader),
            historyReadDetails: decoder.readType(ExtensionObject),
            timestampsToReturn: decoder.readUInt32(),
            releaseContinuationPoints: decoder.readBoolean(),
            nodesToRead: decoder.readTypeArray(HistoryReadValueId)
        });
    }
}
export interface HistoryReadResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: HistoryReadResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class HistoryReadResponse implements HistoryReadResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: HistoryReadResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryReadResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryReadResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryReadResponse {
        return new HistoryReadResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(HistoryReadResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface WriteValueOptions {
    nodeId?: NodeId | undefined;
    attributeId?: UInt32 | undefined;
    indexRange?: UaString | undefined;
    value?: DataValue | undefined;
}
export class WriteValue implements WriteValueOptions {
    readonly nodeId: NodeId;
    readonly attributeId: UInt32;
    readonly indexRange?: UaString;
    readonly value: DataValue;
    constructor(options?: WriteValueOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.attributeId = options?.attributeId ?? 0;
        this.indexRange = options?.indexRange;
        this.value = options?.value ?? new DataValue();
    }
    static [typeId] = NodeIds.WriteValue_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.attributeId);
        encoder.writeString(this.indexRange);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): WriteValue {
        return new WriteValue({
            nodeId: decoder.readType(NodeId),
            attributeId: decoder.readUInt32(),
            indexRange: decoder.readString(),
            value: decoder.readType(DataValue)
        });
    }
}
export interface WriteRequestOptions {
    requestHeader?: RequestHeader | undefined;
    nodesToWrite?: WriteValue[] | undefined;
}
export class WriteRequest implements WriteRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly nodesToWrite?: WriteValue[];
    constructor(options?: WriteRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.nodesToWrite = options?.nodesToWrite;
    }
    static [typeId] = NodeIds.WriteRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.nodesToWrite);
    }
    static [decode](decoder: BinaryDataDecoder): WriteRequest {
        return new WriteRequest({
            requestHeader: decoder.readType(RequestHeader),
            nodesToWrite: decoder.readTypeArray(WriteValue)
        });
    }
}
export interface WriteResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class WriteResponse implements WriteResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: WriteResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.WriteResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): WriteResponse {
        return new WriteResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface HistoryUpdateDetailsOptions {
    nodeId?: NodeId | undefined;
}
export class HistoryUpdateDetails implements HistoryUpdateDetailsOptions {
    readonly nodeId: NodeId;
    constructor(options?: HistoryUpdateDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
    }
    static [typeId] = NodeIds.HistoryUpdateDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateDetails {
        return new HistoryUpdateDetails({
            nodeId: decoder.readType(NodeId)
        });
    }
}
export enum HistoryUpdateType {
    Insert = 1,
    Replace = 2,
    Update = 3,
    Delete = 4
}
export enum PerformUpdateType {
    Insert = 1,
    Replace = 2,
    Update = 3,
    Remove = 4
}
export interface UpdateDataDetailsOptions {
    nodeId?: NodeId | undefined;
    performInsertReplace?: PerformUpdateType | undefined;
    updateValues?: DataValue[] | undefined;
}
export class UpdateDataDetails implements UpdateDataDetailsOptions {
    readonly nodeId: NodeId;
    readonly performInsertReplace: PerformUpdateType;
    readonly updateValues?: DataValue[];
    constructor(options?: UpdateDataDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.updateValues = options?.updateValues;
    }
    static [typeId] = NodeIds.UpdateDataDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeTypeArray(this.updateValues);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateDataDetails {
        return new UpdateDataDetails({
            nodeId: decoder.readType(NodeId),
            performInsertReplace: decoder.readUInt32(),
            updateValues: decoder.readTypeArray(DataValue)
        });
    }
}
export interface UpdateStructureDataDetailsOptions {
    nodeId?: NodeId | undefined;
    performInsertReplace?: PerformUpdateType | undefined;
    updateValues?: DataValue[] | undefined;
}
export class UpdateStructureDataDetails implements UpdateStructureDataDetailsOptions {
    readonly nodeId: NodeId;
    readonly performInsertReplace: PerformUpdateType;
    readonly updateValues?: DataValue[];
    constructor(options?: UpdateStructureDataDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.updateValues = options?.updateValues;
    }
    static [typeId] = NodeIds.UpdateStructureDataDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeTypeArray(this.updateValues);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateStructureDataDetails {
        return new UpdateStructureDataDetails({
            nodeId: decoder.readType(NodeId),
            performInsertReplace: decoder.readUInt32(),
            updateValues: decoder.readTypeArray(DataValue)
        });
    }
}
export interface UpdateEventDetailsOptions {
    nodeId?: NodeId | undefined;
    performInsertReplace?: PerformUpdateType | undefined;
    filter?: EventFilter | undefined;
    eventData?: HistoryEventFieldList[] | undefined;
}
export class UpdateEventDetails implements UpdateEventDetailsOptions {
    readonly nodeId: NodeId;
    readonly performInsertReplace: PerformUpdateType;
    readonly filter: EventFilter;
    readonly eventData?: HistoryEventFieldList[];
    constructor(options?: UpdateEventDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.performInsertReplace = options?.performInsertReplace ?? PerformUpdateType.Insert;
        this.filter = options?.filter ?? new EventFilter();
        this.eventData = options?.eventData;
    }
    static [typeId] = NodeIds.UpdateEventDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeUInt32(this.performInsertReplace);
        encoder.writeType(this.filter);
        encoder.writeTypeArray(this.eventData);
    }
    static [decode](decoder: BinaryDataDecoder): UpdateEventDetails {
        return new UpdateEventDetails({
            nodeId: decoder.readType(NodeId),
            performInsertReplace: decoder.readUInt32(),
            filter: decoder.readType(EventFilter),
            eventData: decoder.readTypeArray(HistoryEventFieldList)
        });
    }
}
export interface DeleteRawModifiedDetailsOptions {
    nodeId?: NodeId | undefined;
    isDeleteModified?: boolean | undefined;
    startTime?: Date | undefined;
    endTime?: Date | undefined;
}
export class DeleteRawModifiedDetails implements DeleteRawModifiedDetailsOptions {
    readonly nodeId: NodeId;
    readonly isDeleteModified: boolean;
    readonly startTime: Date;
    readonly endTime: Date;
    constructor(options?: DeleteRawModifiedDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.isDeleteModified = options?.isDeleteModified ?? false;
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.endTime = options?.endTime ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.DeleteRawModifiedDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeBoolean(this.isDeleteModified);
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.endTime);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteRawModifiedDetails {
        return new DeleteRawModifiedDetails({
            nodeId: decoder.readType(NodeId),
            isDeleteModified: decoder.readBoolean(),
            startTime: decoder.readDateTime(),
            endTime: decoder.readDateTime()
        });
    }
}
export interface DeleteAtTimeDetailsOptions {
    nodeId?: NodeId | undefined;
    reqTimes?: Date[] | undefined;
}
export class DeleteAtTimeDetails implements DeleteAtTimeDetailsOptions {
    readonly nodeId: NodeId;
    readonly reqTimes?: Date[];
    constructor(options?: DeleteAtTimeDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.reqTimes = options?.reqTimes;
    }
    static [typeId] = NodeIds.DeleteAtTimeDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeDateTimeArray(this.reqTimes);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteAtTimeDetails {
        return new DeleteAtTimeDetails({
            nodeId: decoder.readType(NodeId),
            reqTimes: decoder.readDateTimeArray()
        });
    }
}
export interface DeleteEventDetailsOptions {
    nodeId?: NodeId | undefined;
    eventIds?: ByteString[] | undefined;
}
export class DeleteEventDetails implements DeleteEventDetailsOptions {
    readonly nodeId: NodeId;
    readonly eventIds?: ByteString[];
    constructor(options?: DeleteEventDetailsOptions) {
        this.nodeId = options?.nodeId ?? NodeId.null();
        this.eventIds = options?.eventIds;
    }
    static [typeId] = NodeIds.DeleteEventDetails_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.nodeId);
        encoder.writeByteStringArray(this.eventIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteEventDetails {
        return new DeleteEventDetails({
            nodeId: decoder.readType(NodeId),
            eventIds: decoder.readByteStringArray()
        });
    }
}
export interface HistoryUpdateResultOptions {
    statusCode?: StatusCode | undefined;
    operationResults?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class HistoryUpdateResult implements HistoryUpdateResultOptions {
    readonly statusCode: StatusCode;
    readonly operationResults?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryUpdateResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.operationResults = options?.operationResults;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryUpdateResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.operationResults);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateResult {
        return new HistoryUpdateResult({
            statusCode: decoder.readType(StatusCode),
            operationResults: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface HistoryUpdateRequestOptions {
    requestHeader?: RequestHeader | undefined;
    historyUpdateDetails?: ExtensionObject[] | undefined;
}
export class HistoryUpdateRequest implements HistoryUpdateRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly historyUpdateDetails?: ExtensionObject[];
    constructor(options?: HistoryUpdateRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.historyUpdateDetails = options?.historyUpdateDetails;
    }
    static [typeId] = NodeIds.HistoryUpdateRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.historyUpdateDetails);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateRequest {
        return new HistoryUpdateRequest({
            requestHeader: decoder.readType(RequestHeader),
            historyUpdateDetails: decoder.readTypeArray(ExtensionObject)
        });
    }
}
export interface HistoryUpdateResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: HistoryUpdateResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class HistoryUpdateResponse implements HistoryUpdateResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: HistoryUpdateResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: HistoryUpdateResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.HistoryUpdateResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryUpdateResponse {
        return new HistoryUpdateResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(HistoryUpdateResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface CallMethodRequestOptions {
    objectId?: NodeId | undefined;
    methodId?: NodeId | undefined;
    inputArguments?: Variant[] | undefined;
}
export class CallMethodRequest implements CallMethodRequestOptions {
    readonly objectId: NodeId;
    readonly methodId: NodeId;
    readonly inputArguments?: Variant[];
    constructor(options?: CallMethodRequestOptions) {
        this.objectId = options?.objectId ?? NodeId.null();
        this.methodId = options?.methodId ?? NodeId.null();
        this.inputArguments = options?.inputArguments;
    }
    static [typeId] = NodeIds.CallMethodRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.objectId);
        encoder.writeType(this.methodId);
        encoder.writeTypeArray(this.inputArguments);
    }
    static [decode](decoder: BinaryDataDecoder): CallMethodRequest {
        return new CallMethodRequest({
            objectId: decoder.readType(NodeId),
            methodId: decoder.readType(NodeId),
            inputArguments: decoder.readTypeArray(Variant)
        });
    }
}
export interface CallMethodResultOptions {
    statusCode?: StatusCode | undefined;
    inputArgumentResults?: StatusCode[] | undefined;
    inputArgumentDiagnosticInfos?: DiagnosticInfo[] | undefined;
    outputArguments?: Variant[] | undefined;
}
export class CallMethodResult implements CallMethodResultOptions {
    readonly statusCode: StatusCode;
    readonly inputArgumentResults?: StatusCode[];
    readonly inputArgumentDiagnosticInfos?: DiagnosticInfo[];
    readonly outputArguments?: Variant[];
    constructor(options?: CallMethodResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.inputArgumentResults = options?.inputArgumentResults;
        this.inputArgumentDiagnosticInfos = options?.inputArgumentDiagnosticInfos;
        this.outputArguments = options?.outputArguments;
    }
    static [typeId] = NodeIds.CallMethodResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeTypeArray(this.inputArgumentResults);
        encoder.writeTypeArray(this.inputArgumentDiagnosticInfos);
        encoder.writeTypeArray(this.outputArguments);
    }
    static [decode](decoder: BinaryDataDecoder): CallMethodResult {
        return new CallMethodResult({
            statusCode: decoder.readType(StatusCode),
            inputArgumentResults: decoder.readTypeArray(StatusCode),
            inputArgumentDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo),
            outputArguments: decoder.readTypeArray(Variant)
        });
    }
}
export interface CallRequestOptions {
    requestHeader?: RequestHeader | undefined;
    methodsToCall?: CallMethodRequest[] | undefined;
}
export class CallRequest implements CallRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly methodsToCall?: CallMethodRequest[];
    constructor(options?: CallRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.methodsToCall = options?.methodsToCall;
    }
    static [typeId] = NodeIds.CallRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.methodsToCall);
    }
    static [decode](decoder: BinaryDataDecoder): CallRequest {
        return new CallRequest({
            requestHeader: decoder.readType(RequestHeader),
            methodsToCall: decoder.readTypeArray(CallMethodRequest)
        });
    }
}
export interface CallResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: CallMethodResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class CallResponse implements CallResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: CallMethodResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: CallResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.CallResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): CallResponse {
        return new CallResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(CallMethodResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export enum MonitoringMode {
    Disabled = 0,
    Sampling = 1,
    Reporting = 2
}
export enum DataChangeTrigger {
    Status = 0,
    StatusValue = 1,
    StatusValueTimestamp = 2
}
export enum DeadbandType {
    None = 0,
    Absolute = 1,
    Percent = 2
}
export class MonitoringFilter {
    static [typeId] = NodeIds.MonitoringFilter_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringFilter {
        return new MonitoringFilter();
    }
}
export interface DataChangeFilterOptions {
    trigger?: DataChangeTrigger | undefined;
    deadbandType?: UInt32 | undefined;
    deadbandValue?: Double | undefined;
}
export class DataChangeFilter implements DataChangeFilterOptions {
    readonly trigger: DataChangeTrigger;
    readonly deadbandType: UInt32;
    readonly deadbandValue: Double;
    constructor(options?: DataChangeFilterOptions) {
        this.trigger = options?.trigger ?? DataChangeTrigger.Status;
        this.deadbandType = options?.deadbandType ?? 0;
        this.deadbandValue = options?.deadbandValue ?? 0;
    }
    static [typeId] = NodeIds.DataChangeFilter_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.trigger);
        encoder.writeUInt32(this.deadbandType);
        encoder.writeDouble(this.deadbandValue);
    }
    static [decode](decoder: BinaryDataDecoder): DataChangeFilter {
        return new DataChangeFilter({
            trigger: decoder.readUInt32(),
            deadbandType: decoder.readUInt32(),
            deadbandValue: decoder.readDouble()
        });
    }
}
export interface EventFilterOptions {
    selectClauses?: SimpleAttributeOperand[] | undefined;
    whereClause?: ContentFilter | undefined;
}
export class EventFilter implements EventFilterOptions {
    readonly selectClauses?: SimpleAttributeOperand[];
    readonly whereClause: ContentFilter;
    constructor(options?: EventFilterOptions) {
        this.selectClauses = options?.selectClauses;
        this.whereClause = options?.whereClause ?? new ContentFilter();
    }
    static [typeId] = NodeIds.EventFilter_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.selectClauses);
        encoder.writeType(this.whereClause);
    }
    static [decode](decoder: BinaryDataDecoder): EventFilter {
        return new EventFilter({
            selectClauses: decoder.readTypeArray(SimpleAttributeOperand),
            whereClause: decoder.readType(ContentFilter)
        });
    }
}
export interface AggregateConfigurationOptions {
    useServerCapabilitiesDefaults?: boolean | undefined;
    treatUncertainAsBad?: boolean | undefined;
    percentDataBad?: Byte | undefined;
    percentDataGood?: Byte | undefined;
    useSlopedExtrapolation?: boolean | undefined;
}
export class AggregateConfiguration implements AggregateConfigurationOptions {
    readonly useServerCapabilitiesDefaults: boolean;
    readonly treatUncertainAsBad: boolean;
    readonly percentDataBad: Byte;
    readonly percentDataGood: Byte;
    readonly useSlopedExtrapolation: boolean;
    constructor(options?: AggregateConfigurationOptions) {
        this.useServerCapabilitiesDefaults = options?.useServerCapabilitiesDefaults ?? false;
        this.treatUncertainAsBad = options?.treatUncertainAsBad ?? false;
        this.percentDataBad = options?.percentDataBad ?? 0;
        this.percentDataGood = options?.percentDataGood ?? 0;
        this.useSlopedExtrapolation = options?.useSlopedExtrapolation ?? false;
    }
    static [typeId] = NodeIds.AggregateConfiguration_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeBoolean(this.useServerCapabilitiesDefaults);
        encoder.writeBoolean(this.treatUncertainAsBad);
        encoder.writeByte(this.percentDataBad);
        encoder.writeByte(this.percentDataGood);
        encoder.writeBoolean(this.useSlopedExtrapolation);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateConfiguration {
        return new AggregateConfiguration({
            useServerCapabilitiesDefaults: decoder.readBoolean(),
            treatUncertainAsBad: decoder.readBoolean(),
            percentDataBad: decoder.readByte(),
            percentDataGood: decoder.readByte(),
            useSlopedExtrapolation: decoder.readBoolean()
        });
    }
}
export interface AggregateFilterOptions {
    startTime?: Date | undefined;
    aggregateType?: NodeId | undefined;
    processingInterval?: Double | undefined;
    aggregateConfiguration?: AggregateConfiguration | undefined;
}
export class AggregateFilter implements AggregateFilterOptions {
    readonly startTime: Date;
    readonly aggregateType: NodeId;
    readonly processingInterval: Double;
    readonly aggregateConfiguration: AggregateConfiguration;
    constructor(options?: AggregateFilterOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.aggregateType = options?.aggregateType ?? NodeId.null();
        this.processingInterval = options?.processingInterval ?? 0;
        this.aggregateConfiguration = options?.aggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.AggregateFilter_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeType(this.aggregateType);
        encoder.writeDouble(this.processingInterval);
        encoder.writeType(this.aggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateFilter {
        return new AggregateFilter({
            startTime: decoder.readDateTime(),
            aggregateType: decoder.readType(NodeId),
            processingInterval: decoder.readDouble(),
            aggregateConfiguration: decoder.readType(AggregateConfiguration)
        });
    }
}
export class MonitoringFilterResult {
    static [typeId] = NodeIds.MonitoringFilterResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringFilterResult {
        return new MonitoringFilterResult();
    }
}
export interface EventFilterResultOptions {
    selectClauseResults?: StatusCode[] | undefined;
    selectClauseDiagnosticInfos?: DiagnosticInfo[] | undefined;
    whereClauseResult?: ContentFilterResult | undefined;
}
export class EventFilterResult implements EventFilterResultOptions {
    readonly selectClauseResults?: StatusCode[];
    readonly selectClauseDiagnosticInfos?: DiagnosticInfo[];
    readonly whereClauseResult: ContentFilterResult;
    constructor(options?: EventFilterResultOptions) {
        this.selectClauseResults = options?.selectClauseResults;
        this.selectClauseDiagnosticInfos = options?.selectClauseDiagnosticInfos;
        this.whereClauseResult = options?.whereClauseResult ?? new ContentFilterResult();
    }
    static [typeId] = NodeIds.EventFilterResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.selectClauseResults);
        encoder.writeTypeArray(this.selectClauseDiagnosticInfos);
        encoder.writeType(this.whereClauseResult);
    }
    static [decode](decoder: BinaryDataDecoder): EventFilterResult {
        return new EventFilterResult({
            selectClauseResults: decoder.readTypeArray(StatusCode),
            selectClauseDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo),
            whereClauseResult: decoder.readType(ContentFilterResult)
        });
    }
}
export interface AggregateFilterResultOptions {
    revisedStartTime?: Date | undefined;
    revisedProcessingInterval?: Double | undefined;
    revisedAggregateConfiguration?: AggregateConfiguration | undefined;
}
export class AggregateFilterResult implements AggregateFilterResultOptions {
    readonly revisedStartTime: Date;
    readonly revisedProcessingInterval: Double;
    readonly revisedAggregateConfiguration: AggregateConfiguration;
    constructor(options?: AggregateFilterResultOptions) {
        this.revisedStartTime = options?.revisedStartTime ?? new Date(-11644473600000);
        this.revisedProcessingInterval = options?.revisedProcessingInterval ?? 0;
        this.revisedAggregateConfiguration = options?.revisedAggregateConfiguration ?? new AggregateConfiguration();
    }
    static [typeId] = NodeIds.AggregateFilterResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.revisedStartTime);
        encoder.writeDouble(this.revisedProcessingInterval);
        encoder.writeType(this.revisedAggregateConfiguration);
    }
    static [decode](decoder: BinaryDataDecoder): AggregateFilterResult {
        return new AggregateFilterResult({
            revisedStartTime: decoder.readDateTime(),
            revisedProcessingInterval: decoder.readDouble(),
            revisedAggregateConfiguration: decoder.readType(AggregateConfiguration)
        });
    }
}
export interface MonitoringParametersOptions {
    clientHandle?: UInt32 | undefined;
    samplingInterval?: Double | undefined;
    filter?: ExtensionObject | undefined;
    queueSize?: UInt32 | undefined;
    discardOldest?: boolean | undefined;
}
export class MonitoringParameters implements MonitoringParametersOptions {
    readonly clientHandle: UInt32;
    readonly samplingInterval: Double;
    readonly filter: ExtensionObject;
    readonly queueSize: UInt32;
    readonly discardOldest: boolean;
    constructor(options?: MonitoringParametersOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.samplingInterval = options?.samplingInterval ?? 0;
        this.filter = options?.filter ?? new ExtensionObject();
        this.queueSize = options?.queueSize ?? 0;
        this.discardOldest = options?.discardOldest ?? false;
    }
    static [typeId] = NodeIds.MonitoringParameters_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeDouble(this.samplingInterval);
        encoder.writeType(this.filter);
        encoder.writeUInt32(this.queueSize);
        encoder.writeBoolean(this.discardOldest);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoringParameters {
        return new MonitoringParameters({
            clientHandle: decoder.readUInt32(),
            samplingInterval: decoder.readDouble(),
            filter: decoder.readType(ExtensionObject),
            queueSize: decoder.readUInt32(),
            discardOldest: decoder.readBoolean()
        });
    }
}
export interface MonitoredItemCreateRequestOptions {
    itemToMonitor?: ReadValueId | undefined;
    monitoringMode?: MonitoringMode | undefined;
    requestedParameters?: MonitoringParameters | undefined;
}
export class MonitoredItemCreateRequest implements MonitoredItemCreateRequestOptions {
    readonly itemToMonitor: ReadValueId;
    readonly monitoringMode: MonitoringMode;
    readonly requestedParameters: MonitoringParameters;
    constructor(options?: MonitoredItemCreateRequestOptions) {
        this.itemToMonitor = options?.itemToMonitor ?? new ReadValueId();
        this.monitoringMode = options?.monitoringMode ?? MonitoringMode.Disabled;
        this.requestedParameters = options?.requestedParameters ?? new MonitoringParameters();
    }
    static [typeId] = NodeIds.MonitoredItemCreateRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.itemToMonitor);
        encoder.writeUInt32(this.monitoringMode);
        encoder.writeType(this.requestedParameters);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemCreateRequest {
        return new MonitoredItemCreateRequest({
            itemToMonitor: decoder.readType(ReadValueId),
            monitoringMode: decoder.readUInt32(),
            requestedParameters: decoder.readType(MonitoringParameters)
        });
    }
}
export interface MonitoredItemCreateResultOptions {
    statusCode?: StatusCode | undefined;
    monitoredItemId?: UInt32 | undefined;
    revisedSamplingInterval?: Double | undefined;
    revisedQueueSize?: UInt32 | undefined;
    filterResult?: ExtensionObject | undefined;
}
export class MonitoredItemCreateResult implements MonitoredItemCreateResultOptions {
    readonly statusCode: StatusCode;
    readonly monitoredItemId: UInt32;
    readonly revisedSamplingInterval: Double;
    readonly revisedQueueSize: UInt32;
    readonly filterResult: ExtensionObject;
    constructor(options?: MonitoredItemCreateResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.monitoredItemId = options?.monitoredItemId ?? 0;
        this.revisedSamplingInterval = options?.revisedSamplingInterval ?? 0;
        this.revisedQueueSize = options?.revisedQueueSize ?? 0;
        this.filterResult = options?.filterResult ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.MonitoredItemCreateResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeUInt32(this.monitoredItemId);
        encoder.writeDouble(this.revisedSamplingInterval);
        encoder.writeUInt32(this.revisedQueueSize);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemCreateResult {
        return new MonitoredItemCreateResult({
            statusCode: decoder.readType(StatusCode),
            monitoredItemId: decoder.readUInt32(),
            revisedSamplingInterval: decoder.readDouble(),
            revisedQueueSize: decoder.readUInt32(),
            filterResult: decoder.readType(ExtensionObject)
        });
    }
}
export interface CreateMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    timestampsToReturn?: TimestampsToReturn | undefined;
    itemsToCreate?: MonitoredItemCreateRequest[] | undefined;
}
export class CreateMonitoredItemsRequest implements CreateMonitoredItemsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly timestampsToReturn: TimestampsToReturn;
    readonly itemsToCreate?: MonitoredItemCreateRequest[];
    constructor(options?: CreateMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.itemsToCreate = options?.itemsToCreate;
    }
    static [typeId] = NodeIds.CreateMonitoredItemsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.itemsToCreate);
    }
    static [decode](decoder: BinaryDataDecoder): CreateMonitoredItemsRequest {
        return new CreateMonitoredItemsRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            timestampsToReturn: decoder.readUInt32(),
            itemsToCreate: decoder.readTypeArray(MonitoredItemCreateRequest)
        });
    }
}
export interface CreateMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: MonitoredItemCreateResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class CreateMonitoredItemsResponse implements CreateMonitoredItemsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: MonitoredItemCreateResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: CreateMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.CreateMonitoredItemsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): CreateMonitoredItemsResponse {
        return new CreateMonitoredItemsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(MonitoredItemCreateResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface MonitoredItemModifyRequestOptions {
    monitoredItemId?: UInt32 | undefined;
    requestedParameters?: MonitoringParameters | undefined;
}
export class MonitoredItemModifyRequest implements MonitoredItemModifyRequestOptions {
    readonly monitoredItemId: UInt32;
    readonly requestedParameters: MonitoringParameters;
    constructor(options?: MonitoredItemModifyRequestOptions) {
        this.monitoredItemId = options?.monitoredItemId ?? 0;
        this.requestedParameters = options?.requestedParameters ?? new MonitoringParameters();
    }
    static [typeId] = NodeIds.MonitoredItemModifyRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.monitoredItemId);
        encoder.writeType(this.requestedParameters);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemModifyRequest {
        return new MonitoredItemModifyRequest({
            monitoredItemId: decoder.readUInt32(),
            requestedParameters: decoder.readType(MonitoringParameters)
        });
    }
}
export interface MonitoredItemModifyResultOptions {
    statusCode?: StatusCode | undefined;
    revisedSamplingInterval?: Double | undefined;
    revisedQueueSize?: UInt32 | undefined;
    filterResult?: ExtensionObject | undefined;
}
export class MonitoredItemModifyResult implements MonitoredItemModifyResultOptions {
    readonly statusCode: StatusCode;
    readonly revisedSamplingInterval: Double;
    readonly revisedQueueSize: UInt32;
    readonly filterResult: ExtensionObject;
    constructor(options?: MonitoredItemModifyResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.revisedSamplingInterval = options?.revisedSamplingInterval ?? 0;
        this.revisedQueueSize = options?.revisedQueueSize ?? 0;
        this.filterResult = options?.filterResult ?? new ExtensionObject();
    }
    static [typeId] = NodeIds.MonitoredItemModifyResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeDouble(this.revisedSamplingInterval);
        encoder.writeUInt32(this.revisedQueueSize);
        encoder.writeType(this.filterResult);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemModifyResult {
        return new MonitoredItemModifyResult({
            statusCode: decoder.readType(StatusCode),
            revisedSamplingInterval: decoder.readDouble(),
            revisedQueueSize: decoder.readUInt32(),
            filterResult: decoder.readType(ExtensionObject)
        });
    }
}
export interface ModifyMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    timestampsToReturn?: TimestampsToReturn | undefined;
    itemsToModify?: MonitoredItemModifyRequest[] | undefined;
}
export class ModifyMonitoredItemsRequest implements ModifyMonitoredItemsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly timestampsToReturn: TimestampsToReturn;
    readonly itemsToModify?: MonitoredItemModifyRequest[];
    constructor(options?: ModifyMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.timestampsToReturn = options?.timestampsToReturn ?? TimestampsToReturn.Source;
        this.itemsToModify = options?.itemsToModify;
    }
    static [typeId] = NodeIds.ModifyMonitoredItemsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.timestampsToReturn);
        encoder.writeTypeArray(this.itemsToModify);
    }
    static [decode](decoder: BinaryDataDecoder): ModifyMonitoredItemsRequest {
        return new ModifyMonitoredItemsRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            timestampsToReturn: decoder.readUInt32(),
            itemsToModify: decoder.readTypeArray(MonitoredItemModifyRequest)
        });
    }
}
export interface ModifyMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: MonitoredItemModifyResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class ModifyMonitoredItemsResponse implements ModifyMonitoredItemsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: MonitoredItemModifyResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: ModifyMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.ModifyMonitoredItemsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): ModifyMonitoredItemsResponse {
        return new ModifyMonitoredItemsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(MonitoredItemModifyResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface SetMonitoringModeRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    monitoringMode?: MonitoringMode | undefined;
    monitoredItemIds?: UInt32[] | undefined;
}
export class SetMonitoringModeRequest implements SetMonitoringModeRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly monitoringMode: MonitoringMode;
    readonly monitoredItemIds?: UInt32[];
    constructor(options?: SetMonitoringModeRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.monitoringMode = options?.monitoringMode ?? MonitoringMode.Disabled;
        this.monitoredItemIds = options?.monitoredItemIds;
    }
    static [typeId] = NodeIds.SetMonitoringModeRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.monitoringMode);
        encoder.writeUInt32Array(this.monitoredItemIds);
    }
    static [decode](decoder: BinaryDataDecoder): SetMonitoringModeRequest {
        return new SetMonitoringModeRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            monitoringMode: decoder.readUInt32(),
            monitoredItemIds: decoder.readUInt32Array()
        });
    }
}
export interface SetMonitoringModeResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class SetMonitoringModeResponse implements SetMonitoringModeResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetMonitoringModeResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.SetMonitoringModeResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetMonitoringModeResponse {
        return new SetMonitoringModeResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface SetTriggeringRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    triggeringItemId?: UInt32 | undefined;
    linksToAdd?: UInt32[] | undefined;
    linksToRemove?: UInt32[] | undefined;
}
export class SetTriggeringRequest implements SetTriggeringRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly triggeringItemId: UInt32;
    readonly linksToAdd?: UInt32[];
    readonly linksToRemove?: UInt32[];
    constructor(options?: SetTriggeringRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.triggeringItemId = options?.triggeringItemId ?? 0;
        this.linksToAdd = options?.linksToAdd;
        this.linksToRemove = options?.linksToRemove;
    }
    static [typeId] = NodeIds.SetTriggeringRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.triggeringItemId);
        encoder.writeUInt32Array(this.linksToAdd);
        encoder.writeUInt32Array(this.linksToRemove);
    }
    static [decode](decoder: BinaryDataDecoder): SetTriggeringRequest {
        return new SetTriggeringRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            triggeringItemId: decoder.readUInt32(),
            linksToAdd: decoder.readUInt32Array(),
            linksToRemove: decoder.readUInt32Array()
        });
    }
}
export interface SetTriggeringResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    addResults?: StatusCode[] | undefined;
    addDiagnosticInfos?: DiagnosticInfo[] | undefined;
    removeResults?: StatusCode[] | undefined;
    removeDiagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class SetTriggeringResponse implements SetTriggeringResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly addResults?: StatusCode[];
    readonly addDiagnosticInfos?: DiagnosticInfo[];
    readonly removeResults?: StatusCode[];
    readonly removeDiagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetTriggeringResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.addResults = options?.addResults;
        this.addDiagnosticInfos = options?.addDiagnosticInfos;
        this.removeResults = options?.removeResults;
        this.removeDiagnosticInfos = options?.removeDiagnosticInfos;
    }
    static [typeId] = NodeIds.SetTriggeringResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.addResults);
        encoder.writeTypeArray(this.addDiagnosticInfos);
        encoder.writeTypeArray(this.removeResults);
        encoder.writeTypeArray(this.removeDiagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetTriggeringResponse {
        return new SetTriggeringResponse({
            responseHeader: decoder.readType(ResponseHeader),
            addResults: decoder.readTypeArray(StatusCode),
            addDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo),
            removeResults: decoder.readTypeArray(StatusCode),
            removeDiagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface DeleteMonitoredItemsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    monitoredItemIds?: UInt32[] | undefined;
}
export class DeleteMonitoredItemsRequest implements DeleteMonitoredItemsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly monitoredItemIds?: UInt32[];
    constructor(options?: DeleteMonitoredItemsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.monitoredItemIds = options?.monitoredItemIds;
    }
    static [typeId] = NodeIds.DeleteMonitoredItemsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32Array(this.monitoredItemIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteMonitoredItemsRequest {
        return new DeleteMonitoredItemsRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            monitoredItemIds: decoder.readUInt32Array()
        });
    }
}
export interface DeleteMonitoredItemsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class DeleteMonitoredItemsResponse implements DeleteMonitoredItemsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteMonitoredItemsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteMonitoredItemsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteMonitoredItemsResponse {
        return new DeleteMonitoredItemsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface CreateSubscriptionRequestOptions {
    requestHeader?: RequestHeader | undefined;
    requestedPublishingInterval?: Double | undefined;
    requestedLifetimeCount?: UInt32 | undefined;
    requestedMaxKeepAliveCount?: UInt32 | undefined;
    maxNotificationsPerPublish?: UInt32 | undefined;
    publishingEnabled?: boolean | undefined;
    priority?: Byte | undefined;
}
export class CreateSubscriptionRequest implements CreateSubscriptionRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly requestedPublishingInterval: Double;
    readonly requestedLifetimeCount: UInt32;
    readonly requestedMaxKeepAliveCount: UInt32;
    readonly maxNotificationsPerPublish: UInt32;
    readonly publishingEnabled: boolean;
    readonly priority: Byte;
    constructor(options?: CreateSubscriptionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.requestedPublishingInterval = options?.requestedPublishingInterval ?? 0;
        this.requestedLifetimeCount = options?.requestedLifetimeCount ?? 0;
        this.requestedMaxKeepAliveCount = options?.requestedMaxKeepAliveCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.priority = options?.priority ?? 0;
    }
    static [typeId] = NodeIds.CreateSubscriptionRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeDouble(this.requestedPublishingInterval);
        encoder.writeUInt32(this.requestedLifetimeCount);
        encoder.writeUInt32(this.requestedMaxKeepAliveCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeByte(this.priority);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSubscriptionRequest {
        return new CreateSubscriptionRequest({
            requestHeader: decoder.readType(RequestHeader),
            requestedPublishingInterval: decoder.readDouble(),
            requestedLifetimeCount: decoder.readUInt32(),
            requestedMaxKeepAliveCount: decoder.readUInt32(),
            maxNotificationsPerPublish: decoder.readUInt32(),
            publishingEnabled: decoder.readBoolean(),
            priority: decoder.readByte()
        });
    }
}
export interface CreateSubscriptionResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    revisedPublishingInterval?: Double | undefined;
    revisedLifetimeCount?: UInt32 | undefined;
    revisedMaxKeepAliveCount?: UInt32 | undefined;
}
export class CreateSubscriptionResponse implements CreateSubscriptionResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly subscriptionId: UInt32;
    readonly revisedPublishingInterval: Double;
    readonly revisedLifetimeCount: UInt32;
    readonly revisedMaxKeepAliveCount: UInt32;
    constructor(options?: CreateSubscriptionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.revisedPublishingInterval = options?.revisedPublishingInterval ?? 0;
        this.revisedLifetimeCount = options?.revisedLifetimeCount ?? 0;
        this.revisedMaxKeepAliveCount = options?.revisedMaxKeepAliveCount ?? 0;
    }
    static [typeId] = NodeIds.CreateSubscriptionResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeDouble(this.revisedPublishingInterval);
        encoder.writeUInt32(this.revisedLifetimeCount);
        encoder.writeUInt32(this.revisedMaxKeepAliveCount);
    }
    static [decode](decoder: BinaryDataDecoder): CreateSubscriptionResponse {
        return new CreateSubscriptionResponse({
            responseHeader: decoder.readType(ResponseHeader),
            subscriptionId: decoder.readUInt32(),
            revisedPublishingInterval: decoder.readDouble(),
            revisedLifetimeCount: decoder.readUInt32(),
            revisedMaxKeepAliveCount: decoder.readUInt32()
        });
    }
}
export interface ModifySubscriptionRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    requestedPublishingInterval?: Double | undefined;
    requestedLifetimeCount?: UInt32 | undefined;
    requestedMaxKeepAliveCount?: UInt32 | undefined;
    maxNotificationsPerPublish?: UInt32 | undefined;
    priority?: Byte | undefined;
}
export class ModifySubscriptionRequest implements ModifySubscriptionRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly requestedPublishingInterval: Double;
    readonly requestedLifetimeCount: UInt32;
    readonly requestedMaxKeepAliveCount: UInt32;
    readonly maxNotificationsPerPublish: UInt32;
    readonly priority: Byte;
    constructor(options?: ModifySubscriptionRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.requestedPublishingInterval = options?.requestedPublishingInterval ?? 0;
        this.requestedLifetimeCount = options?.requestedLifetimeCount ?? 0;
        this.requestedMaxKeepAliveCount = options?.requestedMaxKeepAliveCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.priority = options?.priority ?? 0;
    }
    static [typeId] = NodeIds.ModifySubscriptionRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeDouble(this.requestedPublishingInterval);
        encoder.writeUInt32(this.requestedLifetimeCount);
        encoder.writeUInt32(this.requestedMaxKeepAliveCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeByte(this.priority);
    }
    static [decode](decoder: BinaryDataDecoder): ModifySubscriptionRequest {
        return new ModifySubscriptionRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            requestedPublishingInterval: decoder.readDouble(),
            requestedLifetimeCount: decoder.readUInt32(),
            requestedMaxKeepAliveCount: decoder.readUInt32(),
            maxNotificationsPerPublish: decoder.readUInt32(),
            priority: decoder.readByte()
        });
    }
}
export interface ModifySubscriptionResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    revisedPublishingInterval?: Double | undefined;
    revisedLifetimeCount?: UInt32 | undefined;
    revisedMaxKeepAliveCount?: UInt32 | undefined;
}
export class ModifySubscriptionResponse implements ModifySubscriptionResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly revisedPublishingInterval: Double;
    readonly revisedLifetimeCount: UInt32;
    readonly revisedMaxKeepAliveCount: UInt32;
    constructor(options?: ModifySubscriptionResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.revisedPublishingInterval = options?.revisedPublishingInterval ?? 0;
        this.revisedLifetimeCount = options?.revisedLifetimeCount ?? 0;
        this.revisedMaxKeepAliveCount = options?.revisedMaxKeepAliveCount ?? 0;
    }
    static [typeId] = NodeIds.ModifySubscriptionResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeDouble(this.revisedPublishingInterval);
        encoder.writeUInt32(this.revisedLifetimeCount);
        encoder.writeUInt32(this.revisedMaxKeepAliveCount);
    }
    static [decode](decoder: BinaryDataDecoder): ModifySubscriptionResponse {
        return new ModifySubscriptionResponse({
            responseHeader: decoder.readType(ResponseHeader),
            revisedPublishingInterval: decoder.readDouble(),
            revisedLifetimeCount: decoder.readUInt32(),
            revisedMaxKeepAliveCount: decoder.readUInt32()
        });
    }
}
export interface SetPublishingModeRequestOptions {
    requestHeader?: RequestHeader | undefined;
    publishingEnabled?: boolean | undefined;
    subscriptionIds?: UInt32[] | undefined;
}
export class SetPublishingModeRequest implements SetPublishingModeRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly publishingEnabled: boolean;
    readonly subscriptionIds?: UInt32[];
    constructor(options?: SetPublishingModeRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.subscriptionIds = options?.subscriptionIds;
    }
    static [typeId] = NodeIds.SetPublishingModeRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeUInt32Array(this.subscriptionIds);
    }
    static [decode](decoder: BinaryDataDecoder): SetPublishingModeRequest {
        return new SetPublishingModeRequest({
            requestHeader: decoder.readType(RequestHeader),
            publishingEnabled: decoder.readBoolean(),
            subscriptionIds: decoder.readUInt32Array()
        });
    }
}
export interface SetPublishingModeResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class SetPublishingModeResponse implements SetPublishingModeResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: SetPublishingModeResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.SetPublishingModeResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): SetPublishingModeResponse {
        return new SetPublishingModeResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface NotificationMessageOptions {
    sequenceNumber?: UInt32 | undefined;
    publishTime?: Date | undefined;
    notificationData?: ExtensionObject[] | undefined;
}
export class NotificationMessage implements NotificationMessageOptions {
    readonly sequenceNumber: UInt32;
    readonly publishTime: Date;
    readonly notificationData?: ExtensionObject[];
    constructor(options?: NotificationMessageOptions) {
        this.sequenceNumber = options?.sequenceNumber ?? 0;
        this.publishTime = options?.publishTime ?? new Date(-11644473600000);
        this.notificationData = options?.notificationData;
    }
    static [typeId] = NodeIds.NotificationMessage_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.sequenceNumber);
        encoder.writeDateTime(this.publishTime);
        encoder.writeTypeArray(this.notificationData);
    }
    static [decode](decoder: BinaryDataDecoder): NotificationMessage {
        return new NotificationMessage({
            sequenceNumber: decoder.readUInt32(),
            publishTime: decoder.readDateTime(),
            notificationData: decoder.readTypeArray(ExtensionObject)
        });
    }
}
export class NotificationData {
    static [typeId] = NodeIds.NotificationData_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
    }
    static [decode](decoder: BinaryDataDecoder): NotificationData {
        return new NotificationData();
    }
}
export interface DataChangeNotificationOptions {
    monitoredItems?: MonitoredItemNotification[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class DataChangeNotification implements DataChangeNotificationOptions {
    readonly monitoredItems?: MonitoredItemNotification[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DataChangeNotificationOptions) {
        this.monitoredItems = options?.monitoredItems;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DataChangeNotification_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.monitoredItems);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DataChangeNotification {
        return new DataChangeNotification({
            monitoredItems: decoder.readTypeArray(MonitoredItemNotification),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface MonitoredItemNotificationOptions {
    clientHandle?: UInt32 | undefined;
    value?: DataValue | undefined;
}
export class MonitoredItemNotification implements MonitoredItemNotificationOptions {
    readonly clientHandle: UInt32;
    readonly value: DataValue;
    constructor(options?: MonitoredItemNotificationOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.value = options?.value ?? new DataValue();
    }
    static [typeId] = NodeIds.MonitoredItemNotification_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeType(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): MonitoredItemNotification {
        return new MonitoredItemNotification({
            clientHandle: decoder.readUInt32(),
            value: decoder.readType(DataValue)
        });
    }
}
export interface EventNotificationListOptions {
    events?: EventFieldList[] | undefined;
}
export class EventNotificationList implements EventNotificationListOptions {
    readonly events?: EventFieldList[];
    constructor(options?: EventNotificationListOptions) {
        this.events = options?.events;
    }
    static [typeId] = NodeIds.EventNotificationList_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.events);
    }
    static [decode](decoder: BinaryDataDecoder): EventNotificationList {
        return new EventNotificationList({
            events: decoder.readTypeArray(EventFieldList)
        });
    }
}
export interface EventFieldListOptions {
    clientHandle?: UInt32 | undefined;
    eventFields?: Variant[] | undefined;
}
export class EventFieldList implements EventFieldListOptions {
    readonly clientHandle: UInt32;
    readonly eventFields?: Variant[];
    constructor(options?: EventFieldListOptions) {
        this.clientHandle = options?.clientHandle ?? 0;
        this.eventFields = options?.eventFields;
    }
    static [typeId] = NodeIds.EventFieldList_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.clientHandle);
        encoder.writeTypeArray(this.eventFields);
    }
    static [decode](decoder: BinaryDataDecoder): EventFieldList {
        return new EventFieldList({
            clientHandle: decoder.readUInt32(),
            eventFields: decoder.readTypeArray(Variant)
        });
    }
}
export interface HistoryEventFieldListOptions {
    eventFields?: Variant[] | undefined;
}
export class HistoryEventFieldList implements HistoryEventFieldListOptions {
    readonly eventFields?: Variant[];
    constructor(options?: HistoryEventFieldListOptions) {
        this.eventFields = options?.eventFields;
    }
    static [typeId] = NodeIds.HistoryEventFieldList_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeTypeArray(this.eventFields);
    }
    static [decode](decoder: BinaryDataDecoder): HistoryEventFieldList {
        return new HistoryEventFieldList({
            eventFields: decoder.readTypeArray(Variant)
        });
    }
}
export interface StatusChangeNotificationOptions {
    status?: StatusCode | undefined;
    diagnosticInfo?: DiagnosticInfo | undefined;
}
export class StatusChangeNotification implements StatusChangeNotificationOptions {
    readonly status: StatusCode;
    readonly diagnosticInfo: DiagnosticInfo;
    constructor(options?: StatusChangeNotificationOptions) {
        this.status = options?.status ?? StatusCode.Good;
        this.diagnosticInfo = options?.diagnosticInfo ?? new DiagnosticInfo();
    }
    static [typeId] = NodeIds.StatusChangeNotification_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.status);
        encoder.writeType(this.diagnosticInfo);
    }
    static [decode](decoder: BinaryDataDecoder): StatusChangeNotification {
        return new StatusChangeNotification({
            status: decoder.readType(StatusCode),
            diagnosticInfo: decoder.readType(DiagnosticInfo)
        });
    }
}
export interface SubscriptionAcknowledgementOptions {
    subscriptionId?: UInt32 | undefined;
    sequenceNumber?: UInt32 | undefined;
}
export class SubscriptionAcknowledgement implements SubscriptionAcknowledgementOptions {
    readonly subscriptionId: UInt32;
    readonly sequenceNumber: UInt32;
    constructor(options?: SubscriptionAcknowledgementOptions) {
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.sequenceNumber = options?.sequenceNumber ?? 0;
    }
    static [typeId] = NodeIds.SubscriptionAcknowledgement_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.sequenceNumber);
    }
    static [decode](decoder: BinaryDataDecoder): SubscriptionAcknowledgement {
        return new SubscriptionAcknowledgement({
            subscriptionId: decoder.readUInt32(),
            sequenceNumber: decoder.readUInt32()
        });
    }
}
export interface PublishRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionAcknowledgements?: SubscriptionAcknowledgement[] | undefined;
}
export class PublishRequest implements PublishRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionAcknowledgements?: SubscriptionAcknowledgement[];
    constructor(options?: PublishRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionAcknowledgements = options?.subscriptionAcknowledgements;
    }
    static [typeId] = NodeIds.PublishRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeTypeArray(this.subscriptionAcknowledgements);
    }
    static [decode](decoder: BinaryDataDecoder): PublishRequest {
        return new PublishRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionAcknowledgements: decoder.readTypeArray(SubscriptionAcknowledgement)
        });
    }
}
export interface PublishResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    availableSequenceNumbers?: UInt32[] | undefined;
    moreNotifications?: boolean | undefined;
    notificationMessage?: NotificationMessage | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class PublishResponse implements PublishResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly subscriptionId: UInt32;
    readonly availableSequenceNumbers?: UInt32[];
    readonly moreNotifications: boolean;
    readonly notificationMessage: NotificationMessage;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: PublishResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.availableSequenceNumbers = options?.availableSequenceNumbers;
        this.moreNotifications = options?.moreNotifications ?? false;
        this.notificationMessage = options?.notificationMessage ?? new NotificationMessage();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.PublishResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32Array(this.availableSequenceNumbers);
        encoder.writeBoolean(this.moreNotifications);
        encoder.writeType(this.notificationMessage);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): PublishResponse {
        return new PublishResponse({
            responseHeader: decoder.readType(ResponseHeader),
            subscriptionId: decoder.readUInt32(),
            availableSequenceNumbers: decoder.readUInt32Array(),
            moreNotifications: decoder.readBoolean(),
            notificationMessage: decoder.readType(NotificationMessage),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface RepublishRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionId?: UInt32 | undefined;
    retransmitSequenceNumber?: UInt32 | undefined;
}
export class RepublishRequest implements RepublishRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionId: UInt32;
    readonly retransmitSequenceNumber: UInt32;
    constructor(options?: RepublishRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.retransmitSequenceNumber = options?.retransmitSequenceNumber ?? 0;
    }
    static [typeId] = NodeIds.RepublishRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeUInt32(this.retransmitSequenceNumber);
    }
    static [decode](decoder: BinaryDataDecoder): RepublishRequest {
        return new RepublishRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionId: decoder.readUInt32(),
            retransmitSequenceNumber: decoder.readUInt32()
        });
    }
}
export interface RepublishResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    notificationMessage?: NotificationMessage | undefined;
}
export class RepublishResponse implements RepublishResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly notificationMessage: NotificationMessage;
    constructor(options?: RepublishResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.notificationMessage = options?.notificationMessage ?? new NotificationMessage();
    }
    static [typeId] = NodeIds.RepublishResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeType(this.notificationMessage);
    }
    static [decode](decoder: BinaryDataDecoder): RepublishResponse {
        return new RepublishResponse({
            responseHeader: decoder.readType(ResponseHeader),
            notificationMessage: decoder.readType(NotificationMessage)
        });
    }
}
export interface TransferResultOptions {
    statusCode?: StatusCode | undefined;
    availableSequenceNumbers?: UInt32[] | undefined;
}
export class TransferResult implements TransferResultOptions {
    readonly statusCode: StatusCode;
    readonly availableSequenceNumbers?: UInt32[];
    constructor(options?: TransferResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.availableSequenceNumbers = options?.availableSequenceNumbers;
    }
    static [typeId] = NodeIds.TransferResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeUInt32Array(this.availableSequenceNumbers);
    }
    static [decode](decoder: BinaryDataDecoder): TransferResult {
        return new TransferResult({
            statusCode: decoder.readType(StatusCode),
            availableSequenceNumbers: decoder.readUInt32Array()
        });
    }
}
export interface TransferSubscriptionsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionIds?: UInt32[] | undefined;
    sendInitialValues?: boolean | undefined;
}
export class TransferSubscriptionsRequest implements TransferSubscriptionsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionIds?: UInt32[];
    readonly sendInitialValues: boolean;
    constructor(options?: TransferSubscriptionsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionIds = options?.subscriptionIds;
        this.sendInitialValues = options?.sendInitialValues ?? false;
    }
    static [typeId] = NodeIds.TransferSubscriptionsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32Array(this.subscriptionIds);
        encoder.writeBoolean(this.sendInitialValues);
    }
    static [decode](decoder: BinaryDataDecoder): TransferSubscriptionsRequest {
        return new TransferSubscriptionsRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionIds: decoder.readUInt32Array(),
            sendInitialValues: decoder.readBoolean()
        });
    }
}
export interface TransferSubscriptionsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: TransferResult[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class TransferSubscriptionsResponse implements TransferSubscriptionsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: TransferResult[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: TransferSubscriptionsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.TransferSubscriptionsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): TransferSubscriptionsResponse {
        return new TransferSubscriptionsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(TransferResult),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface DeleteSubscriptionsRequestOptions {
    requestHeader?: RequestHeader | undefined;
    subscriptionIds?: UInt32[] | undefined;
}
export class DeleteSubscriptionsRequest implements DeleteSubscriptionsRequestOptions {
    readonly requestHeader: RequestHeader;
    readonly subscriptionIds?: UInt32[];
    constructor(options?: DeleteSubscriptionsRequestOptions) {
        this.requestHeader = options?.requestHeader ?? new RequestHeader();
        this.subscriptionIds = options?.subscriptionIds;
    }
    static [typeId] = NodeIds.DeleteSubscriptionsRequest_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.requestHeader);
        encoder.writeUInt32Array(this.subscriptionIds);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteSubscriptionsRequest {
        return new DeleteSubscriptionsRequest({
            requestHeader: decoder.readType(RequestHeader),
            subscriptionIds: decoder.readUInt32Array()
        });
    }
}
export interface DeleteSubscriptionsResponseOptions {
    responseHeader?: ResponseHeader | undefined;
    results?: StatusCode[] | undefined;
    diagnosticInfos?: DiagnosticInfo[] | undefined;
}
export class DeleteSubscriptionsResponse implements DeleteSubscriptionsResponseOptions {
    readonly responseHeader: ResponseHeader;
    readonly results?: StatusCode[];
    readonly diagnosticInfos?: DiagnosticInfo[];
    constructor(options?: DeleteSubscriptionsResponseOptions) {
        this.responseHeader = options?.responseHeader ?? new ResponseHeader();
        this.results = options?.results;
        this.diagnosticInfos = options?.diagnosticInfos;
    }
    static [typeId] = NodeIds.DeleteSubscriptionsResponse_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.responseHeader);
        encoder.writeTypeArray(this.results);
        encoder.writeTypeArray(this.diagnosticInfos);
    }
    static [decode](decoder: BinaryDataDecoder): DeleteSubscriptionsResponse {
        return new DeleteSubscriptionsResponse({
            responseHeader: decoder.readType(ResponseHeader),
            results: decoder.readTypeArray(StatusCode),
            diagnosticInfos: decoder.readTypeArray(DiagnosticInfo)
        });
    }
}
export interface BuildInfoOptions {
    productUri?: UaString | undefined;
    manufacturerName?: UaString | undefined;
    productName?: UaString | undefined;
    softwareVersion?: UaString | undefined;
    buildNumber?: UaString | undefined;
    buildDate?: Date | undefined;
}
export class BuildInfo implements BuildInfoOptions {
    readonly productUri?: UaString;
    readonly manufacturerName?: UaString;
    readonly productName?: UaString;
    readonly softwareVersion?: UaString;
    readonly buildNumber?: UaString;
    readonly buildDate: Date;
    constructor(options?: BuildInfoOptions) {
        this.productUri = options?.productUri;
        this.manufacturerName = options?.manufacturerName;
        this.productName = options?.productName;
        this.softwareVersion = options?.softwareVersion;
        this.buildNumber = options?.buildNumber;
        this.buildDate = options?.buildDate ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.BuildInfo_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.productUri);
        encoder.writeString(this.manufacturerName);
        encoder.writeString(this.productName);
        encoder.writeString(this.softwareVersion);
        encoder.writeString(this.buildNumber);
        encoder.writeDateTime(this.buildDate);
    }
    static [decode](decoder: BinaryDataDecoder): BuildInfo {
        return new BuildInfo({
            productUri: decoder.readString(),
            manufacturerName: decoder.readString(),
            productName: decoder.readString(),
            softwareVersion: decoder.readString(),
            buildNumber: decoder.readString(),
            buildDate: decoder.readDateTime()
        });
    }
}
export enum RedundancySupport {
    None = 0,
    Cold = 1,
    Warm = 2,
    Hot = 3,
    Transparent = 4,
    HotAndMirrored = 5
}
export enum ServerState {
    Running = 0,
    Failed = 1,
    NoConfiguration = 2,
    Suspended = 3,
    Shutdown = 4,
    Test = 5,
    CommunicationFault = 6,
    Unknown = 7
}
export interface RedundantServerDataTypeOptions {
    serverId?: UaString | undefined;
    serviceLevel?: Byte | undefined;
    serverState?: ServerState | undefined;
}
export class RedundantServerDataType implements RedundantServerDataTypeOptions {
    readonly serverId?: UaString;
    readonly serviceLevel: Byte;
    readonly serverState: ServerState;
    constructor(options?: RedundantServerDataTypeOptions) {
        this.serverId = options?.serverId;
        this.serviceLevel = options?.serviceLevel ?? 0;
        this.serverState = options?.serverState ?? ServerState.Running;
    }
    static [typeId] = NodeIds.RedundantServerDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverId);
        encoder.writeByte(this.serviceLevel);
        encoder.writeUInt32(this.serverState);
    }
    static [decode](decoder: BinaryDataDecoder): RedundantServerDataType {
        return new RedundantServerDataType({
            serverId: decoder.readString(),
            serviceLevel: decoder.readByte(),
            serverState: decoder.readUInt32()
        });
    }
}
export interface EndpointUrlListDataTypeOptions {
    endpointUrlList?: UaString[] | undefined;
}
export class EndpointUrlListDataType implements EndpointUrlListDataTypeOptions {
    readonly endpointUrlList?: UaString[];
    constructor(options?: EndpointUrlListDataTypeOptions) {
        this.endpointUrlList = options?.endpointUrlList;
    }
    static [typeId] = NodeIds.EndpointUrlListDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeStringArray(this.endpointUrlList);
    }
    static [decode](decoder: BinaryDataDecoder): EndpointUrlListDataType {
        return new EndpointUrlListDataType({
            endpointUrlList: decoder.readStringArray()
        });
    }
}
export interface NetworkGroupDataTypeOptions {
    serverUri?: UaString | undefined;
    networkPaths?: EndpointUrlListDataType[] | undefined;
}
export class NetworkGroupDataType implements NetworkGroupDataTypeOptions {
    readonly serverUri?: UaString;
    readonly networkPaths?: EndpointUrlListDataType[];
    constructor(options?: NetworkGroupDataTypeOptions) {
        this.serverUri = options?.serverUri;
        this.networkPaths = options?.networkPaths;
    }
    static [typeId] = NodeIds.NetworkGroupDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.serverUri);
        encoder.writeTypeArray(this.networkPaths);
    }
    static [decode](decoder: BinaryDataDecoder): NetworkGroupDataType {
        return new NetworkGroupDataType({
            serverUri: decoder.readString(),
            networkPaths: decoder.readTypeArray(EndpointUrlListDataType)
        });
    }
}
export interface SamplingIntervalDiagnosticsDataTypeOptions {
    samplingInterval?: Double | undefined;
    monitoredItemCount?: UInt32 | undefined;
    maxMonitoredItemCount?: UInt32 | undefined;
    disabledMonitoredItemCount?: UInt32 | undefined;
}
export class SamplingIntervalDiagnosticsDataType implements SamplingIntervalDiagnosticsDataTypeOptions {
    readonly samplingInterval: Double;
    readonly monitoredItemCount: UInt32;
    readonly maxMonitoredItemCount: UInt32;
    readonly disabledMonitoredItemCount: UInt32;
    constructor(options?: SamplingIntervalDiagnosticsDataTypeOptions) {
        this.samplingInterval = options?.samplingInterval ?? 0;
        this.monitoredItemCount = options?.monitoredItemCount ?? 0;
        this.maxMonitoredItemCount = options?.maxMonitoredItemCount ?? 0;
        this.disabledMonitoredItemCount = options?.disabledMonitoredItemCount ?? 0;
    }
    static [typeId] = NodeIds.SamplingIntervalDiagnosticsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.samplingInterval);
        encoder.writeUInt32(this.monitoredItemCount);
        encoder.writeUInt32(this.maxMonitoredItemCount);
        encoder.writeUInt32(this.disabledMonitoredItemCount);
    }
    static [decode](decoder: BinaryDataDecoder): SamplingIntervalDiagnosticsDataType {
        return new SamplingIntervalDiagnosticsDataType({
            samplingInterval: decoder.readDouble(),
            monitoredItemCount: decoder.readUInt32(),
            maxMonitoredItemCount: decoder.readUInt32(),
            disabledMonitoredItemCount: decoder.readUInt32()
        });
    }
}
export interface ServerDiagnosticsSummaryDataTypeOptions {
    serverViewCount?: UInt32 | undefined;
    currentSessionCount?: UInt32 | undefined;
    cumulatedSessionCount?: UInt32 | undefined;
    securityRejectedSessionCount?: UInt32 | undefined;
    rejectedSessionCount?: UInt32 | undefined;
    sessionTimeoutCount?: UInt32 | undefined;
    sessionAbortCount?: UInt32 | undefined;
    currentSubscriptionCount?: UInt32 | undefined;
    cumulatedSubscriptionCount?: UInt32 | undefined;
    publishingIntervalCount?: UInt32 | undefined;
    securityRejectedRequestsCount?: UInt32 | undefined;
    rejectedRequestsCount?: UInt32 | undefined;
}
export class ServerDiagnosticsSummaryDataType implements ServerDiagnosticsSummaryDataTypeOptions {
    readonly serverViewCount: UInt32;
    readonly currentSessionCount: UInt32;
    readonly cumulatedSessionCount: UInt32;
    readonly securityRejectedSessionCount: UInt32;
    readonly rejectedSessionCount: UInt32;
    readonly sessionTimeoutCount: UInt32;
    readonly sessionAbortCount: UInt32;
    readonly currentSubscriptionCount: UInt32;
    readonly cumulatedSubscriptionCount: UInt32;
    readonly publishingIntervalCount: UInt32;
    readonly securityRejectedRequestsCount: UInt32;
    readonly rejectedRequestsCount: UInt32;
    constructor(options?: ServerDiagnosticsSummaryDataTypeOptions) {
        this.serverViewCount = options?.serverViewCount ?? 0;
        this.currentSessionCount = options?.currentSessionCount ?? 0;
        this.cumulatedSessionCount = options?.cumulatedSessionCount ?? 0;
        this.securityRejectedSessionCount = options?.securityRejectedSessionCount ?? 0;
        this.rejectedSessionCount = options?.rejectedSessionCount ?? 0;
        this.sessionTimeoutCount = options?.sessionTimeoutCount ?? 0;
        this.sessionAbortCount = options?.sessionAbortCount ?? 0;
        this.currentSubscriptionCount = options?.currentSubscriptionCount ?? 0;
        this.cumulatedSubscriptionCount = options?.cumulatedSubscriptionCount ?? 0;
        this.publishingIntervalCount = options?.publishingIntervalCount ?? 0;
        this.securityRejectedRequestsCount = options?.securityRejectedRequestsCount ?? 0;
        this.rejectedRequestsCount = options?.rejectedRequestsCount ?? 0;
    }
    static [typeId] = NodeIds.ServerDiagnosticsSummaryDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.serverViewCount);
        encoder.writeUInt32(this.currentSessionCount);
        encoder.writeUInt32(this.cumulatedSessionCount);
        encoder.writeUInt32(this.securityRejectedSessionCount);
        encoder.writeUInt32(this.rejectedSessionCount);
        encoder.writeUInt32(this.sessionTimeoutCount);
        encoder.writeUInt32(this.sessionAbortCount);
        encoder.writeUInt32(this.currentSubscriptionCount);
        encoder.writeUInt32(this.cumulatedSubscriptionCount);
        encoder.writeUInt32(this.publishingIntervalCount);
        encoder.writeUInt32(this.securityRejectedRequestsCount);
        encoder.writeUInt32(this.rejectedRequestsCount);
    }
    static [decode](decoder: BinaryDataDecoder): ServerDiagnosticsSummaryDataType {
        return new ServerDiagnosticsSummaryDataType({
            serverViewCount: decoder.readUInt32(),
            currentSessionCount: decoder.readUInt32(),
            cumulatedSessionCount: decoder.readUInt32(),
            securityRejectedSessionCount: decoder.readUInt32(),
            rejectedSessionCount: decoder.readUInt32(),
            sessionTimeoutCount: decoder.readUInt32(),
            sessionAbortCount: decoder.readUInt32(),
            currentSubscriptionCount: decoder.readUInt32(),
            cumulatedSubscriptionCount: decoder.readUInt32(),
            publishingIntervalCount: decoder.readUInt32(),
            securityRejectedRequestsCount: decoder.readUInt32(),
            rejectedRequestsCount: decoder.readUInt32()
        });
    }
}
export interface ServerStatusDataTypeOptions {
    startTime?: Date | undefined;
    currentTime?: Date | undefined;
    state?: ServerState | undefined;
    buildInfo?: BuildInfo | undefined;
    secondsTillShutdown?: UInt32 | undefined;
    shutdownReason?: LocalizedText | undefined;
}
export class ServerStatusDataType implements ServerStatusDataTypeOptions {
    readonly startTime: Date;
    readonly currentTime: Date;
    readonly state: ServerState;
    readonly buildInfo: BuildInfo;
    readonly secondsTillShutdown: UInt32;
    readonly shutdownReason: LocalizedText;
    constructor(options?: ServerStatusDataTypeOptions) {
        this.startTime = options?.startTime ?? new Date(-11644473600000);
        this.currentTime = options?.currentTime ?? new Date(-11644473600000);
        this.state = options?.state ?? ServerState.Running;
        this.buildInfo = options?.buildInfo ?? new BuildInfo();
        this.secondsTillShutdown = options?.secondsTillShutdown ?? 0;
        this.shutdownReason = options?.shutdownReason ?? new LocalizedText();
    }
    static [typeId] = NodeIds.ServerStatusDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDateTime(this.startTime);
        encoder.writeDateTime(this.currentTime);
        encoder.writeUInt32(this.state);
        encoder.writeType(this.buildInfo);
        encoder.writeUInt32(this.secondsTillShutdown);
        encoder.writeType(this.shutdownReason);
    }
    static [decode](decoder: BinaryDataDecoder): ServerStatusDataType {
        return new ServerStatusDataType({
            startTime: decoder.readDateTime(),
            currentTime: decoder.readDateTime(),
            state: decoder.readUInt32(),
            buildInfo: decoder.readType(BuildInfo),
            secondsTillShutdown: decoder.readUInt32(),
            shutdownReason: decoder.readType(LocalizedText)
        });
    }
}
export interface SessionDiagnosticsDataTypeOptions {
    sessionId?: NodeId | undefined;
    sessionName?: UaString | undefined;
    clientDescription?: ApplicationDescription | undefined;
    serverUri?: UaString | undefined;
    endpointUrl?: UaString | undefined;
    localeIds?: UaString[] | undefined;
    actualSessionTimeout?: Double | undefined;
    maxResponseMessageSize?: UInt32 | undefined;
    clientConnectionTime?: Date | undefined;
    clientLastContactTime?: Date | undefined;
    currentSubscriptionsCount?: UInt32 | undefined;
    currentMonitoredItemsCount?: UInt32 | undefined;
    currentPublishRequestsInQueue?: UInt32 | undefined;
    totalRequestCount?: ServiceCounterDataType | undefined;
    unauthorizedRequestCount?: UInt32 | undefined;
    readCount?: ServiceCounterDataType | undefined;
    historyReadCount?: ServiceCounterDataType | undefined;
    writeCount?: ServiceCounterDataType | undefined;
    historyUpdateCount?: ServiceCounterDataType | undefined;
    callCount?: ServiceCounterDataType | undefined;
    createMonitoredItemsCount?: ServiceCounterDataType | undefined;
    modifyMonitoredItemsCount?: ServiceCounterDataType | undefined;
    setMonitoringModeCount?: ServiceCounterDataType | undefined;
    setTriggeringCount?: ServiceCounterDataType | undefined;
    deleteMonitoredItemsCount?: ServiceCounterDataType | undefined;
    createSubscriptionCount?: ServiceCounterDataType | undefined;
    modifySubscriptionCount?: ServiceCounterDataType | undefined;
    setPublishingModeCount?: ServiceCounterDataType | undefined;
    publishCount?: ServiceCounterDataType | undefined;
    republishCount?: ServiceCounterDataType | undefined;
    transferSubscriptionsCount?: ServiceCounterDataType | undefined;
    deleteSubscriptionsCount?: ServiceCounterDataType | undefined;
    addNodesCount?: ServiceCounterDataType | undefined;
    addReferencesCount?: ServiceCounterDataType | undefined;
    deleteNodesCount?: ServiceCounterDataType | undefined;
    deleteReferencesCount?: ServiceCounterDataType | undefined;
    browseCount?: ServiceCounterDataType | undefined;
    browseNextCount?: ServiceCounterDataType | undefined;
    translateBrowsePathsToNodeIdsCount?: ServiceCounterDataType | undefined;
    queryFirstCount?: ServiceCounterDataType | undefined;
    queryNextCount?: ServiceCounterDataType | undefined;
    registerNodesCount?: ServiceCounterDataType | undefined;
    unregisterNodesCount?: ServiceCounterDataType | undefined;
}
export class SessionDiagnosticsDataType implements SessionDiagnosticsDataTypeOptions {
    readonly sessionId: NodeId;
    readonly sessionName?: UaString;
    readonly clientDescription: ApplicationDescription;
    readonly serverUri?: UaString;
    readonly endpointUrl?: UaString;
    readonly localeIds?: UaString[];
    readonly actualSessionTimeout: Double;
    readonly maxResponseMessageSize: UInt32;
    readonly clientConnectionTime: Date;
    readonly clientLastContactTime: Date;
    readonly currentSubscriptionsCount: UInt32;
    readonly currentMonitoredItemsCount: UInt32;
    readonly currentPublishRequestsInQueue: UInt32;
    readonly totalRequestCount: ServiceCounterDataType;
    readonly unauthorizedRequestCount: UInt32;
    readonly readCount: ServiceCounterDataType;
    readonly historyReadCount: ServiceCounterDataType;
    readonly writeCount: ServiceCounterDataType;
    readonly historyUpdateCount: ServiceCounterDataType;
    readonly callCount: ServiceCounterDataType;
    readonly createMonitoredItemsCount: ServiceCounterDataType;
    readonly modifyMonitoredItemsCount: ServiceCounterDataType;
    readonly setMonitoringModeCount: ServiceCounterDataType;
    readonly setTriggeringCount: ServiceCounterDataType;
    readonly deleteMonitoredItemsCount: ServiceCounterDataType;
    readonly createSubscriptionCount: ServiceCounterDataType;
    readonly modifySubscriptionCount: ServiceCounterDataType;
    readonly setPublishingModeCount: ServiceCounterDataType;
    readonly publishCount: ServiceCounterDataType;
    readonly republishCount: ServiceCounterDataType;
    readonly transferSubscriptionsCount: ServiceCounterDataType;
    readonly deleteSubscriptionsCount: ServiceCounterDataType;
    readonly addNodesCount: ServiceCounterDataType;
    readonly addReferencesCount: ServiceCounterDataType;
    readonly deleteNodesCount: ServiceCounterDataType;
    readonly deleteReferencesCount: ServiceCounterDataType;
    readonly browseCount: ServiceCounterDataType;
    readonly browseNextCount: ServiceCounterDataType;
    readonly translateBrowsePathsToNodeIdsCount: ServiceCounterDataType;
    readonly queryFirstCount: ServiceCounterDataType;
    readonly queryNextCount: ServiceCounterDataType;
    readonly registerNodesCount: ServiceCounterDataType;
    readonly unregisterNodesCount: ServiceCounterDataType;
    constructor(options?: SessionDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.sessionName = options?.sessionName;
        this.clientDescription = options?.clientDescription ?? new ApplicationDescription();
        this.serverUri = options?.serverUri;
        this.endpointUrl = options?.endpointUrl;
        this.localeIds = options?.localeIds;
        this.actualSessionTimeout = options?.actualSessionTimeout ?? 0;
        this.maxResponseMessageSize = options?.maxResponseMessageSize ?? 0;
        this.clientConnectionTime = options?.clientConnectionTime ?? new Date(-11644473600000);
        this.clientLastContactTime = options?.clientLastContactTime ?? new Date(-11644473600000);
        this.currentSubscriptionsCount = options?.currentSubscriptionsCount ?? 0;
        this.currentMonitoredItemsCount = options?.currentMonitoredItemsCount ?? 0;
        this.currentPublishRequestsInQueue = options?.currentPublishRequestsInQueue ?? 0;
        this.totalRequestCount = options?.totalRequestCount ?? new ServiceCounterDataType();
        this.unauthorizedRequestCount = options?.unauthorizedRequestCount ?? 0;
        this.readCount = options?.readCount ?? new ServiceCounterDataType();
        this.historyReadCount = options?.historyReadCount ?? new ServiceCounterDataType();
        this.writeCount = options?.writeCount ?? new ServiceCounterDataType();
        this.historyUpdateCount = options?.historyUpdateCount ?? new ServiceCounterDataType();
        this.callCount = options?.callCount ?? new ServiceCounterDataType();
        this.createMonitoredItemsCount = options?.createMonitoredItemsCount ?? new ServiceCounterDataType();
        this.modifyMonitoredItemsCount = options?.modifyMonitoredItemsCount ?? new ServiceCounterDataType();
        this.setMonitoringModeCount = options?.setMonitoringModeCount ?? new ServiceCounterDataType();
        this.setTriggeringCount = options?.setTriggeringCount ?? new ServiceCounterDataType();
        this.deleteMonitoredItemsCount = options?.deleteMonitoredItemsCount ?? new ServiceCounterDataType();
        this.createSubscriptionCount = options?.createSubscriptionCount ?? new ServiceCounterDataType();
        this.modifySubscriptionCount = options?.modifySubscriptionCount ?? new ServiceCounterDataType();
        this.setPublishingModeCount = options?.setPublishingModeCount ?? new ServiceCounterDataType();
        this.publishCount = options?.publishCount ?? new ServiceCounterDataType();
        this.republishCount = options?.republishCount ?? new ServiceCounterDataType();
        this.transferSubscriptionsCount = options?.transferSubscriptionsCount ?? new ServiceCounterDataType();
        this.deleteSubscriptionsCount = options?.deleteSubscriptionsCount ?? new ServiceCounterDataType();
        this.addNodesCount = options?.addNodesCount ?? new ServiceCounterDataType();
        this.addReferencesCount = options?.addReferencesCount ?? new ServiceCounterDataType();
        this.deleteNodesCount = options?.deleteNodesCount ?? new ServiceCounterDataType();
        this.deleteReferencesCount = options?.deleteReferencesCount ?? new ServiceCounterDataType();
        this.browseCount = options?.browseCount ?? new ServiceCounterDataType();
        this.browseNextCount = options?.browseNextCount ?? new ServiceCounterDataType();
        this.translateBrowsePathsToNodeIdsCount = options?.translateBrowsePathsToNodeIdsCount ?? new ServiceCounterDataType();
        this.queryFirstCount = options?.queryFirstCount ?? new ServiceCounterDataType();
        this.queryNextCount = options?.queryNextCount ?? new ServiceCounterDataType();
        this.registerNodesCount = options?.registerNodesCount ?? new ServiceCounterDataType();
        this.unregisterNodesCount = options?.unregisterNodesCount ?? new ServiceCounterDataType();
    }
    static [typeId] = NodeIds.SessionDiagnosticsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeString(this.sessionName);
        encoder.writeType(this.clientDescription);
        encoder.writeString(this.serverUri);
        encoder.writeString(this.endpointUrl);
        encoder.writeStringArray(this.localeIds);
        encoder.writeDouble(this.actualSessionTimeout);
        encoder.writeUInt32(this.maxResponseMessageSize);
        encoder.writeDateTime(this.clientConnectionTime);
        encoder.writeDateTime(this.clientLastContactTime);
        encoder.writeUInt32(this.currentSubscriptionsCount);
        encoder.writeUInt32(this.currentMonitoredItemsCount);
        encoder.writeUInt32(this.currentPublishRequestsInQueue);
        encoder.writeType(this.totalRequestCount);
        encoder.writeUInt32(this.unauthorizedRequestCount);
        encoder.writeType(this.readCount);
        encoder.writeType(this.historyReadCount);
        encoder.writeType(this.writeCount);
        encoder.writeType(this.historyUpdateCount);
        encoder.writeType(this.callCount);
        encoder.writeType(this.createMonitoredItemsCount);
        encoder.writeType(this.modifyMonitoredItemsCount);
        encoder.writeType(this.setMonitoringModeCount);
        encoder.writeType(this.setTriggeringCount);
        encoder.writeType(this.deleteMonitoredItemsCount);
        encoder.writeType(this.createSubscriptionCount);
        encoder.writeType(this.modifySubscriptionCount);
        encoder.writeType(this.setPublishingModeCount);
        encoder.writeType(this.publishCount);
        encoder.writeType(this.republishCount);
        encoder.writeType(this.transferSubscriptionsCount);
        encoder.writeType(this.deleteSubscriptionsCount);
        encoder.writeType(this.addNodesCount);
        encoder.writeType(this.addReferencesCount);
        encoder.writeType(this.deleteNodesCount);
        encoder.writeType(this.deleteReferencesCount);
        encoder.writeType(this.browseCount);
        encoder.writeType(this.browseNextCount);
        encoder.writeType(this.translateBrowsePathsToNodeIdsCount);
        encoder.writeType(this.queryFirstCount);
        encoder.writeType(this.queryNextCount);
        encoder.writeType(this.registerNodesCount);
        encoder.writeType(this.unregisterNodesCount);
    }
    static [decode](decoder: BinaryDataDecoder): SessionDiagnosticsDataType {
        return new SessionDiagnosticsDataType({
            sessionId: decoder.readType(NodeId),
            sessionName: decoder.readString(),
            clientDescription: decoder.readType(ApplicationDescription),
            serverUri: decoder.readString(),
            endpointUrl: decoder.readString(),
            localeIds: decoder.readStringArray(),
            actualSessionTimeout: decoder.readDouble(),
            maxResponseMessageSize: decoder.readUInt32(),
            clientConnectionTime: decoder.readDateTime(),
            clientLastContactTime: decoder.readDateTime(),
            currentSubscriptionsCount: decoder.readUInt32(),
            currentMonitoredItemsCount: decoder.readUInt32(),
            currentPublishRequestsInQueue: decoder.readUInt32(),
            totalRequestCount: decoder.readType(ServiceCounterDataType),
            unauthorizedRequestCount: decoder.readUInt32(),
            readCount: decoder.readType(ServiceCounterDataType),
            historyReadCount: decoder.readType(ServiceCounterDataType),
            writeCount: decoder.readType(ServiceCounterDataType),
            historyUpdateCount: decoder.readType(ServiceCounterDataType),
            callCount: decoder.readType(ServiceCounterDataType),
            createMonitoredItemsCount: decoder.readType(ServiceCounterDataType),
            modifyMonitoredItemsCount: decoder.readType(ServiceCounterDataType),
            setMonitoringModeCount: decoder.readType(ServiceCounterDataType),
            setTriggeringCount: decoder.readType(ServiceCounterDataType),
            deleteMonitoredItemsCount: decoder.readType(ServiceCounterDataType),
            createSubscriptionCount: decoder.readType(ServiceCounterDataType),
            modifySubscriptionCount: decoder.readType(ServiceCounterDataType),
            setPublishingModeCount: decoder.readType(ServiceCounterDataType),
            publishCount: decoder.readType(ServiceCounterDataType),
            republishCount: decoder.readType(ServiceCounterDataType),
            transferSubscriptionsCount: decoder.readType(ServiceCounterDataType),
            deleteSubscriptionsCount: decoder.readType(ServiceCounterDataType),
            addNodesCount: decoder.readType(ServiceCounterDataType),
            addReferencesCount: decoder.readType(ServiceCounterDataType),
            deleteNodesCount: decoder.readType(ServiceCounterDataType),
            deleteReferencesCount: decoder.readType(ServiceCounterDataType),
            browseCount: decoder.readType(ServiceCounterDataType),
            browseNextCount: decoder.readType(ServiceCounterDataType),
            translateBrowsePathsToNodeIdsCount: decoder.readType(ServiceCounterDataType),
            queryFirstCount: decoder.readType(ServiceCounterDataType),
            queryNextCount: decoder.readType(ServiceCounterDataType),
            registerNodesCount: decoder.readType(ServiceCounterDataType),
            unregisterNodesCount: decoder.readType(ServiceCounterDataType)
        });
    }
}
export interface SessionSecurityDiagnosticsDataTypeOptions {
    sessionId?: NodeId | undefined;
    clientUserIdOfSession?: UaString | undefined;
    clientUserIdHistory?: UaString[] | undefined;
    authenticationMechanism?: UaString | undefined;
    encoding?: UaString | undefined;
    transportProtocol?: UaString | undefined;
    securityMode?: MessageSecurityMode | undefined;
    securityPolicyUri?: UaString | undefined;
    clientCertificate?: ByteString | undefined;
}
export class SessionSecurityDiagnosticsDataType implements SessionSecurityDiagnosticsDataTypeOptions {
    readonly sessionId: NodeId;
    readonly clientUserIdOfSession?: UaString;
    readonly clientUserIdHistory?: UaString[];
    readonly authenticationMechanism?: UaString;
    readonly encoding?: UaString;
    readonly transportProtocol?: UaString;
    readonly securityMode: MessageSecurityMode;
    readonly securityPolicyUri?: UaString;
    readonly clientCertificate?: ByteString;
    constructor(options?: SessionSecurityDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.clientUserIdOfSession = options?.clientUserIdOfSession;
        this.clientUserIdHistory = options?.clientUserIdHistory;
        this.authenticationMechanism = options?.authenticationMechanism;
        this.encoding = options?.encoding;
        this.transportProtocol = options?.transportProtocol;
        this.securityMode = options?.securityMode ?? MessageSecurityMode.Invalid;
        this.securityPolicyUri = options?.securityPolicyUri;
        this.clientCertificate = options?.clientCertificate;
    }
    static [typeId] = NodeIds.SessionSecurityDiagnosticsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeString(this.clientUserIdOfSession);
        encoder.writeStringArray(this.clientUserIdHistory);
        encoder.writeString(this.authenticationMechanism);
        encoder.writeString(this.encoding);
        encoder.writeString(this.transportProtocol);
        encoder.writeUInt32(this.securityMode);
        encoder.writeString(this.securityPolicyUri);
        encoder.writeByteString(this.clientCertificate);
    }
    static [decode](decoder: BinaryDataDecoder): SessionSecurityDiagnosticsDataType {
        return new SessionSecurityDiagnosticsDataType({
            sessionId: decoder.readType(NodeId),
            clientUserIdOfSession: decoder.readString(),
            clientUserIdHistory: decoder.readStringArray(),
            authenticationMechanism: decoder.readString(),
            encoding: decoder.readString(),
            transportProtocol: decoder.readString(),
            securityMode: decoder.readUInt32(),
            securityPolicyUri: decoder.readString(),
            clientCertificate: decoder.readByteString()
        });
    }
}
export interface ServiceCounterDataTypeOptions {
    totalCount?: UInt32 | undefined;
    errorCount?: UInt32 | undefined;
}
export class ServiceCounterDataType implements ServiceCounterDataTypeOptions {
    readonly totalCount: UInt32;
    readonly errorCount: UInt32;
    constructor(options?: ServiceCounterDataTypeOptions) {
        this.totalCount = options?.totalCount ?? 0;
        this.errorCount = options?.errorCount ?? 0;
    }
    static [typeId] = NodeIds.ServiceCounterDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeUInt32(this.totalCount);
        encoder.writeUInt32(this.errorCount);
    }
    static [decode](decoder: BinaryDataDecoder): ServiceCounterDataType {
        return new ServiceCounterDataType({
            totalCount: decoder.readUInt32(),
            errorCount: decoder.readUInt32()
        });
    }
}
export interface StatusResultOptions {
    statusCode?: StatusCode | undefined;
    diagnosticInfo?: DiagnosticInfo | undefined;
}
export class StatusResult implements StatusResultOptions {
    readonly statusCode: StatusCode;
    readonly diagnosticInfo: DiagnosticInfo;
    constructor(options?: StatusResultOptions) {
        this.statusCode = options?.statusCode ?? StatusCode.Good;
        this.diagnosticInfo = options?.diagnosticInfo ?? new DiagnosticInfo();
    }
    static [typeId] = NodeIds.StatusResult_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.statusCode);
        encoder.writeType(this.diagnosticInfo);
    }
    static [decode](decoder: BinaryDataDecoder): StatusResult {
        return new StatusResult({
            statusCode: decoder.readType(StatusCode),
            diagnosticInfo: decoder.readType(DiagnosticInfo)
        });
    }
}
export interface SubscriptionDiagnosticsDataTypeOptions {
    sessionId?: NodeId | undefined;
    subscriptionId?: UInt32 | undefined;
    priority?: Byte | undefined;
    publishingInterval?: Double | undefined;
    maxKeepAliveCount?: UInt32 | undefined;
    maxLifetimeCount?: UInt32 | undefined;
    maxNotificationsPerPublish?: UInt32 | undefined;
    publishingEnabled?: boolean | undefined;
    modifyCount?: UInt32 | undefined;
    enableCount?: UInt32 | undefined;
    disableCount?: UInt32 | undefined;
    republishRequestCount?: UInt32 | undefined;
    republishMessageRequestCount?: UInt32 | undefined;
    republishMessageCount?: UInt32 | undefined;
    transferRequestCount?: UInt32 | undefined;
    transferredToAltClientCount?: UInt32 | undefined;
    transferredToSameClientCount?: UInt32 | undefined;
    publishRequestCount?: UInt32 | undefined;
    dataChangeNotificationsCount?: UInt32 | undefined;
    eventNotificationsCount?: UInt32 | undefined;
    notificationsCount?: UInt32 | undefined;
    latePublishRequestCount?: UInt32 | undefined;
    currentKeepAliveCount?: UInt32 | undefined;
    currentLifetimeCount?: UInt32 | undefined;
    unacknowledgedMessageCount?: UInt32 | undefined;
    discardedMessageCount?: UInt32 | undefined;
    monitoredItemCount?: UInt32 | undefined;
    disabledMonitoredItemCount?: UInt32 | undefined;
    monitoringQueueOverflowCount?: UInt32 | undefined;
    nextSequenceNumber?: UInt32 | undefined;
    eventQueueOverFlowCount?: UInt32 | undefined;
}
export class SubscriptionDiagnosticsDataType implements SubscriptionDiagnosticsDataTypeOptions {
    readonly sessionId: NodeId;
    readonly subscriptionId: UInt32;
    readonly priority: Byte;
    readonly publishingInterval: Double;
    readonly maxKeepAliveCount: UInt32;
    readonly maxLifetimeCount: UInt32;
    readonly maxNotificationsPerPublish: UInt32;
    readonly publishingEnabled: boolean;
    readonly modifyCount: UInt32;
    readonly enableCount: UInt32;
    readonly disableCount: UInt32;
    readonly republishRequestCount: UInt32;
    readonly republishMessageRequestCount: UInt32;
    readonly republishMessageCount: UInt32;
    readonly transferRequestCount: UInt32;
    readonly transferredToAltClientCount: UInt32;
    readonly transferredToSameClientCount: UInt32;
    readonly publishRequestCount: UInt32;
    readonly dataChangeNotificationsCount: UInt32;
    readonly eventNotificationsCount: UInt32;
    readonly notificationsCount: UInt32;
    readonly latePublishRequestCount: UInt32;
    readonly currentKeepAliveCount: UInt32;
    readonly currentLifetimeCount: UInt32;
    readonly unacknowledgedMessageCount: UInt32;
    readonly discardedMessageCount: UInt32;
    readonly monitoredItemCount: UInt32;
    readonly disabledMonitoredItemCount: UInt32;
    readonly monitoringQueueOverflowCount: UInt32;
    readonly nextSequenceNumber: UInt32;
    readonly eventQueueOverFlowCount: UInt32;
    constructor(options?: SubscriptionDiagnosticsDataTypeOptions) {
        this.sessionId = options?.sessionId ?? NodeId.null();
        this.subscriptionId = options?.subscriptionId ?? 0;
        this.priority = options?.priority ?? 0;
        this.publishingInterval = options?.publishingInterval ?? 0;
        this.maxKeepAliveCount = options?.maxKeepAliveCount ?? 0;
        this.maxLifetimeCount = options?.maxLifetimeCount ?? 0;
        this.maxNotificationsPerPublish = options?.maxNotificationsPerPublish ?? 0;
        this.publishingEnabled = options?.publishingEnabled ?? false;
        this.modifyCount = options?.modifyCount ?? 0;
        this.enableCount = options?.enableCount ?? 0;
        this.disableCount = options?.disableCount ?? 0;
        this.republishRequestCount = options?.republishRequestCount ?? 0;
        this.republishMessageRequestCount = options?.republishMessageRequestCount ?? 0;
        this.republishMessageCount = options?.republishMessageCount ?? 0;
        this.transferRequestCount = options?.transferRequestCount ?? 0;
        this.transferredToAltClientCount = options?.transferredToAltClientCount ?? 0;
        this.transferredToSameClientCount = options?.transferredToSameClientCount ?? 0;
        this.publishRequestCount = options?.publishRequestCount ?? 0;
        this.dataChangeNotificationsCount = options?.dataChangeNotificationsCount ?? 0;
        this.eventNotificationsCount = options?.eventNotificationsCount ?? 0;
        this.notificationsCount = options?.notificationsCount ?? 0;
        this.latePublishRequestCount = options?.latePublishRequestCount ?? 0;
        this.currentKeepAliveCount = options?.currentKeepAliveCount ?? 0;
        this.currentLifetimeCount = options?.currentLifetimeCount ?? 0;
        this.unacknowledgedMessageCount = options?.unacknowledgedMessageCount ?? 0;
        this.discardedMessageCount = options?.discardedMessageCount ?? 0;
        this.monitoredItemCount = options?.monitoredItemCount ?? 0;
        this.disabledMonitoredItemCount = options?.disabledMonitoredItemCount ?? 0;
        this.monitoringQueueOverflowCount = options?.monitoringQueueOverflowCount ?? 0;
        this.nextSequenceNumber = options?.nextSequenceNumber ?? 0;
        this.eventQueueOverFlowCount = options?.eventQueueOverFlowCount ?? 0;
    }
    static [typeId] = NodeIds.SubscriptionDiagnosticsDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.sessionId);
        encoder.writeUInt32(this.subscriptionId);
        encoder.writeByte(this.priority);
        encoder.writeDouble(this.publishingInterval);
        encoder.writeUInt32(this.maxKeepAliveCount);
        encoder.writeUInt32(this.maxLifetimeCount);
        encoder.writeUInt32(this.maxNotificationsPerPublish);
        encoder.writeBoolean(this.publishingEnabled);
        encoder.writeUInt32(this.modifyCount);
        encoder.writeUInt32(this.enableCount);
        encoder.writeUInt32(this.disableCount);
        encoder.writeUInt32(this.republishRequestCount);
        encoder.writeUInt32(this.republishMessageRequestCount);
        encoder.writeUInt32(this.republishMessageCount);
        encoder.writeUInt32(this.transferRequestCount);
        encoder.writeUInt32(this.transferredToAltClientCount);
        encoder.writeUInt32(this.transferredToSameClientCount);
        encoder.writeUInt32(this.publishRequestCount);
        encoder.writeUInt32(this.dataChangeNotificationsCount);
        encoder.writeUInt32(this.eventNotificationsCount);
        encoder.writeUInt32(this.notificationsCount);
        encoder.writeUInt32(this.latePublishRequestCount);
        encoder.writeUInt32(this.currentKeepAliveCount);
        encoder.writeUInt32(this.currentLifetimeCount);
        encoder.writeUInt32(this.unacknowledgedMessageCount);
        encoder.writeUInt32(this.discardedMessageCount);
        encoder.writeUInt32(this.monitoredItemCount);
        encoder.writeUInt32(this.disabledMonitoredItemCount);
        encoder.writeUInt32(this.monitoringQueueOverflowCount);
        encoder.writeUInt32(this.nextSequenceNumber);
        encoder.writeUInt32(this.eventQueueOverFlowCount);
    }
    static [decode](decoder: BinaryDataDecoder): SubscriptionDiagnosticsDataType {
        return new SubscriptionDiagnosticsDataType({
            sessionId: decoder.readType(NodeId),
            subscriptionId: decoder.readUInt32(),
            priority: decoder.readByte(),
            publishingInterval: decoder.readDouble(),
            maxKeepAliveCount: decoder.readUInt32(),
            maxLifetimeCount: decoder.readUInt32(),
            maxNotificationsPerPublish: decoder.readUInt32(),
            publishingEnabled: decoder.readBoolean(),
            modifyCount: decoder.readUInt32(),
            enableCount: decoder.readUInt32(),
            disableCount: decoder.readUInt32(),
            republishRequestCount: decoder.readUInt32(),
            republishMessageRequestCount: decoder.readUInt32(),
            republishMessageCount: decoder.readUInt32(),
            transferRequestCount: decoder.readUInt32(),
            transferredToAltClientCount: decoder.readUInt32(),
            transferredToSameClientCount: decoder.readUInt32(),
            publishRequestCount: decoder.readUInt32(),
            dataChangeNotificationsCount: decoder.readUInt32(),
            eventNotificationsCount: decoder.readUInt32(),
            notificationsCount: decoder.readUInt32(),
            latePublishRequestCount: decoder.readUInt32(),
            currentKeepAliveCount: decoder.readUInt32(),
            currentLifetimeCount: decoder.readUInt32(),
            unacknowledgedMessageCount: decoder.readUInt32(),
            discardedMessageCount: decoder.readUInt32(),
            monitoredItemCount: decoder.readUInt32(),
            disabledMonitoredItemCount: decoder.readUInt32(),
            monitoringQueueOverflowCount: decoder.readUInt32(),
            nextSequenceNumber: decoder.readUInt32(),
            eventQueueOverFlowCount: decoder.readUInt32()
        });
    }
}
export enum ModelChangeStructureVerbMask {
    NodeAdded = 1,
    NodeDeleted = 2,
    ReferenceAdded = 4,
    ReferenceDeleted = 8,
    DataTypeChanged = 16
}
export interface ModelChangeStructureDataTypeOptions {
    affected?: NodeId | undefined;
    affectedType?: NodeId | undefined;
    verb?: Byte | undefined;
}
export class ModelChangeStructureDataType implements ModelChangeStructureDataTypeOptions {
    readonly affected: NodeId;
    readonly affectedType: NodeId;
    readonly verb: Byte;
    constructor(options?: ModelChangeStructureDataTypeOptions) {
        this.affected = options?.affected ?? NodeId.null();
        this.affectedType = options?.affectedType ?? NodeId.null();
        this.verb = options?.verb ?? 0;
    }
    static [typeId] = NodeIds.ModelChangeStructureDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.affected);
        encoder.writeType(this.affectedType);
        encoder.writeByte(this.verb);
    }
    static [decode](decoder: BinaryDataDecoder): ModelChangeStructureDataType {
        return new ModelChangeStructureDataType({
            affected: decoder.readType(NodeId),
            affectedType: decoder.readType(NodeId),
            verb: decoder.readByte()
        });
    }
}
export interface SemanticChangeStructureDataTypeOptions {
    affected?: NodeId | undefined;
    affectedType?: NodeId | undefined;
}
export class SemanticChangeStructureDataType implements SemanticChangeStructureDataTypeOptions {
    readonly affected: NodeId;
    readonly affectedType: NodeId;
    constructor(options?: SemanticChangeStructureDataTypeOptions) {
        this.affected = options?.affected ?? NodeId.null();
        this.affectedType = options?.affectedType ?? NodeId.null();
    }
    static [typeId] = NodeIds.SemanticChangeStructureDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.affected);
        encoder.writeType(this.affectedType);
    }
    static [decode](decoder: BinaryDataDecoder): SemanticChangeStructureDataType {
        return new SemanticChangeStructureDataType({
            affected: decoder.readType(NodeId),
            affectedType: decoder.readType(NodeId)
        });
    }
}
export interface RangeOptions {
    low?: Double | undefined;
    high?: Double | undefined;
}
export class Range implements RangeOptions {
    readonly low: Double;
    readonly high: Double;
    constructor(options?: RangeOptions) {
        this.low = options?.low ?? 0;
        this.high = options?.high ?? 0;
    }
    static [typeId] = NodeIds.Range_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.low);
        encoder.writeDouble(this.high);
    }
    static [decode](decoder: BinaryDataDecoder): Range {
        return new Range({
            low: decoder.readDouble(),
            high: decoder.readDouble()
        });
    }
}
export interface EUInformationOptions {
    namespaceUri?: UaString | undefined;
    unitId?: Int32 | undefined;
    displayName?: LocalizedText | undefined;
    description?: LocalizedText | undefined;
}
export class EUInformation implements EUInformationOptions {
    readonly namespaceUri?: UaString;
    readonly unitId: Int32;
    readonly displayName: LocalizedText;
    readonly description: LocalizedText;
    constructor(options?: EUInformationOptions) {
        this.namespaceUri = options?.namespaceUri;
        this.unitId = options?.unitId ?? 0;
        this.displayName = options?.displayName ?? new LocalizedText();
        this.description = options?.description ?? new LocalizedText();
    }
    static [typeId] = NodeIds.EUInformation_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.namespaceUri);
        encoder.writeInt32(this.unitId);
        encoder.writeType(this.displayName);
        encoder.writeType(this.description);
    }
    static [decode](decoder: BinaryDataDecoder): EUInformation {
        return new EUInformation({
            namespaceUri: decoder.readString(),
            unitId: decoder.readInt32(),
            displayName: decoder.readType(LocalizedText),
            description: decoder.readType(LocalizedText)
        });
    }
}
export enum AxisScaleEnumeration {
    Linear = 0,
    Log = 1,
    Ln = 2
}
export interface ComplexNumberTypeOptions {
    real?: Float | undefined;
    imaginary?: Float | undefined;
}
export class ComplexNumberType implements ComplexNumberTypeOptions {
    readonly real: Float;
    readonly imaginary: Float;
    constructor(options?: ComplexNumberTypeOptions) {
        this.real = options?.real ?? 0;
        this.imaginary = options?.imaginary ?? 0;
    }
    static [typeId] = NodeIds.ComplexNumberType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeFloat(this.real);
        encoder.writeFloat(this.imaginary);
    }
    static [decode](decoder: BinaryDataDecoder): ComplexNumberType {
        return new ComplexNumberType({
            real: decoder.readFloat(),
            imaginary: decoder.readFloat()
        });
    }
}
export interface DoubleComplexNumberTypeOptions {
    real?: Double | undefined;
    imaginary?: Double | undefined;
}
export class DoubleComplexNumberType implements DoubleComplexNumberTypeOptions {
    readonly real: Double;
    readonly imaginary: Double;
    constructor(options?: DoubleComplexNumberTypeOptions) {
        this.real = options?.real ?? 0;
        this.imaginary = options?.imaginary ?? 0;
    }
    static [typeId] = NodeIds.DoubleComplexNumberType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.real);
        encoder.writeDouble(this.imaginary);
    }
    static [decode](decoder: BinaryDataDecoder): DoubleComplexNumberType {
        return new DoubleComplexNumberType({
            real: decoder.readDouble(),
            imaginary: decoder.readDouble()
        });
    }
}
export interface AxisInformationOptions {
    engineeringUnits?: EUInformation | undefined;
    euRange?: Range | undefined;
    title?: LocalizedText | undefined;
    axisScaleType?: AxisScaleEnumeration | undefined;
    axisSteps?: Double[] | undefined;
}
export class AxisInformation implements AxisInformationOptions {
    readonly engineeringUnits: EUInformation;
    readonly euRange: Range;
    readonly title: LocalizedText;
    readonly axisScaleType: AxisScaleEnumeration;
    readonly axisSteps?: Double[];
    constructor(options?: AxisInformationOptions) {
        this.engineeringUnits = options?.engineeringUnits ?? new EUInformation();
        this.euRange = options?.euRange ?? new Range();
        this.title = options?.title ?? new LocalizedText();
        this.axisScaleType = options?.axisScaleType ?? AxisScaleEnumeration.Linear;
        this.axisSteps = options?.axisSteps;
    }
    static [typeId] = NodeIds.AxisInformation_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.engineeringUnits);
        encoder.writeType(this.euRange);
        encoder.writeType(this.title);
        encoder.writeUInt32(this.axisScaleType);
        encoder.writeDoubleArray(this.axisSteps);
    }
    static [decode](decoder: BinaryDataDecoder): AxisInformation {
        return new AxisInformation({
            engineeringUnits: decoder.readType(EUInformation),
            euRange: decoder.readType(Range),
            title: decoder.readType(LocalizedText),
            axisScaleType: decoder.readUInt32(),
            axisSteps: decoder.readDoubleArray()
        });
    }
}
export interface XVTypeOptions {
    x?: Double | undefined;
    value?: Float | undefined;
}
export class XVType implements XVTypeOptions {
    readonly x: Double;
    readonly value: Float;
    constructor(options?: XVTypeOptions) {
        this.x = options?.x ?? 0;
        this.value = options?.value ?? 0;
    }
    static [typeId] = NodeIds.XVType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeDouble(this.x);
        encoder.writeFloat(this.value);
    }
    static [decode](decoder: BinaryDataDecoder): XVType {
        return new XVType({
            x: decoder.readDouble(),
            value: decoder.readFloat()
        });
    }
}
export interface ProgramDiagnosticDataTypeOptions {
    createSessionId?: NodeId | undefined;
    createClientName?: UaString | undefined;
    invocationCreationTime?: Date | undefined;
    lastTransitionTime?: Date | undefined;
    lastMethodCall?: UaString | undefined;
    lastMethodSessionId?: NodeId | undefined;
    lastMethodInputArguments?: Argument[] | undefined;
    lastMethodOutputArguments?: Argument[] | undefined;
    lastMethodCallTime?: Date | undefined;
    lastMethodReturnStatus?: StatusResult | undefined;
}
export class ProgramDiagnosticDataType implements ProgramDiagnosticDataTypeOptions {
    readonly createSessionId: NodeId;
    readonly createClientName?: UaString;
    readonly invocationCreationTime: Date;
    readonly lastTransitionTime: Date;
    readonly lastMethodCall?: UaString;
    readonly lastMethodSessionId: NodeId;
    readonly lastMethodInputArguments?: Argument[];
    readonly lastMethodOutputArguments?: Argument[];
    readonly lastMethodCallTime: Date;
    readonly lastMethodReturnStatus: StatusResult;
    constructor(options?: ProgramDiagnosticDataTypeOptions) {
        this.createSessionId = options?.createSessionId ?? NodeId.null();
        this.createClientName = options?.createClientName;
        this.invocationCreationTime = options?.invocationCreationTime ?? new Date(-11644473600000);
        this.lastTransitionTime = options?.lastTransitionTime ?? new Date(-11644473600000);
        this.lastMethodCall = options?.lastMethodCall;
        this.lastMethodSessionId = options?.lastMethodSessionId ?? NodeId.null();
        this.lastMethodInputArguments = options?.lastMethodInputArguments;
        this.lastMethodOutputArguments = options?.lastMethodOutputArguments;
        this.lastMethodCallTime = options?.lastMethodCallTime ?? new Date(-11644473600000);
        this.lastMethodReturnStatus = options?.lastMethodReturnStatus ?? new StatusResult();
    }
    static [typeId] = NodeIds.ProgramDiagnosticDataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.createSessionId);
        encoder.writeString(this.createClientName);
        encoder.writeDateTime(this.invocationCreationTime);
        encoder.writeDateTime(this.lastTransitionTime);
        encoder.writeString(this.lastMethodCall);
        encoder.writeType(this.lastMethodSessionId);
        encoder.writeTypeArray(this.lastMethodInputArguments);
        encoder.writeTypeArray(this.lastMethodOutputArguments);
        encoder.writeDateTime(this.lastMethodCallTime);
        encoder.writeType(this.lastMethodReturnStatus);
    }
    static [decode](decoder: BinaryDataDecoder): ProgramDiagnosticDataType {
        return new ProgramDiagnosticDataType({
            createSessionId: decoder.readType(NodeId),
            createClientName: decoder.readString(),
            invocationCreationTime: decoder.readDateTime(),
            lastTransitionTime: decoder.readDateTime(),
            lastMethodCall: decoder.readString(),
            lastMethodSessionId: decoder.readType(NodeId),
            lastMethodInputArguments: decoder.readTypeArray(Argument),
            lastMethodOutputArguments: decoder.readTypeArray(Argument),
            lastMethodCallTime: decoder.readDateTime(),
            lastMethodReturnStatus: decoder.readType(StatusResult)
        });
    }
}
export interface ProgramDiagnostic2DataTypeOptions {
    createSessionId?: NodeId | undefined;
    createClientName?: UaString | undefined;
    invocationCreationTime?: Date | undefined;
    lastTransitionTime?: Date | undefined;
    lastMethodCall?: UaString | undefined;
    lastMethodSessionId?: NodeId | undefined;
    lastMethodInputArguments?: Argument[] | undefined;
    lastMethodOutputArguments?: Argument[] | undefined;
    lastMethodInputValues?: Variant[] | undefined;
    lastMethodOutputValues?: Variant[] | undefined;
    lastMethodCallTime?: Date | undefined;
    lastMethodReturnStatus?: StatusResult | undefined;
}
export class ProgramDiagnostic2DataType implements ProgramDiagnostic2DataTypeOptions {
    readonly createSessionId: NodeId;
    readonly createClientName?: UaString;
    readonly invocationCreationTime: Date;
    readonly lastTransitionTime: Date;
    readonly lastMethodCall?: UaString;
    readonly lastMethodSessionId: NodeId;
    readonly lastMethodInputArguments?: Argument[];
    readonly lastMethodOutputArguments?: Argument[];
    readonly lastMethodInputValues?: Variant[];
    readonly lastMethodOutputValues?: Variant[];
    readonly lastMethodCallTime: Date;
    readonly lastMethodReturnStatus: StatusResult;
    constructor(options?: ProgramDiagnostic2DataTypeOptions) {
        this.createSessionId = options?.createSessionId ?? NodeId.null();
        this.createClientName = options?.createClientName;
        this.invocationCreationTime = options?.invocationCreationTime ?? new Date(-11644473600000);
        this.lastTransitionTime = options?.lastTransitionTime ?? new Date(-11644473600000);
        this.lastMethodCall = options?.lastMethodCall;
        this.lastMethodSessionId = options?.lastMethodSessionId ?? NodeId.null();
        this.lastMethodInputArguments = options?.lastMethodInputArguments;
        this.lastMethodOutputArguments = options?.lastMethodOutputArguments;
        this.lastMethodInputValues = options?.lastMethodInputValues;
        this.lastMethodOutputValues = options?.lastMethodOutputValues;
        this.lastMethodCallTime = options?.lastMethodCallTime ?? new Date(-11644473600000);
        this.lastMethodReturnStatus = options?.lastMethodReturnStatus ?? new StatusResult();
    }
    static [typeId] = NodeIds.ProgramDiagnostic2DataType_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeType(this.createSessionId);
        encoder.writeString(this.createClientName);
        encoder.writeDateTime(this.invocationCreationTime);
        encoder.writeDateTime(this.lastTransitionTime);
        encoder.writeString(this.lastMethodCall);
        encoder.writeType(this.lastMethodSessionId);
        encoder.writeTypeArray(this.lastMethodInputArguments);
        encoder.writeTypeArray(this.lastMethodOutputArguments);
        encoder.writeTypeArray(this.lastMethodInputValues);
        encoder.writeTypeArray(this.lastMethodOutputValues);
        encoder.writeDateTime(this.lastMethodCallTime);
        encoder.writeType(this.lastMethodReturnStatus);
    }
    static [decode](decoder: BinaryDataDecoder): ProgramDiagnostic2DataType {
        return new ProgramDiagnostic2DataType({
            createSessionId: decoder.readType(NodeId),
            createClientName: decoder.readString(),
            invocationCreationTime: decoder.readDateTime(),
            lastTransitionTime: decoder.readDateTime(),
            lastMethodCall: decoder.readString(),
            lastMethodSessionId: decoder.readType(NodeId),
            lastMethodInputArguments: decoder.readTypeArray(Argument),
            lastMethodOutputArguments: decoder.readTypeArray(Argument),
            lastMethodInputValues: decoder.readTypeArray(Variant),
            lastMethodOutputValues: decoder.readTypeArray(Variant),
            lastMethodCallTime: decoder.readDateTime(),
            lastMethodReturnStatus: decoder.readType(StatusResult)
        });
    }
}
export interface AnnotationOptions {
    message?: UaString | undefined;
    userName?: UaString | undefined;
    annotationTime?: Date | undefined;
}
export class Annotation implements AnnotationOptions {
    readonly message?: UaString;
    readonly userName?: UaString;
    readonly annotationTime: Date;
    constructor(options?: AnnotationOptions) {
        this.message = options?.message;
        this.userName = options?.userName;
        this.annotationTime = options?.annotationTime ?? new Date(-11644473600000);
    }
    static [typeId] = NodeIds.Annotation_Encoding_DefaultBinary as const;
    [encode](encoder: BinaryDataEncoder): void {
        encoder.writeString(this.message);
        encoder.writeString(this.userName);
        encoder.writeDateTime(this.annotationTime);
    }
    static [decode](decoder: BinaryDataDecoder): Annotation {
        return new Annotation({
            message: decoder.readString(),
            userName: decoder.readString(),
            annotationTime: decoder.readDateTime()
        });
    }
}
export enum ExceptionDeviationFormat {
    AbsoluteValue = 0,
    PercentOfValue = 1,
    PercentOfRange = 2,
    PercentOfEURange = 3,
    Unknown = 4
}
